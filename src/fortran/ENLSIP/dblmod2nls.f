C
C     DOUBLE PRECISION VERSION 880505
CGIVEN1
      SUBROUTINE GIVEN1(Z1,Z2,C,S,SIG)
      DOUBLE PRECISION
     *     Z1,Z2,C,S,SIG
C
C     COMPUTE GIVENS ROTATIONS MATRIX SUCH THAT
C
C     (C  S)(Z1) = (+SIG)   WHERE SIG=DSQRT(Z1**2+Z2**2)
C     (S -C)(Z2) = ( 0  )
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     GAMMA,GAMMA2
      IF(Z2.EQ.0.0D0) GOTO 10
      GAMMA2=Z1*Z1+Z2*Z2
      GAMMA=DSQRT(GAMMA2)
      C=Z1/GAMMA
      S=Z2/GAMMA
      SIG=GAMMA
      RETURN
   10 CONTINUE
      C=SIGN(1.0D0,Z1)
      S=0.0D0
      SIG=ABS(Z1)
      RETURN
      END
c
C     DOUBLE PRECISION VERSION 910326
C
CNLSNIP
      SUBROUTINE NLSNIP(X,N,MDC,MDA,MDG,MDF,M,P,L,TOL,W,EPSREL,
     1 EPSABS,EPSX,EPSH,IPRINT,NOUT,MAXIT,NORM,SCALE,SEC,FFUNC,HFUNC,
     2 EXIT,PHI,K,FUNCEV,JACEV,SECEV,LINEV,RANKA,RANK,F,H,
     3 ACTIVE,SPEED,
     4 P1,P2,P3,INACT,P4,B,D1,D2,D3,DIAG,G,PIVOT,DX,V,U,S,WOLD,A,
     5 D,V1,V2,C,FMAT,GMAT                               )
      INTEGER N,MDC,MDA,MDG,MDF,M,P,L,IPRINT,NOUT,MAXIT,NORM,SCALE,
     1 EXIT,K,FUNCEV,JACEV,SECEV,LINEV,RANKA,RANK
      INTEGER ACTIVE(1),P1(1),P2(1),P3(N),INACT(1),P4(1)
      DOUBLE PRECISION
     *     TOL,EPSREL,EPSABS,EPSX,EPSH,PHI,SPEED
      DOUBLE PRECISION
     *     X(N),W(1),F(1),H(1),B(1),D1(1),D2(1),D3(N),DIAG(1),G(N),
     1 PIVOT(N),DX(N),V(1),U(N),S(1),WOLD(1),A(MDA,N),D(1),V1(1),
     2 V2(1),C(MDC,N),FMAT(MDF,N),GMAT(MDG,N)
      LOGICAL SEC
      EXTERNAL FFUNC,HFUNC
C
C   *****************************************************************
C   * NLSNIP IS DEVELOPED BY PER LINDSTR@M AND PER-$KE WEDIN AT THE *
C   * INSTITUTE OF INFORMATION PROCESSING UNIVERSITY OF UME$,       *
C   * S-90187 UME$, SWEDEN                                          *
C   *****************************************************************
C
C   PURPOSE...
C
C     SOLVE THE NONLINEAR LEAST SQUARES PROBLEM
C
C     MINIMIZE  0.5* II F(X) II**2
C        X
C        SUBJECT TO THE NONLINEAR CONSTRAINTS
C     H (X) = 0     I=1,2,.....,P    (P<=N)
C      I
C
C     H (X)   >= 0  J=P+1,....,L  (L>=P) , (M+P)>= N
C      J
C
C     WHERE F(X) IS M-DIMENSIONAL AND X IS N-DIMENSIONAL
C
C     THE DIMENSION OF SOME ARRAYS IN THE CALLING PROGRAM DEPEND
C     ON BND=MIN(L,N)
C
C     ON ENTRY@D
C
C     X()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING A FIRST APPROXIMATION OF THE SOLUTION POINT
C     N       INTEGER SCALAR CONTAINING THE NUMBER OF PARAMETERS
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     MDG     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY GMAT
C     MDF     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY FMAT
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS IN F(X)
C     P       INTEGER SCALAR CONTAINING NUMBER OF EQUALITY CONSTRAINTS
C     L       INTEGER SCALAR CONTAINING THE TOTAL NUMBER OF CONSTRAINTS
C     TOL     REAL SCALAR CONTAING A SMALL VALUE >0 USED TO
C             DETERMINE PSEUDO RANKS OF MATRICES
C     W()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING VALUES >=0 USED AS FIRST PENALTY CONSTANTS
C             IN THE MERIT FUNCTION. IF AN ELEMENT IS <=0.0 THE FIRST
C             PENALTY CONSTANT IS CHOSEN AUTOMATICALLY
C     EPSREL  THEY ARE ALL REAL SCALARS CONTAINING SMALL POSITIVE
C     EPSABS  VALUES USED TO TEST CONVERGENCE
C     EPSX    RECOMMENDED VALUES ARE
C     EPSH    EPSREL=EPSX=EPSH=10**(-3),  EPSABS=10**(-10)
C     IPRINT  INTEGER SCALAR CONTAINING A CODE TO CONTROL
C             PRINTING INSIDE THIS ROUTINE
C             IF IPRINT<=0 THEN NO PRINTING IS DONE
C                         ELSE CERTAIN INFORMATION IS PRINTED EVERY
C                              IPRINT ITERATION ON UNIT NOUT
C     NOUT    INTEGER SCALAR CONTAINING LOGICAL UNIT NUMBER WHERE
C             PRINTING CAN BE DONE (RECORD LENGHT MUST NOT BE LESS
C             THAN 125)
C     MAXIT   INTEGER SCALAR CONTAINING MAXIMUM ALLOWED ITERATIONS
C     NORM    INTEGER SCALAR CONTAINING A CODE THAT CONTROLS WHICH
C             NORM THAT SHOULD BE USED WHEN PENALTY WEIGHTS ARE UPDATED
C             = 0 IF MAXIMUM NORM
C             = 2 IF EUCLIDEAN NORM
C     SCALE   INTEGER SCALAR =1 IF SCALING SHOULD BE DONE OF THE
C             ROWS IN THE CONSTRAINT MATRIX (MATRIX A)
C             =0 IF NO SCALING SHOULD BE DONE
C     SEC     LOGICAL SCALAR = TRUE IF SECOND DERIVATIVES ARE ALLOWED
C             =FALSE IF SECOND DERIVATIVES ARE NOT ALLOWED
C     FFUNC        SUBROUTINE NAME-USER WRITTEN SUBROUTINE WHICH
C                  EVALUATES THE FUNCTION F(X)
C     HFUNC        SUBROUTINE NAME-USER WRITTEN SUBROUTINE WHICH
C                  EVALUATES THE CONSTRAINTS H(X)
C                  BOTH FFUNC AND HFUNC MUST BE WRITTEN AS FOLLOWS
C                  (WITH THE OBVIOUS CHANGES FOR HFUNC)
C
C                  SUBROUTINE FFUNC(X,N,F,M,CTRL,C,MDC)
C                  INTEGER N,M,CTRL,MDC
C                  REAL X(N),F(M),C(MDC,N)
C                  -----------------------
C                  CTRL CAN HAVE 3 DIFFERENT VALUES ON ENTRY
C         CTRL= 1  MEANS EVALUATE THE FUNCTIONS AT THE POINT X AND
C                  RETURN THIS VECTOR IN THE ARRAY F IF THE FUNCTIONS
C                  ARE COMPUTABLE.
C                  ON RETURN THE USER CAN INDICATE UNCOMPUTABILITY BY
C                  SETTING CTRL=-1
C                  DO NOT ALTER ARRAY X.
C         CTRL=-1  MEANS EVALUATE THE FUNCTIONS AT THE POINT X AND
C                  RETURN THIS VECTOR IN THE ARRAY F IF THE FUNCTIONS
C                  ARE COMPUTABLE. DO NOT ALTER ARRAY X.
C                  POSSIBLE UNCOMPUTABILITY OF THE FUNCTIONS MUST BE
C                  INDICATED BY SETTING CTRL TO A VALUE <-10 ON RETURN
C         CTRL= 2  MEANS CALCULATE THE JACOBIAN OF F(X) AT THE POINT X
C                  AND RETURN THIS MATRIX IN THE ARRAY C IF THE JACOBIAN
C                  IS SUPPLIED ANALYTICALLY.
C                  POSSIBLE UNCOMPUTABILITY OF THE JACOBIAN MUST BE
C                  INDICATED BY SETTING CTRL TO A VALUE <-10 ON RETURN
C                  IF THE USER WANTS THE JACOBIAN BEING COMPUTED
C                  NUMERICALLY THAT SHOULD BE INDICATED BY SETTING
C                  CTRL=0 ON RETURN.
C                  DO NOT ALTER ARRAYS X AND F.
C                  ------------------------------
C                  RETURN
C                  END
C
C     ON RETURN@D    AND EXIT.NE.-1  AND  EXIT.GE.-10
C
C     X()     CONTAINS THE TERMINATION POINT (HOPEFULLY THE SOLUTION)
C     P       CONTAINS NUMBER OF ACTIVE CONSTRAINTS AT X
C     W()     CONTAINS THE FINAL PENALTY CONSTANTS
C     EXIT    INTEGER SCALAR-CONTAINS A TERMINATION CODE REPRESENTING
C             THE TERMINATION CRITERIA DESCRIBED BELOW
C             =10000 IF CRITERION 4) IS SATISFIED
C             = 2000 IF CRITERION 5) IS SATISFIED
C             =  300 IF CRITERION 6) IS SATISFIED
C             =   40 IF CRITERION 7) IS SATISFIED
C             =    X IF CRITERION 8) IS SATISFIED
C                    WHERE X= 0,1,2,3 OR 4
C             EXIT CAN ALSO BE A SUM OF THE ABOVE CODES TO INDICATE
C             THAT MORE THAN ONE CRITERION IS SATISFIED
C
C             IF ANY OF THE ABNORMAL CRITERIA IS SATISFIED EXIT IS
C             SET TO
C
C             =   -1 IF IMPROPER DATA ON ENTRY TO THIS ROUTINE
C             =   -2 IF CRITERION  9) IS SATISFIED
C             =   -3 IF convergence to a non-feasible point!!!!
C             =   -4 IF CRITERION 11) IS SATISFIED
C             =   -5 IF CRITERION 12) IS SATISFIED
C             =   -6 IF CRITERION 13) IS SATISFIED
C             =   -7 IF RESIDUALS OR CONSTRAINTS ARE UNCOMPUTABLE AT X
C             =   -8 IF MORE THAN N CONSTRAINTS IN FIRST WORKING
C                    SET (CHOOSE A BETTER STARTING POINT)
C             =   -9 IF TOO MANY(>5) NEWTON STEPS HAVE BEEN USED
c             =  -10 if not possible to satisfy the constraints
C             < -10  TERMINATION DUE TO USER STOP INDICATOR
C     THERE ARE CONVERGENCE CRITERIA AND ABNORMAL TERMINATION
C     CRITERIA
C     THE CONVERGENCE CRITERIA ARE ONLY TESTED IF THE LATEST STEP
C     WAS TAKEN ALONG A GAUSS-NEWTON DIRECTION WITH FULL PSEUDO RANK
C     OR IF THE METHOD OF NEWTON HAS BEEN USED IN THE LATEST STEP.
C     OF COURCE THE STEP MUST NOT BE A RESTART STEP WHEN CONVERGENCE
C     SHOULD BE TESTED
C
C     A SEARCH DIRECTION USING GAUSS-NETON'S METHOD IS COMPUTED
C     BY SOLVING FOR DX    A*DX = -H
C                          C*DX APPR.= -F
C     A FIRST ORDER ESTIMATE OF THE LAGRANGE MULTIPLIERS (V) HAS BEEN
C     COMPUTED BY SOLVING FOR V     T
C                                  A *V APPR.= G (THE GRADIENT )
C     WHERE
C                     T                 -1   T
C           (L@D0) = P1 *A*Q1      DY1= L  *P1 *(-H)
C                                       T
C           (C1@DC2) = C*Q1      (U) = Q3 *C2*P3
C                               (0)
C                    T
C           D=(D1)=Q3 *(-F-C1*DY1)
C             (D2)
C
C     A NECESSARY CONDITION FOR CONVERGENCE IS THAT CONDITIONS
C     1)-3) BELOW ARE SATISFIED
C
C     THE CONVERGENCE CRITERIA ARE
C
C      1) II H(X) II < EPSH   (WHERE ONLY CONSTRAINTS IN THE WORKING
C             T                SET ARE CONSIDERED)
C      2) II A *V -G II < EPSREL*(1.0+II G(X) II)
C      3) SIGMIN >= EPSREL*ABSVMX
C                >= EPSREL*(1+II F(X) II**2)  (IF 1 INEQUALITY)
C      4) II D1 II**2 <= EPSREL**2*II F(X) II**2
C      5) II F(X) II**2 <= EPSABS**2
C      6) II X(K-1)-X(K) II < EPSX*II X(K) II   ( TIME STEP K)
C      7) DSQRT(DRELPR)/II DX(GN) II >0.25 (GN=GAUSS NEWTON)
C      8) THE LAST DIGIT IN THE CONVERGENCE CODE (SEE ABOVE) INDICATES
C         HOW THE LAST STEPS WERE COMPUTED
C        = 0 NO TROUBLE (GAUSS-NEWTON THE LAST 3 STEPS)
C        = 1 RANKA<T OR RANKC2<(N-T) AT THE TERMINATION POINT
C            NO 2@DND DERIVATIVES HAS BEEN USED
C        = 2 THE METHOD OF NEWTON WAS USED (AT LEAST) IN THE LAST STEP
C        = 3 THE 2@DND BUT LAST STEP WAS SUBSPACE MINIMIZATION STEP
C            BUT THE LAST TWO WERE GAUSS-NEWTON STEPS
C        = 4 THE STEPLENGTH WAS NOT UNIT IN BOTH THE LAST 2 STEPS
C
C     THE ABNORMAL TERMINATION CRITERIA ARE
C
C      9) NUMBER OF ITERATIONS EXCEEDS THE MAXIMUM NUMBER
C     10) THE REDUCED HESSIAN EMANATING FROM THE METHOD OF NEWTON
C         IS NOT POSITIVE DEFINTE
C     11) THE USER HAS NOT ALLOWED USE OF 2@DND DERIVATIVES (NEWTON)
C     12) UNDAMPED NEWTON STEP FAILS
C     13) THE LATEST DX(GN) IS NOT A DESCENT DIRECTION TO THE MERIT
C         FUNCTION (PROBABLY CAUSED BY MISSCALCULATED JACOBIAN)
C
C     PHI     REAL SCALAR-CONTAINS THE VALUE OF THE OBJECTIVE
C             FUNCTION AT THE POINT X
C     K       INTEGER SCALAR-CONTAINS NUMBER OF ITERATIONS UNTIL
C             TERMINATION
C     FUNCEV  INTEGER SCALAR-CONTAINS TOTAL NUMBER OF FUNCTION
C             EVALUATIONS DONE
C     JACEV   INTEGER SCALAR-CONTAINS NUMBER OF EVALUATIONS OF
C             JACOBIANS
C     SECEV   INTEGER SCALAR-CONTAINS NUMBER OF FUNCTION EVALUATIONS
C             CAUSED BY 2@DND DERIVATIVE COMPUTATION USING DIFFERENCES
C     LINEV   INTEGER SCALAR-CONTAINS NUMBER OF FUNCTION EVALUATIONS
C             CAUSED BY THE LINESEARCH ROUTINE
C     RANKA   INTEGER SCALAR-CONTAINS ESTIMATED PSEUDO RANK OF THE
C             CONSTRAINT MATRIX (MATRIX A) AT THE TERMINATION POINT
C             RANKA=P IF FULL RANK
C     RANK    INTEGER SCALAR-CONTAINS ESTIMATED PSEUDO RANK OF THE
C             COMPOUND MATRIX (A) AT THE TERMINATION POINT
C                             (C)
C             RANK=N IF FULL RANK
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M+L
C             CONTAINS THE VALUE OF THE RESIDUALS AT THE POINT X
C             AS THE FIRST M ELEMENTS
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINS THE VALUE OF THE CONSTRAINTS AT THE POINT X
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION BND+L
C             CONTAINS INDECES FOR ACTIVE CONSTRAINTS AT THE POINT X
C             SUCH THAT ACTIVE(I) I=1,2,....,P ARE THE INDECES FOR THE
C             ACTIVE CONSTRAINTS
C     SPEED   REAL SCALAR-CONTAINS AN ESTIMATE OF THE CONVERGENCE
C             FACTOR (SHOULD BE <1 , >0 )
C
C     WORKING AREAS@D
C
C     P1(),P2() INTEGER SINGLY SUBSCRIPTED ARRAYS OF DIMENSION BND
C     P3()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C     INACT(),P4() INTEGER SINGLY SUBSCRIPTED ARRAYS OF DIMENSION L
C     WOLD()      REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C     S()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION MAX(L,N)
C     B(),D1(),D2(),V() REAL SINGLY SUBSCRIPTED ARRAYS OF DIMENSION BND
C     G(),PIVOT(),D3() REAL SINGLY SUBSCRIPTED ARRAYS OF DIMENSION N
C     DIAG(),DX(),U() REAL SINGLY SUBSCRIPTED ARRAYS OF DIMENSION N
C     D(),V1(),V2() REAL SINGLY SUBSCRIPTED ARRAYS OF DIMENSION M+L
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*N
C             MDC>=M
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             MDA>=L
C     FMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDF*N
C             MDF>=N (IF ONLY EQUALITY CONSTRAINTS FMAT CAN BE A SCALAR)
C     GMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDG*N
C             MDG>=N
C
C
C     COMMON VARIABLES CONTAINING INFORMATION CONCERNING PREVIOUS
C     TWO POINTS. THE SUFFICES KM2 AND KM1 IN THE NAMES OF THE
C     VARIABLES REPRESENT TIME STEP K-2 AND K-1 RESPECTIVELY.
C     THESE VARIABLES ARE UPDATED ONLY INSIDE THE ROUTINE EVREST
C
      INTEGER RKAKM2,RKCKM2,KODKM2,RKAKM1,RKCKM1,KODKM1,TKM2,TKM1
      DOUBLE PRECISION
     *     BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,ALFKM2,
     1 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     2 PGRESS,PRELIN
      COMMON /PREC/ BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,
     1 ALFKM2,RKAKM2,RKCKM2,TKM2,KODKM2,
     2 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     3 RKAKM1,RKCKM1,TKM1,KODKM1,
     4 PGRESS,PRELIN
C
C     COMMON VARIABLES CONTAINING INFORMATION OF RESTART STEPS
C
      DOUBLE PRECISION
     *    BESTRK,BESTPG
      INTEGER NRREST,LATTRY
      COMMON /BACK/ BESTRK,BESTPG, NRREST,LATTRY
      integer ifree
      common /negdir/ ifree
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     THIS PROGRAM PACKAGE USES THE FOLLOWING LINPACK AND BLAS ROUTINES
C
C     DPOSL,DCHDC,DNRM2,DAXPY,DDOT,DSWAP
C
C
C     INTERNAL VARIABLES
C
      INTEGER ERROR,CODE,CTRLF,CTRLH,T,BND,LMT,NOHOUS,TIME,RANKC2,IND,
     1 EVAL,DIMA,DIMC2
      DOUBLE PRECISION
     *     TAU,XDIFF,ALPHA,HSUM,FSUM,XNORM,GRES,DXNORM,ALFNOI,GNDNRM,
     1 B1NRM,D1NRM,DNRM,PSI,GNORM,BETAK,SUCCES,ALFLOW,ALFUPP,ABSVMX,
     2 SIGMIN,DNRM2,SACTH,athnrm,whnrm2,sss
      LOGICAL RESTAR,ADD,DEL
C
C     VALIDATE INPUT VALUES
C
      EXIT=0
      IF((M+L).LT.N .OR. N.LE.0 .OR. M.LE.0 .OR. MDC.LT.M) EXIT=-1
      IF(P.GT.N .OR. P.LT.0 .OR. L.LT.P .OR. MDA.LT.L) EXIT=-1
      IF(MDG.LT.N .OR. MAXIT.LE.0 .OR. NORM.LT.0 .OR. NORM.GT.2)EXIT=-1
      IF((L.GT.P) .AND. (MDF.LT.N)) EXIT=-1
      IF(TOL.LT.0.0D0 .OR. SCALE.LT.0 .OR. EPSREL.LT.0.0D0) EXIT=-1
      IF(EPSABS.LT.0.0D0 .OR. EPSX.LT.0.0D0 .OR. EPSH.LT.0.0D0) EXIT=-1
      IF(EPSREL+EPSABS+EPSX+EPSH .LE. 0.0D0) EXIT=-1
C
C     COMPUTE DRELPR = DOUBLE RELATIVE PRECISION
C
      CALL RELEPS(DRELPR)
c
c     because of a local area in the subroutine eucnrm
c
      if(n.gt.100)norm=0
C
C     INITIATE VARIABLES
C
      K=0
      ifree=0
      BND=MIN0(L,N)
      ERROR=0
      FUNCEV=0
      JACEV=0
      SECEV=0
      LINEV=0
      NRREST=0
      RESTAR=.FALSE.
      KODKM2=1
      ALFKM2=1.0D0
      KODKM1=1
      TAU=TOL
      XDIFF=DNRM2(N,X,1)*2.0D0*EPSX
C
C     EVALUATE AT USER SUPPLIED STARTING POINT
C
      CTRLF=1
      CALL FFUNC(X,N,F,M,CTRLF,C,MDC)
      CTRLH=1
      CALL HFUNC(X,N,H,L,CTRLH,A,MDA)
      FUNCEV=FUNCEV+1
      IF((-1.EQ.CTRLF).OR.(-1.EQ.CTRLH)) EXIT=-7
      IF(EXIT.LT.0) RETURN
C
C     CONSTRUCT FIRST WORKING SET AND INITIATE PENALTY
C     CONSTANTS (IF MORE THAN N CONSTRAINTS<=0 EXIT IS SET TO -8)
C
      CALL INIALC(P,L,H,ACTIVE,T,BND,NORM,INACT,LMT,W,WOLD,EXIT)
      IF(EXIT.LT.0) RETURN
      RKCKM1=N-T
      ALFKM1=1.0D0
      LATTRY=N
      BESTPG=0.0D0
      RKAKM1=T
      TKM1=T
      ADD=.FALSE.
      FSUM=DNRM2(M,F,1)**2
      FSQKM1=FSUM
      HSQKM1=SACTH(H,ACTIVE,T)
C
C     START OF MAIN LOOP FOR THE ITERATION
C
   10 CONTINUE
      if((-5.eq.error).or.(-3.eq.error)) error=0
      IF(RESTAR) GOTO 20
C
C     COMPUTE JACOBIANS AT THE CURRENT POINT AND SET B=-H
C
      CALL NEWPNT(X,N,H,L,F,M,HFUNC,FFUNC,MDA,MDC,
     1 FUNCEV,A,C,B,D,ERROR)
      IF(ERROR.LT.(-10)) GOTO 40
      JACEV=JACEV+1
c
c     compute the 2-norm of A(T)**h for the active set
c
      athnrm=0.0d0
      if(t.eq.0) goto 17
      do 15 j=1,n
       sss=0.0d0
       do 13 i=1,t
        ii=active(i)
        sss=sss+a(ii,j)*h(ii)
   13  continue
       athnrm=athnrm+sss*sss
   15 continue
      athnrm=sqrt(athnrm)
   17 continue
C
C     MOVE CONSTRAINTS IN THE CURRENT WORKING SET AT THE TOP
C     OF THE ARRAY B AND THE CORRESPONDING GRADIENTS AT THE
C     TOP OF ARRAY A
C
      CALL EQUAL(B,L,A,MDA,N,ACTIVE,T,P,P4)
C
C     COMPUTE THE GRADIENT OF THE OBJECTIVE FUNCTION
C
      CALL GRAD(C,MDC,M,N,F,G)
      GNORM=DNRM2(N,G,1)
C
C     SCALE THE MATRIX A BY MAKING THE ROWS OF A HAVING
C     UNIT LENGTH IF INTERNAL SCALING IS INDICATED
C
      CALL EVSCAL(SCALE,A,MDA,T,N,B,DIAG)
      XNORM=DNRM2(N,X,1)
      PHI=0.5D0*FSUM
C
C     DETERMINE THE CURRENT WORKING SET AND CORRESPONDING GN-SEARCH
C     DIRECTION (DX)
C
      CALL WRKSET(A,MDA,T,P,N,G,B,TAU,MDF,SCALE,K,DIAG,
     1 ACTIVE,BND,INACT,LMT,H,GNDNRM,P4,C,MDC,M,F,MDG,
     2 X,HFUNC,FFUNC,FUNCEV,JACEV,
     3 P2,P3,DX,V1,D2,D3,RANKC2,D1NRM,DNRM,B1NRM,D,GMAT,
     4 P1,V,D1,FMAT,RANKA,GRES,NOHOUS,TIME,DEL,PIVOT,V2,S,U)
*      write(10,*) 'Search direction'
*      write(10,*) (dx(i),i=1,n)
C
C     COMPUTE THE SQUARE SUM OF THE CONSTRAINTS IN THE
C     WORKING SET
C
      HSUM=SACTH(H,ACTIVE,T)
      GNDNRM=DNRM
      DXNORM=DNRM2(N,DX,1)
      ALFNOI=DSQRT(DRELPR)/(DXNORM+DRELPR)
C
C     COMPUTE SIGMIN=MIN(V(I)) WHERE I CORRRESPOND TO
C     CONSTRAINTS DEFINED AS INEQUALITIES
C     ABSVMX=MAX(DABS(V(I))  , I=1,2,.....,T
C
      CALL MINMAX(P,T,V,SCALE,DIAG,SIGMIN,ABSVMX)
C
C     IF THE METHOD OF NEWTON WAS USED IN THE LATEST STEP
C     IT MAY HAPPEN THAT IT FAILS
C     IF IT FAILS GN is used for at least 5 steps
C
      IF(KODKM1.NE.2) GOTO 20
      SUCCES=D1KM1-D1NRM
      IF(RKCKM1.NE.RANKC2) GOTO 20
      IF(SUCCES.LT.0.0D0) then
       ifree=5
       nrrest=0
       goto 10
      endif
   20 CONTINUE
C
C     CHECK MAIN TERMINATION CRITERIA
C
      CALL TERCRI(RANKA,RANKC2,ERROR,P,T,N,RESTAR,DEL,MAXIT,K,
     1 FSUM,D1NRM,HSUM,GRES,XNORM,GNORM,ALFNOI,H,INACT,LMT,
     2 XDIFF,EPSABS,EPSREL,EPSX,EPSH,SIGMIN,ABSVMX,WOLD,X,
     3 athnrm,whnrm2,EXIT)
C
C     IF EXIT<>0 THE ITERATION IS FINISHED
C
      IF(EXIT.NE.0) GOTO 30
C
C     ANALYSE THE PAST AND RECOMPUTE THE SEARCH DIRECTION
C     IF NECESSARY
C
      CALL ANALYS(K,RESTAR,CODE,FSUM,D1NRM,DNRM,C,MDC,M,N,RANKC2,
     1 D,F,P3,D3,ACTIVE,V,INACT,LMT,P4,TIME,A,MDA,P,T,RANKA,B1NRM,
     2 HSUM,NOHOUS,D1,P1,D2,P2,B,H,L,FMAT,MDF,PIVOT,GMAT,MDG,
     3 FFUNC,HFUNC,X,SEC,ADD,DEL,SCALE,DIAG,DX,DXNORM,
     4 V1,EPSREL,ERROR,EVAL,BETAK,DIMA,DIMC2,V2,U )
      IF(ERROR.LT.(-10)) GOTO 40
C
C     ACCUMULATE FUNCTION EVALUATIONS
C
      FUNCEV=FUNCEV+EVAL
      SECEV=SECEV+EVAL
C
C     TEST SOME ABNORMAL TERMINATION CRITERIA
C     ERROR=-3 IF NOT POSSITIVE DEFINITE HESSIAN
C          =-4 IF NOT ALLOWED TO USE 2@DND DERIVATIVES
C
      if(error.eq.(-3))then
	ifree=5
	nrrest=0
	goto 10
      endif
      IF(ERROR.eq.(-4)) GOTO 20
C
C     SAVE THE CURRENT POINT
C
      CALL SAVEXK(X,N,U)
      IF((CODE.EQ.2).AND.(NRREST.EQ.1)) CALL SAVEXK(X,N,WOLD)
C
C     COMPUTE A STEPLENGTH AND TAKE A STEP USING
C     A MERIT FUNCTION
C
      CALL STPLNG(RESTAR,X,A,MDA,DX,N,F,V1,M,FSUM,FFUNC,RANKC2,CODE,
     1 H,HFUNC,ACTIVE,T,INACT,P4,LMT,L,W,WOLD,DIMA,NORM,
     2 NOHOUS,PSI,ALPHA,ALFLOW,ALFUPP,EVAL,XDIFF,ERROR,IND,whnrm2,
     3 D,V2,S,G       )
      IF(ERROR.LT.(-10)) GOTO 40
C
C     ACCUMULATE FUNCTION EVALUATIONS
C
      FUNCEV=FUNCEV+EVAL
      LINEV=LINEV+EVAL
C
C     POSSIBLY A RESTART IS DONE
C     IF NO RESTART IS DONE VARIABLES REPRESENTING
C     THE PAST ARE UPDATED
C
      CALL EVREST(X,U,N,M,K,FFUNC,FUNCEV,F,D1NRM,DNRM,FSUM,DIMC2,
     1 CODE,DXNORM,BETAK,ALPHA,ALFLOW,ACTIVE,H,L,T,HFUNC,
     2 B1NRM,HSUM,DIMA,ERROR,RESTAR)
      IF(ERROR.LT.(-10)) GOTO 40
      ADD=.FALSE.
      IF(RESTAR.OR.(-1.EQ.ERROR).or.(-5.eq.error)) GOTO 10
C
C     POSSIBLY SOME CONSTRAINTS ARE ADDED TO THE WORKING SET
C
      CALL EVADD(H,ACTIVE,T,BND,P,INACT,LMT,IND,K,ADD)
C
C     PRINT SOME INFORMATION FOR LATEST STEP
C
      CALL OUTPUT(IPRINT,K,NOUT,GRES,W,ACTIVE,
     1 SPEED)
C
C     REPEAT FROM START OF ITERATION LOOP
C
      GOTO 10
   30 CONTINUE
      SPEED=(D1NRM+B1NRM)/max(BETKM1,drelpr**2)
      P=T
      RANK=RANKC2+RANKA
      RETURN
   40 CONTINUE
C
C     USER STOP INDICATOR DETECTED
C
      EXIT=ERROR
      RETURN
      END
c
C     DOUBLE PRECISION VERSION 910326
C
CTERCRI
      SUBROUTINE TERCRI(RANKA,RANKC2,ERROR,P,T,N,RESTAR,DEL,MAXIT,K,
     1 FSUM,D1NRM,HSUM,GRES,XNORM,GNORM,ALFNOI,H,INACT,Q,XDIFF,EPSABS,
     2 EPSREL,EPSX,EPSH,SIGMIN,ABSVMX,WOLD,X,athnrm,whnrm2,EXIT)
      INTEGER RANKA,RANKC2,ERROR,P,T,N,MAXIT,K,Q,EXIT
      INTEGER INACT(1)
      DOUBLE PRECISION
     *     H(1),WOLD(N),X(N)
      DOUBLE PRECISION
     *     FSUM,D1NRM,HSUM,GRES,XNORM,GNORM,ALFNOI,XDIFF,EPSABS,
     1 EPSREL,EPSX,EPSH,SIGMIN,ABSVMX,athnrm,whnrm2
      LOGICAL RESTAR,DEL
C
C     CHECK IF ANY OF THE TERMINATION CRITERIA ARE SATISFIED
C     THERE ARE CONVERGENCE CRITERIA AND ABNORMAL TERMINATION
C     CRITERIA
C     THE CONVERGENCE CRITERIA ARE ONLY TESTED IF THE LATEST STEP
C     WAS TAKEN ALONG A GAUSS-NEWTON DIRECTION WITH FULL PSEUDO RANK
C     OR IF THE METHOD OF NEWTON HAS BEEN USED IN THE LATEST STEP
C     OF COURCE THE STEP MUST NOT BE A RESTART STEP IF CONVERGENCE
C     SHOULD BE TESTED
C
C     A SEARCH DIRECTION USING GAUSS-NETON'S METHOD IS COMPUTED
C     BY SOLVING FOR DX    A*DX = -H
C                          C*DX APPR.= -F
C     A FIRST ORDER ESTIMATE OF THE LAGRANGE MULTIPLIERS (V) HAS BEEN
C     COMPUTED BY SOLVING FOR V     T
C                                  A *V APPR.= G (THE GRADIENT )
C     WHERE
C                     T                 -1   T
C           (L@D0) = P1 *A*Q1      DY1= L  *P1 *(-H)
C                                       T
C           (C1@DC2) = C*Q1      (U) = Q3 *C2*P3
C                               (0)
C                    T
C           D=(D1)=Q3 *(-F-C1*DY1)
C             (D2)
C
C     THE CONVERGENCE CRITERIA ARE
C
C      1) II H(X) II < EPSH   (WHERE ONLY CONSTRAINTS IN THE WORKING
C                              SET ARE CONSIDERED)
C      1.5) ALL INACTIVE CONSTRAINTS MUST BE GREATER THAN ZERO
C             T
C      2) II A *V -G II < DSQRT(EPSREL)*(1.0+II G(X) II)
C      3) SIGMIN >= EPSREL*ABSVMX
C                >= EPSREL*(1+II F(X) II**2)  (IF 1 INEQUALITY)
C      4) II D1 II**2 <= EPSREL**2*II F(X) II**2
C      5) II F(X) II**2 <= EPSABS**2
C      6) II X(K-1)-X(K) II < EPSX*II X(K) II   ( TIME STEP K)
C      7) DSQRT(DRELPR)/II DX(GN) II >0.25 (GN=GAUSS NEWTON)
C      8) THE LAST DIGIT IN THE CONVERGENCE CODE (SEE BELOW) INDICATES
C         HOW THE LASTS STEPS WERE COMPUTED
C        = 0 NO TROUBLE (GAUSS-NEWTON THE LAST 3 STEPS)
C        = 1 RANKA<>T OR RANKC2<>(N-T) AT THE TERMINATION POINT
C            NO 2@DND DERIVATIVES HAS BEEN USED
C        = 2 THE METHOD OF NEWTON WAS USED (AT LEAST) IN THE LAST STEP
C        = 3 THE 2@DND BUT LAST STEP WAS SUBSPACE MINIMIZATION STEP
C            BUT THE LAST TWO WERE GAUSS-NEWTON STEPS
C        = 4 THE STEPLENGTH WAS NOT UNIT IN BOTH THE LAST 2 STEPS
C
C     THE ABNORMAL TERMINATION CRITERIA ARE
C
C      9) NUMBER OF ITERATIONS EXCEEDS THE MAXIMUM NUMBER
C     10) Convergence to a non-feasible point.
C     11) THE USER HAS NOT ALLOWED USE OF 2@DND DERIVATIVES (NEWTON)
C     12) UNDAMPED NEWTON STEP FAILS
C     13) THE LATEST DX(GN) IS NOT A DESCENT DIRECTION TO THE
C         MERIT FUNCTION (PROBABLY CAUSED BY MISSCALCULATED JACOBIAN)
C
C     ON ENTRY@D
C
C     RANKA   INTEGER SCALAR CONTAINING PSEUDO RANK OF THE MATRIX
C             A IN CURRENT STEP
C     RANKC2  INTEGER SCALAR CONTAINING PSEUDO RANK OF THE MATRIX
C             C2 IN CURRENT STEP
C     ERROR   INTEGER SCALAR CONTAINING
C             =-1 IF NO DESCENT DIRECTION
C             =-2 IF WE ARE COMPUTING AT NOISE LEVEL
C             =-3 IF NOT POSITIVE DEFINITE HESSIAN FROM NEWTON
C             =-4 IF NO USE OF 2@DND DERIVATIVES IS ALLOWED
C             =-5 IF UNDAMPED NEWTON FAILS
C             =-9 IF TOO MANY(>5) NEWTON STEPS
C             = 0 OTHERWISE
C     P       INTEGER SCALAR CONTAINING NUMBER OF EQUALITY CONSTRAINTS
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     RESTAR  LOGICAL SCALAR =TRUE IF RESTART IS DONE AT CURRENT POINT
C             =FALSE IF NO RESTART HAS BEEN DONE
C     DEL     LOGICAL SCALAR = TRUE IF A CONSTRAINT IS DELETED
C             AT THE CURRENT POINT. = FALSE OTHERWISE
C     MAXIT   INTEGER SCALAR CONTAINING MAXIMUM ITERATIONS ALLOWED
C     K       INTEGER SCALAR CONTAINING CURRENT ITERATION NUMBER
C     FSUM    REAL SCALAR CONTAINING SQUARE SUM OF THE RESIDUALS
C     D1NRM   REAL SCALAR CONTAINING  II D1 II
C     HSUM    REAL SCALAR CONTAINING SQUARE SUM OF THE CURRENT
C             CONSTRAINTS                  T
C     GRES    REAL SCALAR CONTAINING   II A *V-G II
C     XNORM   REAL SCALAR CONTAINING  II X(K) II
C     GNORM   REAL SCALAR CONTAINING NORM OF THE GRADIENT OF
C             THE OBJECTIVE FUNCTION
C     ALFNOI  REAL SCALAR CONTAINING DSQRT(DRELPR)/II DX(GN) II
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION Q
C             CONTAINING INDECES FOR THE INACTIVE CONSTRAINTS
C     Q       INTEGER SCALAR CONTAINING NO. OF INACTIVE CONSTRAINTS
C     XDIFF   REAL SCALAR CONTAINING  II X(K-1)-X(K) II
C     EPSABS  REAL SCALARS CONTAINING SMALL NON NEGATIVE VALUES
C     EPSREL  USED IN CONVERGENCE TESTS
C     EPSX
C     EPSH
C     SIGMIN  REAL SCALAR CONTAINING SMALLEST (>0) LAGRANGE MULTIPLIER
C             ESTIMATE CORRESPONDING TO INEQUALITY CONSTRAINTS
C     ABSVMX  REAL SCALAR CONTAINING LARGEST ABSOLUTE LAGRANGE
C             MULTIPLIER ESTIMATES
C     WOLD()  REAL SINGLYSUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING NEWTON INITIAL X-POINT WHEN
C             ERROR = -9. OTHERWISE UNDEFINED
C
C     ON RETURN@D
C
C     A NECESSARY CONDITION FOR CONVERGENCE IS THAT CONDITIONS
C     1)-3) HOLD TRUE
C
C     X()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING WOLD WHEN ERROR = -9. OTHERWISE
C             UNDEFINED
C     EXIT    INTEGER SCALAR CONTAINING
C             =    0 IF NO TERMINATION CRITERION IS SATISFIED
C             =10000 IF CRITERION  4) IS SATISFIED
C             = 2000 IF     @      5)       @
C             =  300 IF     @      6)       @
C             =   40 IF     @      7)       @
C             =    X IF     @      8)       @
C                    WHERE X CAN BE   0,1,2,3 OR 4
c             = -YYYYX if   #     10)       #
c                    where YYYYX is one of the convergence codes above.
C             =   -2 IF CRITERION  9) IS SATISFIED
C             =   -3 Not used
C             =   -4 IF     @     11)       @
C             =   -5 IF     @     12)       @
C             =   -6 IF     @     13)       @
C             =   -9 IF TOO MANY (>5) NEWTON STEPS
c             =  -10 if not possible to satisfy the constraints
C
C     COMMON VARIABLES CONTAINING INFORMATION CONCERNING PREVIOUS
C     TWO POINTS. THE SUFFICES KM2 AND KM1 IN THE NAMES OF THE
C     VARIABLES REPRESENT TIME STEP K-2 AND K-1
C     THESE VARIABLES ARE UPDATED ONLY INSIDE THE ROUTINE EVREST
C
      INTEGER RKAKM2,RKCKM2,KODKM2,RKAKM1,RKCKM1,KODKM1,TKM2,TKM1
      DOUBLE PRECISION
     *     BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,ALFKM2,
     1 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     2 PGRESS,PRELIN
      COMMON /PREC/ BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,
     1 ALFKM2,RKAKM2,RKCKM2,TKM2,KODKM2,
     2 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     3 RKAKM1,RKCKM1,TKM1,KODKM1,
     4 PGRESS,PRELIN
C
C     COMMON VARIABLES CONTAINING INFORMATION OF RESTART STEPS
C
      DOUBLE PRECISION
     *    BESTRK,BESTPG
      INTEGER NRREST,LATTRY
      COMMON /BACK/ BESTRK,BESTPG, NRREST,LATTRY
      integer ifree
      common /negdir/ ifree
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,feas
      DOUBLE PRECISION
     *     FACTOR
      EXIT=0
      feas=1
C
C     THE CONVERGENCE CRITERIA ARE NOT CHECKED IF A RESTART WAS
C     DONE AT THE CURRENT POINT OR IF CURRENT STEP IS NOT A FULL
C     PSEUDO RANK STEP
C
      IF(RESTAR.or.(ifree.gt.3)) GOTO 60
      IF((-1.EQ.KODKM1).AND.(ALFNOI.LE. 0.25D0)) GOTO 60
      IF((ERROR.LT.0).AND.(-2.NE.ERROR)) GOTO 60
C
C     CHECK NECESSARY CONDITIONS
C
      IF(DEL) GOTO 60
      IF(DSQRT(HSUM).GT.EPSH) GOTO 60
      IF(GRES.GT.DSQRT(EPSREL)*(1.0D0+GNORM)) GOTO 60
      IF(Q.LE.0) GOTO 5
      DO 1 I=1,Q
           J=INACT(I)
           IF(H(J).LE. 0.0D0) feas=-1
    1 CONTINUE
    5 CONTINUE
      IF(T.EQ.P) GOTO 10
      IF(T.EQ.1) FACTOR=1.0D0+FSUM
      IF(T.GT.1) FACTOR=ABSVMX
      IF(SIGMIN.LT.EPSREL*FACTOR) GOTO 60
   10 CONTINUE
C
C     CHECK THE SUFFICIENT CONDITIONS
C
C     CRITERION NO. 4
C
      IF(D1NRM**2.LE.(EPSREL**2*FSUM)) EXIT=EXIT+10000
C
C     CRITERION NO. 5
C
      IF(FSUM.LE.EPSABS**2) EXIT=EXIT+2000
C
C     CRITERION NO. 6
C
      IF(XDIFF.LT.EPSX*XNORM) EXIT=EXIT+300
C
C     CRITERION NO. 7
C
      IF((ALFNOI.GT. 0.25D0).OR.(-2.EQ.ERROR)) EXIT=EXIT+40
      IF(EXIT.EQ.0) GOTO 60
C
C     CRITERION NO. 8
C
      IF(KODKM1.EQ.1) GOTO 20
      EXIT=EXIT+2
      EXIT=EXIT*feas
      RETURN
   20 CONTINUE
      IF((RANKA.EQ.T).AND.(RANKC2.EQ.(N-T))) GOTO 30
      EXIT=EXIT+1
      EXIT=EXIT*feas
      RETURN
   30 CONTINUE
      IF((KODKM2.EQ.1).OR.(K.LT.2)) GOTO 40
      EXIT=EXIT+3
      EXIT=EXIT*feas
      RETURN
   40 CONTINUE
      IF(.not.(DABS(ALFKM2-1.0D0).LE.1.0D-2).AND.
     1  (DABS(ALFKM1-1.0D0).LE.1.0D-2)) EXIT=EXIT+4
      EXIT=EXIT*feas
      RETURN
   60 CONTINUE
C
C     CHECK ABNORMAL TERMINATION CRITERIA
C
C     CRITERION NO. 9
C
      IF((K+nrrest).LE.MAXIT) GOTO 70
      EXIT=-2
      RETURN
   70 CONTINUE
      if(ifree.gt.0)then
       exit=0
       return
      endif
C
C     CRITERION NO. 13
C
      IF(ERROR.NE.(-1)) GOTO 80
      EXIT=-6
      RETURN
   80 CONTINUE
c
c     test if impossible to satisfy the constraints
c
      if((xdiff.gt.epsx*10.0d0).or.(athnrm.gt.epsh*10.0d0)
     1 .or.(whnrm2.lt.1.0d0)) goto 85
      exit=-10
      return
   85 continue
C
C     CRITERION NO. 10)-12)
C
      IF((ERROR.GE.(-5)).AND.(ERROR.LE.(-3))) EXIT=ERROR
      IF(-9.NE.ERROR) RETURN
      EXIT=ERROR
      DO 90 I=1,N
        X(I)=WOLD(I)
   90 CONTINUE
      RETURN
      END
C     DOUBLE PRECISION VERSION 880329
C
CSTPLNG
      SUBROUTINE STPLNG(RESTAR,X,A,MDA,DX,N,F,V1,M,FSUM,FFUNC,RANKC2,
     1 CODE,H,HFUNC,ACTIVE,T,INACT,P4,Q,L,W,WOLD,DIMA,NORM,
     2 NOHOUS,PSI,ALPHA,ALFLOW,ALFUPP,EVAL,XDIFF,ERROR,IND,whnrm2,
     3 FNEW,V2,HNEW,G                            )
      INTEGER MDA,N,M,RANKC2,CODE,T,Q,L,DIMA,NORM,NOHOUS,EVAL,ERROR,IND
      INTEGER ACTIVE(1),INACT(1),P4(1)
      DOUBLE PRECISION
     *     FSUM,PSI,ALPHA,ALFLOW,ALFUPP,XDIFF,whnrm2
      DOUBLE PRECISION
     *     X(N),A(MDA,N),DX(N),F(1),V1(1),H(1),W(1),WOLD(1),
     1 FNEW(1),V2(1),HNEW(1),G(N)
      LOGICAL RESTAR
      EXTERNAL FFUNC,HFUNC
C
C     FIND THE STEPLENGTH ALPHA IN    XNEW@D=XOLD+ALPHA*DX   BY
C     APPROXIMATELY MINIMIZING THE MERIT FUNCTION PSI(XOLD+ALPHA*DX,W)
C     WITH RESPECT TO ALPHA IF THE SEARCH DIRECTION (DX) IS COMPUTED
C     USING SUBSPACE MINIMIZATION
C
C     PSI(X,W)=0.5*(II F(X) II**2+SIGMA(W(I)*H (X)**2)+
C                                   I         I
C       SIGMA(W(J))*H (X)**2))  WHERE H (X)=MIN(0,H (X))
C         J          +                 +           J
C     WHERE I BELONGS TO THE CURRENT WORKING SET AND J TO THE INACTIVE
C     SET. HOWEVER, IF DX IS COMPUTED USING THE METHOD
C     OF NEWTON AN UNDAMPED STEP IS TAKEN (I.E. ALPHA@D=1 )
C
C     ON ENTRY@D
C
C     VARIABLES FLAGGED WITH * ARE NOT DEFINED IF CODE=2
C
C     RESTAR  LOGICAL SCALAR = TRUE IF CURRENT STEP IS A RESTART STEP
C             = FALSE IF NOT SO
C     X()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE POINT XOLD
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING THE GRADIENTS OF THE INACTIVE CONSTRAINTS AS
C             ROWS T+1,T+2,......,L
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     DX()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE SEARCH DIRECTION
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M+T
C             CONTAINING THE VALUE OF THE RESIDUALS IN THE FIRST M
C             ELEMENTS
C  *  V1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M+L
C             CONTAINING THE COMPOUND VECTOR  (C*DX   )
C                                             (AHAT*DX)
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     FSUM    REAL SCALAR CONTAINING SUM OF SQUARED RESIDUALS
C     FFUNC   SUBROUTINE NAME-USED TO EVALUATE THE RESIDUALS
C     RANKC2  INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX C2
C             IN  (C1@DC2)=C*Q1*FMAT*P2
C     CODE     INTEGER SCALAR CONTAINING
C             = 1 IF GAUSS-NEWTON SEARCH DIRECTION
C             =-1 IF SUBSPACE MINIMIZATION SEARCH DIRECTION
C             = 2 IF NEWTON SEARCH DIRECTION
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS AT THE POINT XOLD
C     HFUNC   SUBROUTINE NAME-USED TO EVALUATE THE CONSTRAINTS
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING INDECES FOR THE CONSTRAINTS IN CURRENT WORKING
C             SET
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION Q
C             CONTAINING INDECES FOR INACTIVE CONSTRAINTS
C     P4()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             REPRESENTING THE REORDERING OF CONSTRAINT GRADIENTS
C             DUE TO THE WORKING SET SUCH THAT P4(I) POINTS TO ROW
C             IN ARRAY A WERE GRADIENT NUMBER I IS MOVED
C     Q       INTEGER SCALAR CONTAINING NUMBER OF INACTIVE CONSTRAINTS
C     L       INTEGER SCALAR CONTAINING TOTAL NUMBER OF CONSTRAINTS
C     W()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING LATEST VECTOR OF PENALTY CONSTANTS
C     WOLD()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE SAME AS W ABOVE UNLESS A RESTART IS DONE.
C     DIMA    INTEGER SCALAR CONTAINING THE DIMENSION OF MATRIX A USED
C             IN SUBSPACE MINIMAZATION
C     NORM    INTEGER SCALAR CONTAINING A CODE THAT CONTROLS WHICH
C             NORM THAT SHOULD BE USED WHEN PENALTY WEIGHTS ARE UPDATED
C             = 0 MAXIMUM NORM
C             = 1 ABSOLUTE NORM
C             = 2 EUCLIDEAN NORM
C     NOHOUS  INTEGER SCALAR CONTAINING NUMBER OF HOUSEHOLDER
C             TRANSFORMATIONS DONE TO FORM            T
C                                            (L@D0) =P1 *A*Q1
C
C     ON RETURN@D
C
C     X()     CONTAINS THE NEW POINT XNEW
C     F()     CONTAINS THE VALUE OF THE RESIDUALS AT XNEW
C     H()     CONTAINS THE VALUE OF THE CONSTRAINTS AT XNEW
C *   W()     CONTAINS THE VECTOR OF PENALTY CONSTANTS THAT HAS BEEN
C             USED IN THIS LINESEARCH
C     WOLD()  CONTAINS THE VALUE OF W() ON ENTRY UNLESS A RESTART
C             IF RESTART THEN WOLD() IS UNCHANGED
C     PSI     REAL SCALAR-CONTAINS THE VALUE PSI(XNEW,W)
C     ALPHA   REAL SCALAR-CONTAINS THE STEPLENGTH
C     ALFLOW  REAL SCALAR-CONTAINS THE LOWER BOUND OF THE STEPLENGTH
C     ALFUPP  REAL SCALAR-CONTAINS THE UPPER BOUND OF THE STEPLENGTH
C     EVAL    INTEGER SCALAR-CONTAINS NUMBER OF FUNCTION EVALUATIONS
C             DONE INSIDE THIS ROUTINE
C     XDIFF   REAL SCALAR-CONTAINS  II XNEW-XOLD II
C     ERROR   INTEGER SCALAR-CONTAINS
C             = 0 IF EVERY THING IS OK
C             =-1 IF DX IS NOT A DESCENT DIRECTION TO PSI(XOLD,W)
C             =-2 IF ALPHA<=ALFLOW OR ALPHA*DX<DSQRT(DRELPR)
C             < -10 AS A USER STOP INDICATOR
C     IND     INTEGER SCALAR = 0 IF ALPHA IS LESS THAN ALFUPP
C             = INDEX FOR THE CONSTRAINT THAT DEFINES THE UPPER BOUND
C               WHICH EQUALS ALPHA
C
C     WORKING AREAS@D
C
C     FNEW(),V2() REAL SINGLY SUBSCRIPTED ARRAYS OF DIMENSION M+L
C     HNEW()      REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C      G()        REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C
C     COMMON VARIABLES CONTAINING INFORMATION CONCERNING PREVIOUS
C     TWO POINTS. THE SUFFICES KM2 AND KM1 IN THE NAMES OF THE
C     VARIABLES REPRESENT TIME STEP K-2 AND K-1
C     THESE VARIABLES ARE UPDATED ONLY INSIDE THE ROUTINE EVREST
C
      INTEGER RKAKM2,RKCKM2,KODKM2,RKAKM1,RKCKM1,KODKM1,TKM2,TKM1
      DOUBLE PRECISION
     *     BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,ALFKM2,
     1 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     2 PGRESS,PRELIN
      COMMON /PREC/ BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,
     1 ALFKM2,RKAKM2,RKCKM2,TKM2,KODKM2,
     2 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     3 RKAKM1,RKCKM1,TKM1,KODKM1,
     4 PGRESS,PRELIN
C
C     COMMON VARIABLES CONTAINING INFORMATION OF RESTART STEPS
C
      DOUBLE PRECISION
     *    BESTRK,BESTPG
      INTEGER NRREST,LATTRY
      COMMON /BACK/ BESTRK,BESTPG, NRREST,LATTRY
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER I,K,CTRL,EXIT
      DOUBLE PRECISION
     *     C1,UPPBND,WHSUM
      LOGICAL OLD
      DOUBLE PRECISION
     *     PSI0,DPSI0,MAGFY,XEL,SUM,DUMMY,ATWA,CDX,DXTCTF,DNRM2
      DATA C1 /1.0D-3/
      ERROR=0
      OLD=.FALSE.
      ALFLOW=C1
C
C     IF THE METHOD OF NEWTON HAS BEEN USED TO COMPUTE DX
C     AN UNDAMPED STEP IS TAKEN
C
      IF(IABS(CODE).NE.1) GOTO 60
C
C     DETERMINE PENALTY CONSTANTS (W) IN THE MERIT FUNCTION PSI(X,W)
C
      IF(RESTAR) GOTO 20
      DO 10 I=1,L
           WOLD(I)=W(I)
   10 CONTINUE
   20 CONTINUE
C
C     IN SOME SITUATIONS THE SEQUENCE OF PENALTY CONSTANTS ARE RESTARTED
C
      IF(RESTAR) OLD=.TRUE.
      CALL WEIGHT(W,WOLD,V1,F,FSUM,M,ACTIVE,T,H,L,NORM,DIMA,OLD,
     1 whnrm2,PSI0,DPSI0,ATWA,CDX,DXTCTF,FNEW,HNEW,V2)
C
C     CHECK IF DX IS A DESCENT DIRECTION
C
      IF(DPSI0 .GE. 0.0D0) ERROR=-1
      IF(ERROR .LT. 0) RETURN
C
C     DETERMINE UPPER BOUND OF THE STEPLENGTH
C
      CALL UPBND(A,MDA,Q,NOHOUS,T,N,H,INACT,P4,V1,M,
     1 DX,ALFUPP,IND)
      ALFLOW=ALFUPP/3000.0D0
C
C     DETERMINE A FIRST GUESS OF STEPLENGTH
C
      MAGFY=3.0D0
      IF(RANKC2.LT.RKCKM1) MAGFY=2.0D0*MAGFY
      ALPHA=2.0D0*DMIN1(1.0D0,MAGFY*ALFKM1,ALFUPP)
   40 CONTINUE
      ALPHA=0.5D0*ALPHA
C
C     COMPUTE A STEPLENGTH BY APPROXIMATELY
C     MINIMIZING  PSI(XOLD+ALF*DX)  WITH RESPECT TO ALF
C
      CALL LINEC(X,DX,F,V1,M,N,ALPHA,PSI0,DPSI0,ALFLOW,FFUNC,HFUNC,
     1 H,HNEW,ACTIVE,T,INACT,Q,L,W,ALFUPP,FNEW,V2,G,PSI,XDIFF,EVAL,EXIT)
      IF(EXIT.LT.(-10)) GOTO 90
C
C     CHECK IF THE USER HAS SIGNALED UNCOMPUTABILTY FOR ALF=ALPHA
C     (THE FIRST GUESSS)
C
      IF(-3.EQ.EXIT) GOTO 40
      ERROR=EXIT
   50 CONTINUE
      UPPBND=DMIN1(1.0D0,ALFUPP)
C
C     COMPUTE THE PREDICTED LINEAR PROGRESS (PRELIN) AND
C     THE ACTUAL PROGRESS (PGRESS)
C
      PRELIN=UPPBND*(-2.0D0*DXTCTF-UPPBND*CDX+(2.0D0-UPPBND**2)*ATWA)
      PGRESS=2.0D0*PSI0-DNRM2(M,F,1)**2
      IF(T.LE.0) GOTO 80
      WHSUM=0.0D0
      DO 55 I=1,T
        K=ACTIVE(I)
        WHSUM=WHSUM+W(K)*H(K)**2
   55 CONTINUE
      PGRESS=PGRESS-WHSUM
      GOTO 80
   60 CONTINUE
C
C     TAKE AN UNDAMPED STEP
C
      ALFUPP=3.0D0
      SUM=0.0D0
      DO 70 I=1,N
           XEL=X(I)
           X(I)=XEL+DX(I)
           SUM=SUM+(XEL-X(I))**2
   70 CONTINUE
      XDIFF=DSQRT(SUM)
C
C     EVALUATE RESIDUALS AND CONSTRAINTS AT THE NEW POINT
C
      CTRL=-1
      CALL FFUNC(X,N,F,M,CTRL,DUMMY,1)
      EXIT=CTRL
      CTRL=-1
      CALL HFUNC(X,N,H,L,CTRL,DUMMY,1)
      EXIT=CTRL
      IF(EXIT.LT.(-10)) GOTO 90
      ALPHA=1.0D0
      EVAL=1
   80 CONTINUE
      IF(IND.EQ.0) RETURN
      IF(DABS(ALPHA-ALFUPP).GT. 0.1D0) IND=0
      RETURN
C
C     A USER STOP INDICATOR IS DETECTED
C
   90 CONTINUE
      ERROR=EXIT
      RETURN
      END
C     DOUBLE PRECISION VERSION 911001
C
CEUCNRM
      SUBROUTINE EUCNRM(VA,H,ACTIVE,T,MU,ANORM,BNORM,DIMA,W,L,PSET,
     1 Y,WOLD)
      INTEGER T,DIMA,L
      INTEGER ACTIVE(1),PSET(1)
      DOUBLE PRECISION
     *     MU,ANORM,BNORM
      DOUBLE PRECISION
     *     VA(1),H(1),W(1),Y(1),WOLD(1)
C
C     UPDATE THE PENALTY CONSTANTS USING THE EUCLIDEAN NORM
C
C     ON ENTRY@D
C
C     VA()         REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C                  CONTAINING THE VECTOR AHAT*DX NORMALIZED TO HAVE
C                  LENGTH 1
C     H()          REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C                  CONTAINING THE VALUE OF THE CONSTRAINTS DIVIDED
C                  BY BNORM
C     ACTIVE()     INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C                  CONTAINING INDECES FOR THE CONSTRAINTS IN THE
C                  CURRENT WORKING SET
C     T            INTEGER SCALAR CONTAINING THE NUMBER OF CONSTRAINTS
C                  IN THE CURRENT WORKING SET         T
C     MU           REAL SCALAR CONTAINING      ABS(CTD-CTC)/DELTA-CTC
C     ANORM        REAL SCALAR CONTAINING   II VA II
C     BNORM        REAL SCALAR CONTAINING   II H II
C     DIMA         INTEGER SCALAR CONTAINING DIMENSION <=T USED
C                  TO COMPUTE THE SEARCH DIRECTION DX
C     W()          REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C                  CONTAINING THE LATEST PENALTY CONSTANTS (WOLD)
C     L            INTEGER SCALAR CONTAINING THE TOTAL NUMBER OF
C                  CONSTRAINTS
C
C     ON RETURN@D
C
C     W()          CONTAINS THE NEW PENALTY CONSTANTS
C
C     WORKING AREAS@D
C
C     PSET()       INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C     Y()          REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C     WOLD()       REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,NRP,CTRL
      DOUBLE PRECISION
     *     ZTW,YEL,GAMMA,TAU,ynorm,u
      common /wsave/ u(100,4)
      IF(T.LE.0) RETURN
      ZTW=0.0D0
C
C     COMPUTE ZTW= Z(TR)*WOLD where WOLD holds the 4'th lowest weights used
c     so far
C
      do 5 i=1,L
       w(i)=u(i,4)
    5 continue
*      ynorm=0.0d0
      DO 10 I=1,T
           J=ACTIVE(I)
*           ynorm=ynorm+va(i)**4
*            w(j)=u(j,4)
           ZTW=ZTW+VA(I)**2*W(J)
   10 CONTINUE
*      ynorm=ynorm*anorm**2
      ZTW=ANORM*ANORM*ZTW
*      goto 19
*      do 15 i=1,l
*       wold(i)=w(i)
*   15 continue
*      do 18 i=1,t
*       j=active(i)
*       if(mu .le. 0.0d0)then
*         w(j)=0.0d0
*       else   
*         w(j)=mu*va(i)**2/ynorm
*       endif
*   18 continue
*      call assort(u,100,l,4,t,active,w,wold)
*      return
*   19 continue
      IF(ZTW.LT.MU) GOTO 40
C
C     IF ZTW>=MU WE DON'T NEED TO CHANGE WOLD UNLESS T@DIMA
C
      IF(T.EQ.DIMA) goto 106
C
C     FORM THE VECTOR Y AND THE SCALAR GAMMA
C     PSET HOLDS INDECES FOR THOSE Y(I) BEING >0
C
      CTRL=2
      NRP=0
      GAMMA=0.0D0
      DO 30 I=1,T
           J=ACTIVE(I)
           YEL=VA(I)*ANORM*(VA(I)*ANORM+BNORM*H(J))
           IF(YEL .LE. 0.0D0) GOTO 20
           NRP=NRP+1
           PSET(NRP)=J
           Y(NRP)=YEL
           GOTO 30
   20      CONTINUE
           GAMMA=GAMMA-YEL*W(J)
   30 CONTINUE
      CALL EUCMOD(CTRL,W,L,PSET,NRP,Y,GAMMA,WOLD)
      goto 106
*      RETURN
   40 CONTINUE
C
C     ZTW<MU WHEN EXECUTION CONTINUES FROM HERE
C
      IF(T.EQ.DIMA) GOTO 70
C	
C     FORM THE VECTOR E AND THE SCALAR TAU
C     PSET HOLDS INDECES FOR THOSE E(I) BEING >0
C
      CTRL=2
      NRP=0
      TAU=MU
      DO 60 I=1,T
           J=ACTIVE(I)
           YEL=-VA(I)*H(J)*ANORM*BNORM
           IF(YEL .LE. 0.0D0) GOTO 50
           NRP=NRP+1
           PSET(NRP)=J
           Y(NRP)=YEL
           GOTO 60
   50      CONTINUE
           TAU=TAU-YEL*W(J)
   60 CONTINUE
      CALL EUCMOD(CTRL,W,L,PSET,NRP,Y,TAU,WOLD)
      goto 106
*      RETURN
   70 CONTINUE
      CTRL=1
C
C     FORM THE VECTOR Z
C     PSET HOLDS THE INDECES ACTIVE(I) , I=1,2,....,T SINCE ALL
C     ELEMENTS IN Z IS >= 0
C
      DO 80 I=1,T
           PSET(I)=ACTIVE(I)
           Y(I)=VA(I)**2*ANORM*ANORM
   80 CONTINUE
      CALL EUCMOD(CTRL,W,L,PSET,T,Y,MU,WOLD)
*      RETURN
  106 continue
      call assort(u,100,l,4,t,active,w,wold)
      return
      END
c
c     double precision version 880329
CMAXNRM
      SUBROUTINE MAXNRM(ATA,RMY,ALFA,DELTA,W,ACTIVE,T)
      INTEGER T,ACTIVE(T)
      DOUBLE PRECISION
     *     ATA,RMY,ALFA,DELTA
      DOUBLE PRECISION
     *     W(1)
C
C     UPDATE THE PENALTY WEIGHTS CORRESPONDING TO THE
C     CONSTRAINTS IN THE CURRENT WORKING SET
C
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     MU,wkm1,nu,u
      common /wsave/ u(100,4)
      INTEGER I,K,l
      IF(DABS(ALFA-1.0D0) .LE. DELTA) then
       mu=0.0d0
      else
      MU=RMY/ATA
      endif
      l=ACTIVE(1)
      wkm1=w(l)
      nu=MAX(MU,u(1,4))
      DO 10 I=1,T
              K=ACTIVE(I)
              W(K)=nu
   10 CONTINUE
      if(mu .le. wkm1) goto 40
      do 30 i=1,4
       if(mu .le. u(1,i)) goto 30
       do 20 j=4,i+1,-1
        u(1,j)=u(1,j-1)
   20  continue
       u(1,i)=mu
       goto 40
   30 continue
   40 continue
      RETURN
      END
c
c       double precision version 911001
cassort
        subroutine assort(u,mdu,l,s,t,active,w,wold)
	integer mdu,l,s,t
	integer active(1)
	double precision u(mdu,1),w(1),wold(1)
c
c	update row no. i in u when w(i)>max(u(i,s), wold(i))
c
	double precision wmax,wxk
	integer i,j,k,ii
	do 30 i=1,t
	 k=active(i)
	 wxk=w(k)
*	 w(k)=max(u(k,s), wxk)
*	 WXK=W(K)
* wmax=max(u(k,s), wold(k))
*         WMAX=WOLD(K)
*	 if(wxk.le.wmax)goto 30
         do 10 ii=1,s
         if(wxk .le. u(k,ii))goto 10
	 do 20 j=s,ii+1,-1
	  u(k,j)=u(k,j-1)
  20	 continue
	 u(k,ii)=wxk
         goto 30
  10     continue
  30	continue
	return
	end
c
C     DOUBLE PRECISION VERSION 880406
CINIALC
      SUBROUTINE INIALC(P,L,H,ACTIVE,T,BND,NORM,INACT,LMT,W,WOLD,EXIT)
      INTEGER P,L,T,BND,NORM,LMT,EXIT
      INTEGER ACTIVE(1),INACT(1)
      DOUBLE PRECISION
     *     H(1),W(1),WOLD(1)
C
C     DETERMINE THE FIRST WORKING SET BY STORING THE INDECES
C     FOR CONSTRAINTS BEING REGARDED AS EQUALITIES AT THE
C     STARTING POINT IN THE ARRAY ACTIVE AND THE OTHER
C     INDECES IN THE ARRAY INACT
C
C     ON ENTRY@D
C
C     P       INTEGER SCALAR CONTAINING NUMBER OF EQUALITY CONSTRAINTS
C     L       INTEGER SCALAR CONTAINING TOTAL NUMBER OF CONSTRAINTS
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS AT X
C     W()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING VALUES >=0 USED AS FIRST PENALTY CONSTANTS
C             IF AN ELEMENT IS <=0.0 THE FIRST PENALTY CONSTANT IS
C             CHOOSEN AUTOMATICALLY
C     BND     INTEGER SCALAR CONTAINING MIN(L,N)
C     NORM    INTEGER SCALAR CONTAINING A CODE THAT CONTROLS WHICH
C             NORM THAT SHOULD BE USED WHEN PENALTY WEIGHTS ARE UPDATED
C             = 0 MAXIMUM NORM
C             = 1 ABSOLUTE NORM
C             = 2 EUCLIDEAN NORM
C
C     ON RETURN@D
C
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             ACTIVE(I)= INDEX FOR A CONSTRAINT IN CURRENT WORKING SET
C             I=1,2,......,T . ACTIVE(BND+I) =1 OR 0  I=1,2,...,(L-P)
C             1 IF CORRESPONDING CONSTRAINT IN WORKING SET.OTHERWISE 0
C     T       INTEGER SCALAR-CONTAINS NUMBER OF CONSTRAINTS IN CURRENT
C             WORKING SET
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             INACT(I)= INDEX FOR A CONSTRAINT NOT IN CURRENT WORKING
C             SET   I=1,2,.....,LMT
C     LMT     INTEGER SCALAR-CONTAINS NUMBER OF CONSTRAINTS NOT IN
C             CURRENT WORKING SET
C     WOLD()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINS PENALTY CONSTANTS CORRESPONDING TO EACH
C             CONSTRAINT
C     W()     W(I)=WOLD(I) I=1,2,.......,L
C     EXIT    INTEGER SCALAR SET TO -8 IF T>N
C             I.E. IF MORE THAN N CONSTRAINTS IN FIRST WORKING SET
C
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,PP1,lmin
      DOUBLE PRECISION
     *     POS,WI,ABSH,DELTA,EPS,SUM,u
      common /wsave/ u(100,4)
      DATA DELTA,EPS /0.1D0,0.01D0/
      T=P
      LMT=0
      IF(L.EQ.0) RETURN
      lmin=min(l,100)
      do 5 i=1,lmin
       do 5 j=1,4
        u(i,j)=delta
    5 continue
C
C     COMPUTE PENALTY CONSTANTS
C
      SUM=0.0D0
      DO 10 I=1,L
              ABSH=DABS(H(I))
              WI=W(I)
              IF(WI.GT.0.0D0) POS=WI
              IF(WI.LE.0.0D0) POS=DMIN1(ABSH+EPS,DELTA)
              WOLD(I)=POS
              W(I)=POS
              SUM=SUM+POS
   10 CONTINUE
      IF(NORM.GT.0) GOTO 25
      SUM=SUM/DBLE(L)
      DO 20 I=1,L
              WOLD(I)=SUM
              W(I)=SUM
   20 CONTINUE
   25 CONTINUE
      IF(P.EQ.0) GOTO 40
C
C     BUILD WORKING AND INACTIVE SET
C
      DO 30 I=1,P
              ACTIVE(I)=I
   30 CONTINUE
   40 CONTINUE
      PP1=P+1
      IF(PP1.GT.L) RETURN
      DO 60 I=PP1,L
              J=BND+I-P
              IF(H(I).LE.0.0d0) GOTO 50
              LMT=LMT+1
              INACT(LMT)=I
              ACTIVE(J)=0
              GOTO 60
   50         CONTINUE
              T=T+1
              ACTIVE(T)=I
              ACTIVE(J)=1
   60 CONTINUE
      IF(T.GT.BND) EXIT=-8
      RETURN
      END
c
c     double precision version 880329
CRELEPS
      SUBROUTINE RELEPS(DRELPR)
      DOUBLE PRECISION
     *     DRELPR
C
C     COMPUTE DRELPR = DOUBLE RELATIVE PRECISION FOR A BINARY
C     MACHINE   I.E.
C     DETERMINE THE SMALLEST POSITIVE NUMBER 0.5**K FOR WHICH
C        (1.0+0.5**K) > 1.0  AND  (1.0+0.5**(K+1)) = 1.0
C     WHERE K IS A POSITIVE INTEGER
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     FRAC,temp
      FRAC=1.0D0
   10 CONTINUE
      FRAC=FRAC*0.5D0
      temp=1.0d0+frac
      IF(temp .EQ. 1.0D0) GOTO 20
      GOTO 10
   20 CONTINUE
      DRELPR=FRAC*2.0D0
      RETURN
      END
CGNDCHK
      SUBROUTINE GNDCHK(B1NRM,D1NRM,DNRM,HSUM,K,RESTAR,D1APM1,ADD,
     1 M,N,DEL,ACTIVE,P,T,V,INACT,Q,H,EPSREL,RANKA,SCALE,DIAG,BETAK,IND)
      INTEGER K,M,N,P,T,IND,Q,RANKA,SCALE
      INTEGER ACTIVE(1),INACT(1)
      DOUBLE PRECISION
     *     B1NRM,D1NRM,DNRM,HSUM,D1APM1,EPSREL,BETAK
      DOUBLE PRECISION
     *     V(1),H(1),DIAG(1)
      LOGICAL RESTAR,ADD,DEL
C
C     DECIDE WHAT METHOD SHOULD BE USED TO COMPUTE THE SEARCH DIRECTION
C
C     IND IS SET = 1 IF GAUSS-NEWTON
C                =-1 IF SUBSPACE MINIMIZATION
C                = 2 IF NEWTON
C
C     ON ENTRY@D
C
C     B1NRM   REAL SCALAR CONTAINING  II B1 II
C     D1NRM   REAL SCALAR CONTAINING  II D1 II
C     DNRM    REAL SCALAR CONTAINING  II D II
C     HSUM    REAL SCALAR CONTAINING SUM OF SQUARED CONSTRAINTS IN
C             CURRENT WORKING SET
C     K       INTEGER SCALAR CONTAINING ITERATION NUMBER
C     RESTAR  LOGICAL SCALAR = TRUE IF CURRENT STEP IS A RESTART STEP
C             = FALSE IF IT IS NOT
C     D1APM1  REAL SCALAR CONTAINING  II D1 II  WHERE D1 HAS AS MANY
C             ELEMENTS AS IN THE LATEST STEP  -1
C     ADD     LOGICAL SCALAR = TRUE IF AT LEAST ONE CONSTRAINT WAS
C             ADDED TO THE WORKING SET IN THE LATEST STEP
C             =FALSE IF NO CONSTRAINT WAS ADDED
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     DEL     LOGICAL SCALAR = TRUE IF SOME CONSTRAINT WAS DELETED
C             FROM WORKING SET IN CURRENT STEP
C             = FALSE IF NO CONSTRAINT WAS DELETED
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING INDECES OF THE CONSTRAINTS IN CURRENT
C             WORKING SET
C     P       INTEGER SCALAR CONTAINING NUMBER OF EQUALITY CONSTRAINTS
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     V()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING ESTIMATES OF LAGRANGE MULTIPLIERS
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION Q
C             CONTAINING INDECES FOR INACTIVE CONSTRAINTS
C     Q       INTEGER SCALAR CONTAINING NUMBER OF INACTIVE CONSTRAINTS
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS
C     EPSREL  REAL SCALAR CONTAINING RELATIVE CONVERGENCE TOLERANCE
C     RANKA   INTEGER SCALAR CONTAINING THE PSEUDO-RANK OF
C             THE MATRIX AHAT
C     SCALE   INTEGER SCALAR CONTAINING ZERO IF NO INTERNAL ROW
C             SCALING OF THE MATRIX A HAS BEEN DONE. OTHERWISE
C             SCALING HAS BEEN DONE
C     DIAG()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING THE DIAGONAL ELEMENTS OF THE SCALING MATRIX
C             INTERNAL SCALING HAS BEEN DONE. OTHERWISE IT CONTAINS
C             THE LENGHT OF EACH ROW IN THE MATRIX A
C
C     ON RETURN@D
C
C     BETAK   REAL SCALAR-CONTAINS  DSQRT(D1NRM**2+B1NRM**2)
C     IND     INTEGER SCALAR-CONTAINS
C             = 1 IF GAUSS-NEWTON SEARCH DIRECTION IS ACCEPTED
C             =-1 IF SUBSPACE MINIMIZATION IS SUGGESTED
C             = 2 IF THE METHOD OF NEWTON IS SUGGESTED
C
C
C     COMMON VARIABLES CONTAINING INFORMATION CONCERNING PREVIOUS
C     TWO POINTS. THE SUFFICES KM2 AND KM1 IN THE NAMES OF THE
C     VARIABLES REPRESENT TIME STEP K-2 AND K-1
C     THESE VARIABLES ARE UPDATED ONLY INSIDE THE ROUTINE EVREST
C
      INTEGER RKAKM2,RKCKM2,KODKM2,RKAKM1,RKCKM1,KODKM1,TKM2,TKM1
      DOUBLE PRECISION
     *     BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,ALFKM2,
     1 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     2 PGRESS,PRELIN
      COMMON /PREC/ BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,
     1 ALFKM2,RKAKM2,RKCKM2,TKM2,KODKM2,
     2 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     3 RKAKM1,RKCKM1,TKM1,KODKM1,
     4 PGRESS,PRELIN
C
C     COMMON VARIABLES CONTAINING INFORMATION OF RESTART STEPS
C
      DOUBLE PRECISION
     *    BESTRK,BESTPG
      INTEGER NRREST,LATTRY
      COMMON /BACK/ BESTRK,BESTPG, NRREST,LATTRY
      integer ifree
      common /negdir/ ifree
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER PP1,I,J,NMT,QPT
      DOUBLE PRECISION
     *     NLK,NLKM1,EPS,DELTA,SQREL,ROWI,C1,C2,C3,C4,C5
      LOGICAL NEG
      DATA DELTA /0.1D0/
      DATA C1,C2,C3,C4,C5 /0.5D0,0.1D0,4.0D0,10.0D0,0.05D0/
      BETAK=DSQRT(D1NRM**2+B1NRM**2)
      PP1=P+1
      NMT=N-T
      QPT=Q+T
C
C     TO ACCEPT THE GAUSS-NEWTON SEARCH DIRECTION WE MUST NOT HAVE
C     USED THE METHOD OF NEWTON BEFORE AND CURRENT STEP MUST NOT
C     BE A RESTART STEP
C
      IF(RESTAR.OR.(KODKM1.EQ.2)) GOTO 10
C
C     IF ANY OF THE FOLLOWING CONDITIONS IS SATISFIED THE GAUSS-
C     NEWTON DIRECTION IS ACCEPTED
C
C     1) THE FIRST ITERATION STEP
C     2) ESTIMATED CONVERGENCE FACTOR < C1
C     3) THE REAL PROGRESS > C2*PREDICTED LINEAR PROGRESS
C        (PROVIDED WE ARE NOT CLOSE TO THE SOLUTION)
C
      IND=1
      if(ifree.gt.0)ifree=ifree-1
      if(ifree.eq.4)return
      IF((K.EQ.0).AND..NOT.RESTAR) RETURN
      IF(-1.EQ.KODKM1) GOTO 10
      if(add .or. del) return
      IF(BETAK.LT.C1*BETKM1) RETURN
      IF((PGRESS.GT.C2*PRELIN).AND.(DNRM.LE.C3*BETAK)) RETURN
   10 CONTINUE
C
C     SUBSPACE MINIMIZATION IS SUGGESTED IF ONE OF THE FOLLOWING
C     HOLDS TRUE
C
C     4) THERE IS SOMETHING LEFT TO REDUCE IN SUBSPACES
C     5) ADDITION AND/OR DELETION TO/FROM CURRENT WORKING SET
C        HAS BEEN DONE IN THE LATEST STEP
C     6) THE NONLINEARITY IS NOT TOO SEVER
C
      ind=-1
      if(ifree.gt.0)return
      IF((KODKM1.EQ.2).AND..NOT.DEL) GOTO 60
      NLK=DSQRT(D1NRM**2+HSUM)
      NLKM1=DSQRT(D1APM1**2+HSUM)
      NEG=.FALSE.
      PP1=P+1
      IF(PP1.GT.T) GOTO 30
      SQREL=DSQRT(DRELPR)
      DO 20 I=PP1,T
        ROWI=DIAG(I)
        IF(SCALE .NE. 0) ROWI=1.0D0/DIAG(I)
        IF(-SQREL .LT. V(I)*ROWI) GOTO 20
        IF(V(I) .LT. 0.0D0) NEG=.TRUE.
   20 CONTINUE
   30 CONTINUE
      IF(Q.LE.0) GOTO 50
      DO 40 I=1,Q
           J=INACT(I)
           IF(H(J).LT.DELTA) NEG=.TRUE.
   40 CONTINUE
   50 CONTINUE
C
C     IN SOME SITUATIONS WE CAN'T TAKE THE RISK OF SUGGESTING
C     THE METHOD OF NEWTON
C
      if(hsum.gt.c2)return
      IF(ADD.OR.DEL.OR.NEG.OR.((T.EQ.N).AND.(T.EQ.RANKA))) RETURN
      IF((QPT.EQ.P).OR.(RANKA.LT.T)) GOTO 55
      EPS=DMAX1(1.0D-2,10.0D0*EPSREL)
      IF(.NOT.((BETAK.LT.EPS*DNRM).OR.((B1NRM.LT.EPS).AND.(M.EQ.NMT))))
     1    RETURN
   55 CONTINUE
      IF(RESTAR) GOTO 70
      IF(((ALFKM1.LT.C5).AND.(NLKM1.LT.C2*NLK)).OR.(M.EQ.NMT)) GOTO 60
      IF(DNRM.LE.C4*BETAK) RETURN
C
C     THE METHOD OF NEWTON IS THE ONLY ALTERNATIVE
C
   60 CONTINUE
      IND=2
      RETURN
   70 CONTINUE
      IF(NLKM1.GT.C2*NLK) RETURN
      IND=2
      RETURN
      END
CSUBSPC
      SUBROUTINE SUBSPC(RESTAR,FSUM,C,MDC,M,N,
     1 RANKC2,F,P3,D3,A,MDA,T,RANKA,
     2 HSUM,P1,D2,P2,B,FMAT,MDF,PIVOT,GMAT,MDG,
     3 D,DX,WORK1,DIMA,DIMC2         )
      INTEGER MDC,M,N,RANKC2,MDA,T,RANKA,MDF,
     1 MDG,DIMA,DIMC2
      INTEGER P3(N),P1(1),P2(1)
      DOUBLE PRECISION
     *     FSUM,HSUM
      DOUBLE PRECISION
     *     C(MDC,N),F(M),D3(N),A(MDA,N),D2(1),B(1),
     1 FMAT(MDF,N),PIVOT(1),GMAT(MDG,N),D(M),DX(N),
     2 WORK1(1)
      LOGICAL RESTAR
C
C     THE ORIGINAL SYSTEM  A*DX = -H
C                          C*DX APPR.= -F
C     IS TRANSFORMED TO    R*DY1 = B1
C                          U*DY2 = D1
C     WHERE   R IS RANKA*RANKA UPPER TRIANGULAR
C             U IS RANKC2*RANKC2 UPPER TRIANGULAR
C     AND             T   T
C            (R@D0)= Q2 *P1 *A*Q1*FMAT*P2
C          B=(B1)   T   T       (C1@DC2)=C*Q1*FMAT*P2
C            (B2)=Q2 *P1 *(-H)
C     (U))    T             D=(D1)      T
C     (0) = Q3 *C2*P3         (D2) = -Q3 *(F+C1*DY1)
C         DX=Q1*FMAT*P2*(DY1)
C                       (P3*DY2)
C
C     THIS ROUTINE CHOOSES THE DIMENSIONS OF THE SUBSPACES
C     WHERE MINIMIZATION SHOULD BE DONE
C     I.E. HOW MANY COLUMNS OF R AND U SHOULD BE USED
C
C     ON ENTRY@D
C
C     RESTAR  LOGICAL SCALAR = TRUE IF CURRENT STEP IS A RESTART STEP
C             = FALSE IF NO RESTART WAS DONE
C     FSUM    REAL SCALAR CONTAINIG SUM OF SQUARED RESIDUALS
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*N
C             CONTAINING (C1@DU) AND INFO. TO FORM Q3
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     RANKC2  INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX C2
C     D()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING    T
C                        -Q3 *(F+C1*DY1)
C     P3()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION N-T
C             REPRESENTING PERMUTATION MATRIX P3
C     D3()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N-T
C             CONTAINING INFO. TO FORM Q3
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMESION MDA*N
C             CONTAINING MATRIX L FROM (L@D0) AND INFO. TO FORM Q1
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     RANKA   INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX A
C     HSUM    REAL SCALAR CONTAINING SUM OF SQUARED CONSTRAINTS
C             IN CURRENT WORKING SET
C     P1()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING PERMUTATION MATRIX P1
C     D2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q2
C     P2()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING PERMUTATION MATRIX P2
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING  (B1)
C                         (B2)
C     FMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDF*N
C             CONTAINING A PRODUCT OF GIVENS ROTATION MATRICES
C     MDF     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY FMAT
C     PIVOT() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     GMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDG*N
C             CONTAINING MATRIX R AND INFO. TO FORM Q2
C     MDG     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY GMAT
C
C     ON RETURN@D
C
C     DIMA    INTEGER SCALAR-CONTAINS DIMENSION SUGGESTED FOR R
C     DIMC2   INTEGER SCALAR-CONTAINS DIMENSION SUGGESTED FOR C2
C
C     WORKING AREAS@D
C
C     DX()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C     WORK1() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C
C     COMMON VARIABLES CONTAINING INFORMATION CONCERNING PREVIOUS
C     TWO POINTS. THE SUFFICES KM2 AND KM1 IN THE NAMES OF THE
C     VARIABLES REPRESENT TIME STEP K-2 AND K-1
C     THESE VARIABLES ARE UPDATED ONLY INSIDE THE ROUTINE EVREST
C
      INTEGER RKAKM2,RKCKM2,KODKM2,RKAKM1,RKCKM1,KODKM1,TKM2,TKM1
      DOUBLE PRECISION
     *     BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,ALFKM2,
     1 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     2 PGRESS,PRELIN
      COMMON /PREC/ BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,
     1 ALFKM2,RKAKM2,RKCKM2,TKM2,KODKM2,
     2 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     3 RKAKM1,RKCKM1,TKM1,KODKM1,
     4 PGRESS,PRELIN
C
C     COMMON VARIABLES CONTAINING INFORMATION OF RESTART STEPS
C
      DOUBLE PRECISION
     *    BESTRK,BESTPG
      INTEGER NRREST,LATTRY
      COMMON /BACK/ BESTRK,BESTPG, NRREST,LATTRY
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER I,K,DRKM1,DUKM1
      DOUBLE PRECISION
     *     HPGRS,FPGRS,B1ASPR,D1ASPR,ETAA,ETAC,DNRM2,
     1     r11td1,r22td2,beta1,beta2,lowalf
      save r11td1,r22td2
      data beta1,beta2,lowalf /0.1d0,0.1d0,0.2d0/
      DIMA=0
C
C     MOVE -F TO D
C
      DO 10 I=1,M
           D(I)=-F(I)
   10 CONTINUE
C
C     TRANSFORM L IN (L@D0) TO UPPER TRIANGULAR FORM IF IT
C     IS NOT DONE BEFORE
C
      ETAA=1.0D0
      IF(RANKA.LE.0) GOTO 50
      IF(T.GT.RANKA) GOTO 20
      IF(NRREST.GT.1) GOTO 20
      CALL LTOUP(A,MDA,RANKA,T,B,MDG,P2,GMAT,D2)
C
C     DO COORDINATE CHANGE IN MATRIX C1 BY FORMING
C     C1@D=C1*P2
C
      CALL VP(C,MDC,M,RANKA,P2)
*
*     compute norms of R11(T)*d1 and R22(T)*d2
*
      call rtd(a,mda,ranka,b,r11td1)
      do 15 i=1,rankc2
       k=ranka+i
       call h12per(2,i,i+1,m,c(1,k),1,d3(i),d,1,m,1,c(i,k))
   15 continue
      call rtd(c(1,ranka+1),mdc,rankc2,d,r22td2)
      do 17 i=1,m
       d(i)=-f(i)
   17 continue
   20 CONTINUE
      DO 30 I=1,RANKA
           DX(I)=B(I)
   30 CONTINUE
C
C     DRKM1 = PSEUDO RANK OF R USED IN THE LATEST STEP
C     B1ASPR = II B1 II  WHERE B1 BELONGS TO R(DRKM1)
C
      DRKM1=IABS(RKAKM1)+T-TKM1
      B1ASPR=DNRM2(DRKM1,B,1)
C
C     DETERMINE DIMENSION OF MATRIX R TO BE USED
C
      HPGRS=HSQKM1-HSUM
      if(.not.restar .and. (r11td1.lt.beta1*r22td2))then
       dima=0
      else
      CALL DIMUPP(RESTAR,DRKM1,HPGRS,RANKA,GMAT,MDG,DX,WORK1,
     1 B1KM1,B1ASPR,ALFKM1,DIMA,ETAA )
      endif
C
C     SOLVE FOR DY1 THE SYSTEM  R*DY1 = B1
C     BY USING DIMA COLUMNS OF MATRIX R
C
      DO 40 I=1,RANKA
           DX(I)=B(I)
   40 CONTINUE
      CALL USOLVE(MDG,DIMA,GMAT,DX)
C
C     FORM RIGHT HAND SIDE   -F-C1*DY1
C     AND STORE IN ARRAY D
C
      CALL YCOMP(DIMA,M,D,C,MDC,DX)
   50 CONTINUE
      DIMC2=RANKC2
      IF(RANKC2.LE.0) GOTO 65
C                   T
C     COMPUTE D@D= Q3 *(-F-C1*DY1)
C
      DO 60 I=1,RANKC2
           K=RANKA+I
           CALL H12PER(2,I,I+1,M,C(1,K),1,D3(I),D,1,M,1,C(I,K))
   60 CONTINUE
C
C     DUKM1 = PSEUDO RANK OF MATRIX U USED IN THE LATEST STEP
C     D1ASPR =  II D II   WHERE D BELONGS TO R(DUKM1)
C
   65 CONTINUE
      DUKM1=IABS(RKCKM1)+TKM1-T
      D1ASPR=DNRM2(DUKM1,D,1)
      FPGRS=FSQKM1-FSUM
C
C     DETERMINE DIMENSION OF U TO BE USED
C
      if(.not.restar .and. (r22td2.lt.beta2*r11td1))then
       dimc2=0
       etac=1.0d0
      else
      CALL DIMUPP(RESTAR,DUKM1,FPGRS,RANKC2,C(1,RANKA+1),MDC,
     1 D,WORK1,D1KM1,D1ASPR,ALFKM1,DIMC2,ETAC)
      endif
      IF(.NOT.RESTAR) GOTO 120
   70 CONTINUE
C
C     REDUCE THE DIMENSION CORRESPONDING TO EITHER THE CONSTRAINTS
C     OR THE OBJECTIVE FUNCTION
C
      IF(NRREST.GT.1) GOTO 90
   80 CONTINUE
      BESTPG=PGRESS
      RKCKM2=RKCKM1
      RKAKM2=RKAKM1
   90 CONTINUE
      IF(PGRESS.GT.BESTPG) GOTO 80
      IF(ETAA.ge.ETAC) GOTO 100
      DIMC2=RKCKM1
      DIMA=MAX0(RKAKM1-1,0)
      GOTO 110
  100 CONTINUE
      IF((ETAA.EQ.ETAC).AND.(RANKA.GT.1)) RKAKM1=RKAKM1-1
      DIMC2=MAX0(0,RKCKM1-1)
      DIMA=RKAKM1
      IF((DIMC2.EQ.0).AND.(RANKA.EQ.1)) DIMA=0
  110 CONTINUE
      IF((DIMC2.GT.0).OR.(DIMA.GT.0)) GOTO 120
      DIMC2=RKCKM2
      DIMA=RKAKM2
      LATTRY=0
  120 CONTINUE
      if(restar) return
      if(alfkm1.ge.lowalf) then
       dima=max0(dima,drkm1)
       dimc2=max0(dimc2,dukm1)
      endif
      RETURN
      END
c
c      double precsion 880410
c
      subroutine rtd(R,mdr,n,d,rtdnrm)
      integer mdr,n
      double precision R(mdr,1),d(1),rtdnrm
*
*     compute rtdnrm = 2-norm of R(T)*d
*
      integer i,j
      double precision sum,sum2
      sum=0.0d0
      do 20 j=1,n
       sum2=0.0d0
       do 10 i=1,j
        sum2=sum2+R(i,j)*d(i)
   10  continue
       sum=sum+sum2**2
   20 continue
      rtdnrm=sqrt(sum)
      return
      end
c
c     double precision 880410
CDIMUPP
      SUBROUTINE DIMUPP(RESTAR,KM1RNK,PGRESS,KP1,A,MDA,B,R,PRELIN,
     1 ASPREV,ALFKM1,NEWDIM,ETA)
      INTEGER KM1RNK,KP1,MDA,NEWDIM
      DOUBLE PRECISION
     *     PGRESS,PRELIN,ASPREV,ALFKM1,ETA
      DOUBLE PRECISION
     *     A(MDA,1),B(1),R(1)
      LOGICAL RESTAR
C
C     DETERMINE SUITABLE DIMENSION FOR SOLVING
C                A*X  = B
C     WHERE
C           A IS UPPER TRIANGULAR (KP1*KP1)
C           B IS KP1*1
C
C         NEWDIM HOLDS THE SUGGESTED DIMENSION ON RETURN
C
C     ON ENTRY@D
C
C     RESTAR  LOGICAL SCALAR = TRUE IF THIS IS A RESTART STEP
C             = FALSE OTHERWISE
C     KM1RNK  INTEGER SCALAR CONTAINING DIMENSION USED IN THE
C             LATEST STEP
C     PGRESS  REAL SCALAR CONTAINING THE REDUCTION IN THE OBJECTIVE
C             OF CONSERN IN THE LATEST STEP
C     KP1     INTEGER SCALAR CONTAINING THE PSEUDO RANK OF MATRIX A
C     A()     REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*KP1
C             CONTAINING THE UPPER TRIANGULAR MATRIX A
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION KP1
C             CONTAINING THE RIGHT HAND SIDE
C     R()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION KP1
C             WORKING AREA
C     PRELIN  REAL SCALAR CONTAINING THE SQUARE ROOT OF THE PREDICTED
C             REDUCTION IN THE OBJECTIVE OF CONSERN IN THE LATEST STEP
C     ASPREV  REAL SCALAR CONTAINING THE SQUARE ROOT OF THE PREDICTED
C             IN THE OBJECTIVE OF CONSERN IN THE CURRENT STEP IF THE SAME
C             DIMENSION AS IN THE PREVIOUS STEP IS USED
C     ALFKM1  REAL SCALAR CONTAINING THE STEPLENGTH USED IN THE
C             LATEST STEP
C
C     ON RETURN@D
C
C     NEWDIM  INTEGER SCALAR-CONTAINS THE SUGGESTED DIMENSION
C     ETA     REAL SCALAR-CONTAINS 1.0 WHEN RESTAR IS FALSE OR KP1<=0
C             IF RESTAR IS TRUE AND KP1>0 ETA=L(KM1RNK-1)/L(KM1RNK)
C             WHERE L(I) IS THE LENGTH OF AN ESTIMATED SEARCH DIRECTION
C             COMPUTED BY USING DIMENSION I
C
C     INTERNAL VARIABLES
C
      INTEGER I,IK,K,MINDIM
      DOUBLE PRECISION
     *     C1,C2,PGB1,PGB2,STEPB,RN,SN,DNRM2,psimax,dsum,psi
      DATA C1,C2 /0.1D0,0.01D0/
      DATA STEPB,PGB1,PGB2 /0.2D0,0.3D0,0.1D0/
      NEWDIM=KP1
      ETA=1.0D0
      IF(KP1.LE.0) RETURN
C
C     COMPUTE THE LENGTH OF THE ESTIMATED SEARCH DIRECTIONS
C     AND RIGHTHAND SIDES
C
      R(1)=DABS(B(1))
      B(1)=DABS(B(1)/A(1,1))
      IF(KP1.EQ.1) GOTO 15
      DO 10 I=2,KP1
           R(I)=B(I)
           B(I)=B(I)/A(I,I)
           B(I)=DNRM2(2,B(I-1),1)
           R(I)=DNRM2(2,R(I-1),1)
   10 CONTINUE
   15 CONTINUE
      RN=R(KP1)
      SN=B(KP1)
C
C     DETERMINE LOWEST POSSIBLE DIMENSION
C
*      DO 20 I=1,KP1
*           MINDIM=I
*           IF(R(I).GT.C1*RN) GOTO 30
*   20 CONTINUE
*   30 CONTINUE
      dsum=0.0d0
      psimax=0.0d0
      do 20 i=1,kp1
       dsum=dsum+b(i)**2
       psi=sqrt(dsum)*abs(a(i,i))
       if(psi.gt.psimax)then
        psimax=psi
        mindim=i
       endif
   20 continue
C
C     IF THE LATEST STEP WAS FAIRLY GOOD THE DIMENSION MUST NOT
C     BE DECREASED
C
*      IF((ALFKM1.GE.STEPB).OR.(PGRESS.GT.PGB1*PRELIN**2).OR.
*     1  (PGRESS.GT.PGB2*ASPREV**2)) MINDIM=MAX0(MINDIM,KM1RNK)
      K=MINDIM
      IF(RESTAR) GOTO 40
      IF((KM1RNK.EQ.KP1).OR.(KM1RNK.LE.0)) CALL PREGN(B,SN,R,RN,
     1 MINDIM,KP1,IK)
      IF((KM1RNK.NE.KP1).AND.(KM1RNK.GT.0)) CALL PRESUB(B,R,RN,C1,KP1,
     1 KM1RNK,PGRESS,PRELIN,ASPREV,ALFKM1,IK)
      NEWDIM=MAX0(MINDIM,IK)
      RETURN
   40 CONTINUE
      NEWDIM=MIN0(KP1,KM1RNK)
      NEWDIM=MAX0(NEWDIM,0)
      IF(NEWDIM.EQ.0) RETURN
      K=MAX0(KM1RNK-1,1)
      IF(B(NEWDIM).NE. 0.0D0) ETA=B(K)/B(NEWDIM)
      RETURN
      END
C
C     DOUBLE PRECISION VERSION 880505
CMULEST
      SUBROUTINE MULEST(TIME,A,MDA,T,N,G,BV,J,TOL,D1,H,MDH,PIVOT,
     1  P,ISCALE,DIAG,V,PRANKA,RESIDU,S,U,W)
      INTEGER TIME,MDA,T,N,J,ISCALE,PRANKA
      INTEGER P(1)
      DOUBLE PRECISION
     *     TOL,RESIDU
      DOUBLE PRECISION
     *     A(MDA,N),G(N),BV(1),D1(1),V(1),S(N),U(N),W(N)
      DOUBLE PRECISION
     *     H(MDH,N),PIVOT(1),DIAG(1)
C
C     THE MAIN PURPOSE IS TO
C     COMPUTE ESTIMATES OF LAGRANGE MULTIPLIERS BY SOLVING FOR V
C     THE OVERDETERMINED SYSTEM
C          A(TR)*V = G   WHERE A IS  T*N  (T<=N)
C                                      -1
C     THEN V IS REPLACED BY V-(A*A(TR))  *H
C     THE SOLUTION IS COMPUTED BY DETERMINING MATRICES Q1 AND P1 SO
C     THAT   P1(TR)*A*Q1 = (L@D0)
C     WHERE  Q1 IS SYMMETRIC ORTHOGONAL   N*N
C            P1 IS A PERMUTATION MATRIX   T*T
C            L IS LOWER TRIANGULAR       T*T
C     THIS FACTORIZATION CAN BE USED TO SOLVE       A(TR)*V = G
C     IF WE USE THE TRANSPOSE OF IT                T
C     NAMELY                   Q1(TR)*A(TR)*P1 = (L )
C                                                (0 )
C     THE FACTORIZATION  P1(TR)*A*Q1
C     WILL LATER BE USED TO SOLVE THE SYSTEM  A*DX = BV
C     FORM  BV@D= P1(TR)*BV   TO BE ABLE TO COMPLETE THE SOLUTION LATER
C
C     THIS FACTORIZATION ARE UPDATED IF TIME>1
C
C     ON ENTRY.....
C
C     TIME         INTEGER. THIS ROUTINE CAN BE CALLED IN 3 DIFFERENT
C                  SITUATIONS DEPENDING ON THE VALUE OF TIME
C                  IF TIME
C                  =1  COMPUTE FACTORIZATION  P1(TR)*A*Q1=(L@D0)
C                      L IS T*T LOWER TRIANGULAR
C                  =2  COLUMN J IN L(TR) IS DELETED I.E. ROW J IN ARRAY A
C                      COMPUTE GIVENS ROTATIONS SO THAT THE MODIFIED
C                      L-MATRIX IS TRANSFORMED TO LOWER TRIANGULAR
C                      FORM L2 WHERE  L2 IS (T-1)*(T-1)
C                  >2  COLUMN J IN L(TR) IS DELETED
C                      COMPUTE GIVENS ROTATIONS AS IF TIME=2 BUT
C                      DO MULTIPLICATIONS BY GIVENS MATRICES ONE BY ONE
C     A(T,N),MDA   REAL MATRIX OF ORDER T*N. MDA IS THE LEADING
C                  DIMENSION OF ARRAY A IN THE CALLING PROGRAM
C                  IF TIME=1
C                     THEN A CONTAINS MATRIX TO BE FACTORIZED
C                     ELSE A CONTAINS L AS FIRST T COLUMNS AND
C                               NORMALS DEFINING Q1 AS FIRST T ROWS
C     T            INTEGER. NO. OF CONSTRAINTS IN CURRENT WORKING SET
C     G(N)         REAL VECTOR OF ORDER N. THE GRADIENT OF THE
C                  OBJECTIVE FUNCTION IF TIME=1.  IF TIME>1
C                  THEN G=Q1(TR)*G
C     BV(T)        REAL VECTOR OF ORDER T
C                  IF TIME=1
C                     THEN BV(I),I=1,...T IS NEG. VALUE OF CONSTRAINTS
C                            IN CURRENT WORKING SET
C                     ELSE BV IS MODIFIED BV SUCH THAT BV=P(TR)*BV
C     J            INTEGER
C                  IF TIME=1
C                     THEN J IS UNDEFINED
C                     ELSE J IS THE COLUMN OF MATRIX L(TR) THAT IS
C                            DELETED
C     TOL          REAL. A SMALL POSITIVE VALUE USED TO DETERMINE
C                  THE PSEUDO RANK OF THE MATRIX A
C     D1(T)        REAL VECTOR OF ORDER T
C                  IF TIME=1
C                     THEN D1 IS UNDEFINED
C                     ELSE D1 CONTAINS MISSING ELEMENTS OF NORMALS
C                          THAT DEFINE THE ORTHOGONAL MATRIX Q1
C     H(N,N),MDH   REAL MATRIX OF ORDER N*N. MDH IS THE LEADING
C                  DIMENSION OF ARRAY H IN THE CALLING PROGRAM
C                  IF TIME=1
C                     THEN H IS UNDEFINED
C                     ELSE H IS THE MATRIX FORMED WHEN GIVENS ROTATIONS
C                          IS MULTIPLIED TOGETHER
C     PIVOT(T)     REAL VECTOR OF ORDER PRANKA (FOR TIME=1 SEE PRANKA)
C                  IF TIME =1
C                     THEN PIVOT IS UNDEFINED
C                     ELSE PIVOT HOLDS THE PIVOT ELEMENTS USED WHEN
C                          THE A-MATRIX WAS TRANSFORMED TO LOWER
C                          TRIANGULAR FORM
C     P(T)         INTEGER VECTOR OF ORDER T HOLDING THE PIVOT RECORD
C                  WHEN P1(TR)*A*Q1 IS COMPUTED
C                  IF TIME=1
C                     THEN P IS UNDEFINED
C                     ELSE P REPRESENTS THE PIVOT MATRIX P1
C     ISCALE     INTEGER. IF ISCALE
C                         =0 NO SCALING OF MATRIX A IS DONE
C                         >0 SCALING OF THE ROWS OF A IS DONE
C     DIAG(T)    REAL VECTOR OF ORDER T HOLDING THE DIAGONAL ELEMENTS
C                OF THE SCALING MATRIX IF ISCALE>0
C                OTHERWISE DIAG(I) HOLDS THE EUCLIDEAN LENGTH OF ROW
C                NO. I OF THE MATRIX A
C
C     ON RETURN......
C     TIME         TIME@D=TIME+1
C     A(T,N)       SEE ON INPUT
C     H(N,N)       SEE ON INPUT
C     D1(T)        SEE ON INPUT
C     P(T)         SEE ON INPUT
C     V(T)         REAL VECTOR OF ORDER T.
C                  HOLDS THE ESTIMATED LAGRANGE MULTIPLIERS
C     PRANKA       INTEGER
C                  IF TIME=1
C                    THEN PRANKA@D=PSEUDORANK OF A OBTAINED BY USING TOL
C                    ELSE PRANKA =T
C     RESIDU       REAL
C                  THE RESIDUAL OBTAINED WHEN A(TR)*L = G
C                  IS SOLVED
C
C     WORKING AREAS......
C     S(N),U(N),W(N)   REAL VECTORS ALL OF ORDER N
C
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES.......
C
      INTEGER CTRL,I,TP1,K,K1,K2,IP1,IST
      DOUBLE PRECISION
     *     CO,SI,PI,ETA,COM1,DNRM2
      CTRL=TIME
      TIME=TIME+1
      PRANKA=T
      RESIDU=0.0D0
      IF(CTRL.EQ.1) GOTO 100
      IF(CTRL.GE.2) GOTO 200
  100 CONTINUE
      IF(T.EQ.0) RESIDU=DNRM2(N,G,1)
      IF(T.EQ.0) RETURN
C
C     FACTORIZE MATRIX A SO THAT    P1(TR)*A*Q1=(L@D0)
C     AND FORM    G@D=Q1(TR)*G
C
      CALL ATOLOW(T,N,P,A,MDA,TOL,PRANKA,D1,G)
C
C     SAVE THE COMPUTED PIVOT ELEMENTS IN THE PIVOT-VECTOR
C
      DO 110 I=1,PRANKA
      PIVOT(I)=A(I,I)
  110 CONTINUE
C
C     TRANSFORM RIGHT HAND SIDE OF SYSTEM A*DX=BV
C
      CALL PTRV(P,T,BV,T,1)
C
C     COMPUTE ESTIMATES OF LAGRANGE MULTIPLIERS
C
      CALL ATSOLV(A,MDA,PRANKA,G,V,N,RESIDU)
      IF(PRANKA.EQ.T) GOTO 130
      IP1=PRANKA+1
      DO 120 I=IP1,T
      V(I)=0.0D0
  120 CONTINUE
  130 CONTINUE
      CALL NZESTM(A,MDA,PRANKA,T,BV,V,W,U)
C
C     DO BACK PERMUTATIONS
C
      CALL PV(P,T,V,T,1)
      GOTO 290
  200 CONTINUE
      IF(T.EQ.0) RETURN
C
C     COMPUTE GIVENS ROTATIONS SO THAT THE LOWER HESSENBERG
C     MATRIX L IS TRANSFORMED TO LOWER TRIANGULAR FORM
C
      IF(CTRL.GE.3) GOTO 215
C
C     INITIATE THE PRODUCT OF GIVENS MATRICES
C
      DO 210 I=1,N
           DO 205 K=1,N
           H(I,K)=0.0D0
  205      CONTINUE
      H(I,I)=1.0D0
  210 CONTINUE
  215 CONTINUE
c      PRANKA=T
      TP1=T+1
      IF(J.EQ.TP1) GOTO 280
      PI=DRELPR
      IST=J
      DO 250 I=J,T
      IP1=I+1
      K1=I
      K2=I
      IF(I.GT.J) K1=K1+1
      IF(IP1.GT.J) K2=K2+1
C
C     COMPUTE GIVENS ROTATION
C
      CALL GIVEN1(A(K1,I),A(K2,IP1),CO,SI,A(I,I))
C
C     AND APPLY IT TO COLUMN I AND I+1 OF ARRAY A WHERE THE
C     LOWER TRIANGULAR MATRIX L IS STORED
C
      IF(IP1.GT.T) GOTO 230
           DO 220 K=IP1,T
           K1=K
           K2=K
           IF(I.GT.J) K1=K1+1
           IF(IP1.GT.J) K2=K2+1
           IF(SI.NE.0.0D0) CALL GIVEN2(CO,SI,A(K1,I),A(K2,IP1))
           A(K,I)=A(K1,I)
  220      CONTINUE
  230 CONTINUE
C
C     IF SI IS EXACTLY ZERO THEN NO GIVENS TRANSFORMATION
C     WAS NECESSARY
C
      IF(SI .NE. 0.0D0) GOTO 235
      U(I)=ETA
      W(I)=-COM1/ETA
      IF(CTRL.EQ.2) CALL PROD1(H,MDH,S,U,W,IST,I)
C     IF(CTRL.GE.3) CALL PROD2(H,MDH,N,S,U,W,IST,I,W1)
      IST=I+1
      GOTO 250
  235 CONTINUE
C
C     APPLY IT TO THE RIGHT HAND SIDE OF Q1(TR)*A(TR)*P1= Q1(TR)*G
C
      CALL GIVEN2(CO,SI,G(I),G(IP1))
C
C     SAVE TO BE ABLE TO FORM THE PRODUCT OF GIVENS MATRICES
C
      S(I)=SI
      IF(I.GT.IST) GOTO 240
      U(I)=CO/PI
      W(I)=PI
      ETA=SI/PI
      COM1=CO
      GOTO 250
  240 CONTINUE
      U(I)=CO*ETA
      W(I)=-COM1/ETA
      ETA=SI*ETA
      COM1=CO
  250 CONTINUE
      U(TP1)=ETA
      W(TP1)=-COM1/ETA
C
C     FORM THE PRODUCT OF GIVENS MATRICES
C
      IF(CTRL.EQ.2) CALL PROD1(H,MDH,S,U,W,IST,TP1)
C     IF(CTRL.GE.3) CALL PROD2(H,MDH,N,S,U,W,IST,TP1,W1)
  280 CONTINUE
c
c     what pseudo rank should be used
c
      k=1
      do 310 i=1,t
       if(abs(a(i,i)).lt.tol) goto 320
       k=k+1
  310 continue
  320 continue
      pranka=k-1
C
C     COMPUTE ESTIMATES AND RESIDUAL
C
      CALL ATSOLV(A,MDA,pranka,G,V,N,RESIDU)
      CALL NZESTM(A,MDA,PRANKA,T,BV,V,W,U)
      DO 285 I=1,T
        W(I)=V(I)
  285 CONTINUE
C
C     DO BACK PERMUTATIONS
C
      CALL PSPECF(T,P,W,V)
  290 CONTINUE
C
C     BACK TRANSFORM DUE TO ROW SCALING OF MATRIX A
C
      IF(ISCALE.EQ.0) RETURN
      DO 300 I=1,T
      V(I)=DIAG(I)*V(I)
  300 CONTINUE
      RETURN
      END
C     DOUBLE PRECISION VERSION 880425
C
CWEIGHT
      SUBROUTINE WEIGHT(W,WOLD,V1,F,FSUM,M,ACTIVE,T,H,L,NORM,DIMA,
     1 OLD,whnrm2,PSI0,DPSI0,ATWA,CTC,CTD,FNEW,HNEW,V2)
      INTEGER M,T,L,NORM,DIMA
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     PSI0,DPSI0,ATWA,CTC,CTD,FSUM,whnrm2
      DOUBLE PRECISION
     *     W(1),WOLD(1),F(M),V1(1),H(1),FNEW(1),HNEW(1),V2(1)
      LOGICAL OLD
C
C     DETERMINE THE PENALTY CONSTANTS THAT SHOULD BE USED IN
C     THE CURRENT LINESEARCH WHERE PSI(ALPHA)=PSI(XOLD+ALPHA*DX)
C     IS APPROXIMATELY MINIMIZED
C
C     ON ENTRY@D
C
C     W()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING PENALTY CONSTANTS USED IN THE LATEST TRY
C     WOLD()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING PENALTY CONSTANTS USED IN THE LATEST TRY
C             UNLESS THAT WAS A RESTART.IF RESTART WOLD=W
C     V1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M+T
C             CONTAINING THE COMPOUND VECTOR  (C*DX   )
C                                             (AHAT*DX)
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE VALUE OF THE RESIDUALS
C     FSUM    REAL SCALAR CONTAINING THE SUM OF SQUARED RESIDUALS
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING INDECES FOR CONSTRAINTS IN CURRENT WORKING SET
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS
C     L       INTEGER SCALAR CONTAINIG TOTAL NUMBER OF CONSTRAINTS
C     NORM    INTEGER SCALAR CONTAINING A CODE THAT CONTROLS WHICH
C             NORM THAT SHOULD BE USED WHEN PENALTY WEIGHTS ARE UPDATED
C             = 0 MAXIMUM NORM
C             = 2 EUCLIDEAN NORM
C     DIMA    INTEGER SCALAR CONTAINING DIMENSION USED FOR MATRIX AHAT
C     OLD     LOGICAL SCALAR = TRUE IF THE SEQUENCE OF PENALTY
C             CONSTANTS MAY RESTART BEGINNING WITH THE CONSTANTS
C             IN WOLD. = FALSE IF NO RESTART IS ALLOWED
C
C     ON RETURN@D
C
C     W()     CONTAINS THE NEW PENALTY CONSTANTS
C     PSI0    REAL SCALAR-CONTAINS PSI(0,W)  (SEE ABOVE)
C     DPSI0   REAL SCALAR-CONTAINS THE DERIVATIVE OF PSI(XOLD+ALF*DX,W)
C             WITH RESPECT TO ALF AT ALF=0
C                                        T
C     ATWA    REAL SCALAR-CONTAINS (A*DX) *W*(A*DX)
C     CTC     REAL SCALAR-CONTAINS II C*DX II**2
C     CTD     REAL SCALAR-CONTAINS THE DERIVATIVE OF FI(ALFHA)
C             AT ALPHA=0
C
C     WORKING AREAS@D
C
C     FNEW()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C     HNEW()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C     V2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C
C     INTERNAL VARIABLES
C
      INTEGER I,K,MPI, PSET(1)
      DOUBLE PRECISION
     *     BTWA,ATA,ALFA,DELTA,RMY,WHSUM,ANORM,BNORM,
     1       CNORM,DNORM,DNRM2,u,dalf
      DATA DELTA / 0.25D0 /
C                            T
C     COMPUTE   ATWA = (A*DX) *W*(A*DX)
C                ATA = II A*DX II**2
C                            T
C               BTWA = (A*DX) *W*H
C
C
C     RESTART THE PENALTY CONSTANT SEQUENCE IF SO INDICATED
C
      IF(.NOT.OLD) GOTO 20
      DO 10 I=1,L
        W(I)=WOLD(I)
   10 CONTINUE
   20 CONTINUE
*      write(10,*) 'In WEIGHT: dima= ',dima
*      write(10,*) 'The constraints'
*      write(10,*) (h(i),i=1,L)
*      write(10,*) 'A*p appr. = -c'
*      write(10,*) (v1(m+i),i=1,t)
      ANORM=DNRM2(dima,V1(M+1),1)
*      anorm=0.0
*      do 11 i=1,dima
*       anorm=anorm+v1(m+i)**2
*   11 continue
*      anorm=sqrt(anorm)
      ATA=ANORM**2
      IF(ANORM.NE. 0.0D0) CALL SCALV(V1(M+1),ANORM,dima)
      BTWA=0.0D0
      ATWA=0.0D0
      BNORM=0.0D0
      IF(dima.LE.0) GOTO 50
      DO 30 I=1,dima
           K=ACTIVE(I)
           MPI=M+I
           ATWA=ATWA+W(K)*V1(MPI)**2
           IF(DABS(H(K)).GT.BNORM) BNORM=DABS(H(K))
   30 CONTINUE
      IF(BNORM.NE. 0.0D0) CALL SCALV(H,BNORM,L)
      ATWA=ANORM*ANORM*ATWA
      DO 40 I=1,dima
        K=ACTIVE(I)
        MPI=M+I
        BTWA=BTWA+W(K)*V1(MPI)*H(K)
   40 CONTINUE
      BTWA=BNORM*ANORM*BTWA
   50 CONTINUE
C
C     COMPUTE     CTC = II C*DX II**2
C                         T  T
C                 CTD = DX *C *F
C
      CNORM=DNRM2(M,V1,1)
      CTC=CNORM**2
      IF(CNORM.NE. 0.0D0) CALL SCALV(V1,CNORM,M)
      DNORM=DSQRT(FSUM)
      IF(DNORM.NE. 0.0D0) CALL SCALV(F,DNORM,M)
      CTD=0.0D0
      DO 60 I=1,M
           CTD=CTD+V1(I)*F(I)
   60 CONTINUE
      CTD=CNORM*DNORM*CTD
C
C     COMPUTE THE VALUE  ALFA(W)
C
      if((atwa+ctc) .eq. 0.0d0)then
       alfa=1.0d0
      else
       alfa=(-btwa-ctd)/(atwa+ctc)
      endif
c      ALFA=(-BTWA-CTD)/(ATWA+CTC)
      PSI0=FSUM*0.5D0
      DPSI0=CTD
*      write(10,*) 'In WEIGHT: dpsi0= ',dpsi0
      ATWA=0.0D0
      whsum=0.0d0
      IF(T.LE.0) GOTO 100
      if(anorm.ne.0.0d0)then
          call scalv(v1(m+1),1.0d0/anorm,dima)
          call scalv(v1(m+1),anorm,t)
      endif
      RMY=DABS(-CTD-CTC)/DELTA-CTC
C
C     COMPUTE THE NEW PENALTY CONSTANTS
C
      IF(NORM.EQ.0) CALL MAXNRM(ATA,RMY,ALFA,DELTA,W,ACTIVE,T)
      IF(NORM.NE.0) CALL EUCNRM(V1(M+1),H,ACTIVE,T,RMY,ANORM,BNORM,
     1       DIMA,W,L,PSET,HNEW,V2)
*      write(10,*) 'New penalty weights from EUCNRM'
*      write(10,*) (w(i),i=1,L)
*      write(10,*) 'Active(i),i=1,t'
*      write(10,*) (active(i),i=1,t)
C
C     COMPUTE    PSI0 = PSI(0)
C               DPSI0 = (SEE ABOVE)
C                BTWA = (SEE ABOVE)
C
      BTWA=0.0D0
      DO 80 I=1,T
           K=ACTIVE(I)
           MPI=M+I
           WHSUM=WHSUM+W(K)*H(K)**2
           BTWA=BTWA+W(K)*V1(MPI)*H(K)
           ATWA=ATWA+W(K)*V1(MPI)**2
   80 CONTINUE
*      write(10,*) 'anorm,bnorm,btwa= ',anorm,bnorm,btwa
      WHSUM=BNORM*BNORM*WHSUM
      BTWA=ANORM*BNORM*BTWA
      ATWA=ANORM*ANORM*ATWA
      PSI0=0.5D0*(WHSUM+FSUM)
      DPSI0=BTWA+CTD
*      write(10,*) 'After rescaling: atwa,btwa= ',atwa,btwa
      dalf=(-btwa-ctd)/(atwa+ctc)
*      write(10,*) 'dalf in WEIGHT: ',dalf
*      write(10,*) 'dpsi0= ',dpsi0
  100 CONTINUE
      whnrm2=whsum
      IF(ANORM.NE. 0.0D0) CALL SCALV(V1(M+1),1.0D0/ANORM,t)
      IF(BNORM.NE. 0.0D0) CALL SCALV(H,1.0D0/BNORM,L)
      IF(CNORM.NE. 0.0D0) CALL SCALV(V1,1.0D0/CNORM,M)
      IF(DNORM.NE. 0.0D0) CALL SCALV(F,1.0D0/DNORM,M)
      RETURN
      END
