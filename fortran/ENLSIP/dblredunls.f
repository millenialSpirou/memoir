C
C     HELP ROUTINES (FILE 1) FOR ENLSIP
C     DOUBLE PRECISION VERSION 841005
CNEWPNT
      SUBROUTINE NEWPNT(X,N,H,L,F,M,HFUNC,FFUNC,MDA,MDC,
     1 FUNCEV,A,C,B,D,IER   )
      INTEGER N,L,M,MDA,MDC,FUNCEV,IER
      DOUBLE PRECISION
     *     X(N),H(1),F(M),A(MDA,N),C(MDC,N),B(1),D(M)
      EXTERNAL HFUNC,FFUNC
C
C     COMPUTE THE JACOBIANS A AND C CORRESPONDING TO THE
C     CONSTRAINTS AND THE RESIDUALS RESPECTIVELY
C
C     ON ENTRY@D
C
C     X()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE CURRENT POINT
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETRES
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS AT X
C     L       INTEGER SCALAR CONTAINING TOTAL NUMBER OF CONSTRAINTS
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE VALUE OF THE RESIDUALS AT X
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     HFUNC   SUBROUTINE NAME FOR CONSTRAINTS
C     FFUNC   SUBROUTINE NAME FOR RESIDUALS
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C
C     FUNCEV  INTEGER SCALAR CONTAINING TOTAL NUMBER OF FUNCTION
C             EVALUATION DONE SO FAR
C
C     ON RETURN@D
C
C     FUNCEV  FUNCEV@D=FUNCEV+N
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             ROW NO. I CONTAINS GRADIENT OF CONSTRAINT NO. I
C             I=1,2,......,L
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             ROW NO. I CONTAINS GRADIENT OF RESIDUAL NO. I
C             I=1,2,......,M
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             B(I)@D=-H(I)     I=1,2,.......,L
C     IER   INTEGER SCALAR CONTAINING A VALUE < -10 TO INDICATE
C           A POSSIBLE USER STOP
C
C     WORKING AREA@D
C
C     D()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C
C     INTERNAL VARIABLES
C
      INTEGER CTRLA,CTRLC,I
      CTRLC=2
      CALL FFUNC(X,N,F,M,CTRLC,C,MDC)
      IF(CTRLC.LT.(-10)) IER=CTRLC
      IF(IER.LT.(-10)) GOTO 40
      IF(CTRLC.NE.0) GOTO 10
C
C     COMPUTE THE JACOBIAN NUMERICALLY
C
      CALL JACDIF(X,N,F,M,FFUNC,C,MDC,D,IER)
      IF(IER.LT.(-10)) GOTO 40
      FUNCEV=FUNCEV+N
   10 CONTINUE
      IF(L.LE.0) RETURN
      CTRLA=2
      CALL HFUNC(X,N,H,L,CTRLA,A,MDA)
      IF(CTRLA.LT.(-10)) IER=CTRLA
      IF(IER.LT.(-10)) GOTO 40
      IF(CTRLA.NE.0) GOTO 20
C
C     COMPUTE THE JACOBIAN NUMERICALLY
C
      CALL JACDIF(X,N,H,L,HFUNC,A,MDA,B,IER)
      IF(IER.LT.(-10)) GOTO 40
   20 CONTINUE
      DO 30 I=1,L
              B(I)=-H(I)
   30 CONTINUE
   40 CONTINUE
  101 format(1x,8e10.3)
*      write(10,*) 'Constraints'
*      write(10,101) (h(i),i=1,l)
*      write(10,*) 'Functions'
*      write(10,101) (f(i),i=1,m)
      RETURN
      END
CEQUAL
      SUBROUTINE EQUAL(B,L,A,MDA,N,ACTIVE,T,P,P4)
      INTEGER L,MDA,n,T,P
      INTEGER ACTIVE(1),P4(1)
      DOUBLE PRECISION
     *     B(1),A(MDA,N)
C
C     MOVE THE CONSTRAINTS IN CURRENT WORKING SET TO THE TOP
C     PART OF ARRAY B
C     THE CORRESPONDING GRADIENTS ARE MOVED TO THE TOP ROWS
C     OF THE ARRAY A
C
C     INTERNAL VARIABLES
C
      INTEGER I,INDEX,IP,J,IK
      DOUBLE PRECISION
     *     TEMP
      IF(L.LE.0) GOTO 20
      DO 10 I=1,L
           P4(I)=I
   10 CONTINUE
   20 CONTINUE
      IF((T.LE.0).OR.(T.EQ.P)) RETURN
      DO 50 I=1,T
           INDEX=ACTIVE(I)
           IP=P4(INDEX)
           IF(IP.EQ.I) GOTO 50
           DO 30 J=1,N
                TEMP=A(I,J)
                A(I,J)=A(IP,J)
                A(IP,J)=TEMP
   30      CONTINUE
           TEMP=B(I)
           B(I)=B(IP)
           B(IP)=TEMP
           DO 40 J=1,T
                IF(I.NE.P4(J)) GOTO 40
                IK=J
   40      CONTINUE
           P4(IK)=IP
           P4(INDEX)=I
   50 CONTINUE
      RETURN
      END
CEVSCAL
      SUBROUTINE EVSCAL(SCALE,A,MDA,T,N,B,DIAG)
      INTEGER SCALE,MDA,T,N
      DOUBLE PRECISION
     *     A(MDA,N),B(1),DIAG(1)
C
C     SCALE THE SYSTEM  A*DX = B    IF SO INDICATED BY FORMING
C     A@D=DIAG*A      B@D=DIAG*B
C
C     ON ENTRY@D
C
C     SCALE   INTEGER SCALAR =0 IF NO SCALING SHOULD BE DONE
C             >0 IF SCALING SHOULD BE DONE
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING THE JACOBIAN OF THE WORKING SET
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS
C             IN CURRENT WORKING SET
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING THE NEGATIVE VALUE OF THE CONSTRAINTS IN THE
C             CURRENT WORKING SET
C
C     ON RETURN@D
C
C     A(,)    CONTAINS THE SCALED JACOBIAN IF SCALE>0
C     B()     CONTAINS THE SCALED RIGHT HAND SIDE IF SCALE>0
C     DIAG()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINS THE DIAGONAL ELEMENTS OF THE SCALING MATRIX
C
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     ROWI,ANORM,DNRM2
      ANORM=0.0D0
      IF(T.EQ.0) RETURN
      DO 20 I=1,T
              ROWI=DNRM2(N,A(I,1),MDA)
              IF(ROWI.GT.ANORM) ANORM=ROWI
              DIAG(I)=ROWI
              IF(SCALE.EQ.0) GOTO 20
              IF(ROWI.EQ.0.0D0) ROWI=1.0D0
              DO 10 J=1,N
                 A(I,J)=A(I,J)/ROWI
   10         CONTINUE
              B(I)=B(I)/ROWI
              DIAG(I)=1.0D0/ROWI
   20 CONTINUE
      RETURN
      END
CGNSRCH
      SUBROUTINE GNSRCH(TIME,A,MDA,T,N,D1,P1,RANKA,NOHOUS,B,FMAT,MDF,
     1 C,MDC,M,F,PIVOT,TAU,MDG,SCALE,DIAG,INACT,Q,P4,P2,P3,DX,V1,D2,D3,
     2 RANKC2,D1NRM,DNRM,B1NRM,D,S,U,GMAT)
      INTEGER TIME,MDA,T,N,RANKA,NOHOUS,MDF,MDC,M,MDG,SCALE,Q,RANKC2
      INTEGER P1(1),P2(1),P3(N),INACT(1),P4(1)
      DOUBLE PRECISION
     *     TAU,D1NRM,DNRM,B1NRM
      DOUBLE PRECISION
     *     A(MDA,N),D1(1),B(1),FMAT(MDF,N),C(MDC,N),F(M),PIVOT(1),
     1 DIAG(1),DX(N),V1(M),D2(1),D3(N),D(M),S(N),U(N),GMAT(MDG,N)
C
C     SOLVE FOR DX ONE OF THE COMPOUND SYSTEMS
C
C                                               T
C          (L@D0)*DY = B  (1)       (R@D0)*DY = Q2 *B    (2)
C         C*DY APPR.=-F               C*DY APPR.=-F
C     WHERE
C               T                           T
C     (L@D0) = P1 *A*Q1*FMAT       (R@D0) = Q2 *(L@D0)*P2
C                T
C          B = P1 *(-H)
C         DX = Q1*FMAT*DY              DX = Q1*FMAT*P2*DY
C     L IS LOWER TRIANGULAR RANKA*RANKA
C     R IS UPPER TRIANGULAR RANKA*RANKA
C
C     IF RANKA=T SYSTEM NO. (1) IS SOLVED OTHERWISE SYSTEM (2)
C     IS SOLVED
C
C     ON ENTRY@D
C
C     TIME    INTEGER SCALAR = 2 IF MATRIX FMAT IS THE IDENTITY MATRIX
C             >2 IF FMAT CONTAINS A PRODUCT OF GIVENS ROTATION MATRICES
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING MATRIX L AND INFO. TO FORM Q1
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     D1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     P1()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             REPRESENTING PERMUTATION MATRIX P1
C     RANKA   INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX A
C     NOHOUS  INTEGER SCALAR CONTAINING NUMBER OF HOUSEHOLDER
C             TRANSFORMATIONS USED TO FORM  (L@D0)
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING  T
C                       P1 *(-H)
C     FMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDF*N
C             IF TIME=2 FMAT IS UNDEFINED OTHERWISE IT CONTAINS
C             A PRODUCT OF GIVENS ROTATION MATRICES
C     MDF     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY FMAT
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*N
C             CONTAINING THE JACOBIAN OF THE RESIDUALS
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE VALUE OF THE RESIDUALS
C     PIVOT() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     TAU     REAL SCALAR CONTAING A SMALL VALUE USED TO DETERMINE
C             PSEUDO RANK OF MATRIX C2 (SEE BELOW)
C     MDG     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY GMAT
C     SCALE   INTEGER SCALAR =0 IF NO ROW SCALING OF MATRIX A HAS
C             BEEN DONE. >0 IF SCALING HAS BEEN DONE
C     DIAG()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING THE DIAGONAL MATRIX IN   T
C                                         (L@D0) = P1 *DIAG*A*Q1*FMAT
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION Q
C             CONTAINING INDECES FOR THE INACTIVE CONSTRAINTS
C     Q       INTEGER SCALAR CONTAINING NO. OF INACTIVE CONSTRAINTS
C     P4()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING INFO. TO COMPUTE A*DX FOR INACTIVE CONSTRAINTS
C
C     ON RETURN@D
C                                   T
C     B()     IF T>RANKA THEN  B@D=Q2 *B
C                        ELSE UNCHANGED
C     C(,)    CONTAINS  (C1 @D U)    WHERE  (C1@DC2)=C*Q1*FMAT*P2
C                       (     0)              T
C                                           Q3 *C2*P3 = (U)
C                                                       (0)
C     P2()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING PERMUTATION MATRIX P2 (IF IT IS USED)
C     P3()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION N-RANKA
C             REPRESENTING PERMUTATION MATRIX P3
C     DX()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINS THE GAUSS-NEWTON SEARCH DIRECTION
C     V1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M+T
C             CONTAINS THE COMPOUND VECTOR  (C*DX)
C                                           (A*DX)
C     D2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINS INFO. TO FORM Q2 (IF IT IS USED)
C     D3()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N-RANKA
C             CONTAINS INFO. TO FORM Q3
C     RANKC2  INTEGER SCALAR-CONTAINS PSEUDO RANK OF MATRIX C2
C                                      -1                     T
C             DENOTE  (D)=(D1)= -F-C1*L  *B1    WHERE  (B1)=Q2 *B
C                         (D2)                         (B2)
C             D1 IS RANKC2*1            B1 IS RANKA*1
C             THEN
C     D1NRM   REAL SCALAR-CONTAINS EUCLIDEAN NORM OF D1
C     DNRM    REAL SCALAR-CONTAINS EUCLIDEAB NORM OF D
C     B1NRM   REAL SCALAR-CONTAINS EUCLIDEAN NORM OF B1
C     D()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING    T
C                         Q3 *(-F-C1*DY1)
C     GMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDG*N
C             CONTAINS MATRIX R AND INFO. TO FORM Q2 (IF IT IS USED)
C
C     WORKING AREAS@D
C
C     S(),U() REAL SINGLY SUBSCRIPTED ARRAYS OF DIMENSION N
C
C     INTERNAL VARIABLES
C
      INTEGER KC2,NMP,CODE
      DOUBLE PRECISION
     *     TOL
C
C     TRANSFORM L IN (L@D0) TO UPPER TRIANGULAR FORM IF T>RANKA
C
*      write(10,*) 'In GNSRCH: ranka,t= ', ranka,t
      CODE=1
      IF(T.EQ.RANKA) GOTO 10
      CODE=-1
      CALL LTOUP(A,MDA,RANKA,T,B,MDG,P2,GMAT,D2)
   10 CONTINUE
C
C     DO COORDINATE CHANGES IN MATRIX C BY FORMING
C     (C1@DC2)=C*Q1*FMAT*P2  AND STORE IN ARRAY C
C
      CALL CQHP2(TIME,C,MDC,M,N,T,RANKA,PIVOT,NOHOUS,A,MDA,D1,
     1 FMAT,MDF,P2,S)
      KC2=RANKA+1
      NMP=N-RANKA
      TOL=DSQRT(DBLE(NMP))*TAU
C
C     TRANSFORM C2 TO UPPER TRIANGULAR FORM BY FORMING
C           T
C         Q3 *C2*P3 = (U)
C                     (0)
C
      CALL C2TOUP(M,NMP,C(1,KC2),MDC,TOL,P3,RANKC2,D3)
C
C     COMPUTE GAUSS-NEWTON SEARCH DIRECTION
C
      CALL SUBDIR(TIME,A,MDA,T,N,D1,P1,RANKA,RANKA,NOHOUS,B,FMAT,MDF,
     1 C,MDC,M,F,PIVOT,GMAT,MDG,D2,P2,P3,D3,RANKC2,INACT,Q,P4,RANKC2,
     2 CODE,SCALE,DIAG,D,DX,V1,D1NRM,DNRM,B1NRM,U)
      RETURN
      END
CMINMAX
      SUBROUTINE MINMAX(P,T,V,SCALE,DIAG,SIGMIN,ABSVMX)
      INTEGER P,T,SCALE
      DOUBLE PRECISION
     *     V(1),DIAG(1)
      DOUBLE PRECISION
     *     SIGMIN,ABSVMX
C
C     ON ENTRY@D
C
C     V()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING ESTIMATES OF THE LAGRANGE MULTIPLIERS
C     P       INTEGER SCALAR CONTAINING NUMBER OF EQUALITY CONSTRAINTS
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     SCALE   INTEGER SCALAR CONTAINING ZERO IF NO INTERNAL ROW
C             SCALING OF THE MATRIX A HAS BEEN DONE. OTHERWISE
C             SCALING HAS BEEN DONE
C     DIAG()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING THE DIAGONAL ELEMENTS OF THE SCALING MATRIX
C             IF INTERNAL SCALING HAS BEEN DONE. OTHERWISE IT
C             CONTAINS THE LENGHT OF EACH ROW IN THE MATRIX A
C
C     ON RETURN@D
C
C     SIGMIN  REAL SCALAR-CONTAINS THE SMALLEST MULTIPLIER
C             CORRESPONDING TO INEQUALITY CONSTRAINTS
C     ABSVMX  REAL SCALAR-CONTAINS MAXIMUM(DABS(V(I))  I=1,2,.....,T
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER I
      DOUBLE PRECISION
     *     ABSEL,SQREL,ROWI
      SQREL=DSQRT(DRELPR)
      SIGMIN=1.0D6
      ABSVMX=0.0D0
      IF(P.EQ.T) RETURN
      DO 10 I=1,T
              ABSEL=DABS(V(I))
              IF(ABSEL.GT.ABSVMX) ABSVMX=ABSEL
              IF(I.LE.P) GOTO 10
              ROWI=DIAG(I)
              IF(SCALE .NE. 0) ROWI=1.0D0/DIAG(I)
              IF(-SQREL .LT. V(I)*ROWI) GOTO 10
              IF(V(I).LT.SIGMIN) SIGMIN=V(I)
   10 CONTINUE
      RETURN
      END
CANALYS
      SUBROUTINE ANALYS(K,RESTAR,CODE,FSUM,D1NRM,DNRM,C,MDC,M,N,RANKC2,
     1 D,F,P3,D3,ACTIVE,V,INACT,Q,P4,TIME,A,MDA,P,T,RANKA,B1NRM,
     2 HSUM,NOHOUS,D1,P1,D2,P2,B,H,L,FMAT,MDF,PIVOT,GMAT,MDG,FFUNC,
     3 HFUNC,X,SEC,ADD,DEL,SCALE,DIAG,DX,DXNORM,V1,EPSREL,
     4 ERROR,EVAL,BETAK,DIMA,DIMC2,
     5 V2,WORK1                                )
      INTEGER K,CODE,MDC,M,N,RANKC2,TIME,MDA,P,T,RANKA,NOHOUS,MDF,MDG,
     1 L,SCALE,ERROR,EVAL,DIMA,DIMC2,Q
      INTEGER P3(N),ACTIVE(1),P1(1),P2(1),INACT(1),P4(1)
      DOUBLE PRECISION
     *     FSUM,D1NRM,DNRM,B1NRM,DXNORM,EPSREL,BETAK,HSUM
      DOUBLE PRECISION
     *     C(MDC,N),D(M),F(M),D3(N),V(1),A(MDA,N),D1(1),D2(1),B(1),
     1 H(1),FMAT(MDF,N),PIVOT(1),X(N),DIAG(1),DX(N),V1(1),
     2 GMAT(MDG,N),V2(1),WORK1(1)
      LOGICAL RESTAR,SEC,ADD,DEL
      EXTERNAL FFUNC,HFUNC
C
C     CHECK IF THE LATEST STEP WAS SUFFICIENTLY GOOD AND EVENTUALLY
C     RECOMPUTE THE SEARCH DIRECTION  BY USING EITHER SUBSPACE
C     MINIMIZATION OR THE METHOD OF NEWTON
C
C     ON ENTRY@D
C
C     K       INTEGER SCALAR CONTAINING CURRENT ITERATION NUMBER
C     RESTAR  LOGICAL SCALAR = TRUE IF CURRENT STEP IS A RESTART STEP
C             =FALSE IF NO RESTART HAS BEEN DONE
C     CODE    INTEGER SCALAR CONTAINING A CODE INDICATING HOW
C             THE LATEST SEARCH DIRECTION WAS COMPUTED
C             = 1 IF GAUSS-NEWTON
C             =-1 IF SUBSPACE MINIMIZATION
C             = 2 IF NEWTON
C     FSUM    REAL SCALAR CONTAINING SQUARED SUM OF THE RESIDUALS
C     D1NRM   REAL SCALAR CONTAINING  II D1 II
C     DNRM    REAL SCALAR CONTAINING  II D II
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*N
C             CONTAINING   (C1 @D U)  WHERE  (C1@DC2)=C*Q1*FMAT*P2
C               T          (     0)     FMAT AND P2 MAY BE THE IDENTITY
C             Q3 *C2*P3=(U)
C                       (0)
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     RANKC2  INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX C2
C     D()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING    T
C                         Q3 *(-F-C1*DY1)
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE VALUES OF THE RESIDUALS
C     P3()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION N-RANKA
C             REPRESENTING PERMUTATION MATRIX P3
C     D2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q2 (IF IT IS HAS BEEN USED)
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING INDECES OF THE CONSTRAINTS IN CURRENT
C             WORKING SET
C     V()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING ESTIMATES OF LAGRANGE MULTIPLIERS
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION Q
C             CONTAINING INDECES FOR INACTIVE CONSTRAINTS
C     Q       INTEGER SCALAR CONTAINING NUMBER OF INACTIVE CONSTRAINTS
C     P4()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING INFO. TO COMPUTE A*DX FOR INACTIVE CONSTRAINTS
C     TIME    INTEGER SCALAR CONTAINING =2 IF NO DELETION OF
C             CONSTRAINTS HAS BEEN DONE IN CURRENT STEP (I.E. FMAT=I)
C             >2 IF DELETIONS HAVE BEEN DONE
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING MATRIX L FROM          T
C                                       (L@D0)=P1 *A*Q1      AND INFO.
C             TO FORM  Q1
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     P       INTEGER SCALAR CONTAINING NUMBER OF EQUALITY CONSTRAINTS
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     RANKA   INTEGER SCALAR  CONTAINING PSEUDO RANK OF MATRIX L
C     B1NRM   REAL SCALAR CONTAINING  II B1 II
C     HSUM    INTEGER SCALAR CONTAINING SUM OF SQUARED CONSTRAINTS
C             IN CURRENT WORKING SET
C     NOHOUS  INTEGER SCALAR CONTAINING NUMBER OF HOUSEHOLDER
C             TRANSFORMATIONS DONE TO FORM  (L@D0)
C     D1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     P1()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING PERMUTATION MATRIX P1
C     D2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q2 (IF IT HAS BEEN USED)
C     P2()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING PERMUTATION MATRIX P2  (IF IT HAS BEEN USED)
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING     T         OR       T   T
C                          P1 *(-H)           Q2 *P1 *(-H)
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS
C     L       INTEGER SCALAR CONTAINING TOTAL NUMBER OF CONSTRAINTS
C     FMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDF*N
C             CONTAINING A PRODUCT OF GIVENS ROTATION  MATRICES
C     MDF     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY FMAT
C     PIVOT() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     GMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDG*N
C             CONTAINING MATRIX R FROM    T
C                                       Q2 *(L@D0) = (R@D0)
C             AND INFO. TO FORM Q2
C     MDG     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY GMAT
C     FFUNC   SUBROUTINE NAME USED TO EVALUATE THE RESIDUALS
C     HFUNC   SUBROUTINE NAME USED TO EVALUATE THE CONSTRAINTS
C     X()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE CURRENT POINT
C     SEC     LOGICAL SCALAR = TRUE IF THE USER HAS ALLOWED USE OF
C             2@DND DERIVATIVES . =FALSE IF NOT
C     ADD     LOGICAL SCALAR=TRUE IF AT LEAST ONE CONSTRAINT WAS ADDED
C             TO THE WORKING SET IN THE LATEST STEP
C             =FALSE IF NO CONSTRAINTS WERE ADDED IN THE LATEST STEP
C     DEL     LOGICAL SCALAR = TRUE IF SOME CONSTRAINT WAS DELETED
C             FROM THE WORKING SET IN THE CURRENT STEP
C     SCALE   INTEGER SCALAR CONTAINING =0 IF NO SCALING OF MATRIX A
C             HAS BEEN DONE. >0 IF ROW SCALING OF A HAS BEEN DONE
C     DIAG()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             REPRESENTING THE DIAGONAL SCALING MATRIX
C     DX()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE GAUSS-NEWTON SEARCH DIRECTION FOR CURRENT
C             STEP
C     DXNORM  REAL SCALAR CONTAINING  II DX II
C     V1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M+T
C             CONTAINING THE VECTOR   (C*DX)
C                                     (A*DX)
C     EPSREL  REAL SCALAR CONTAINING RELATIVE TERMINATION TOLERANCE
C
C     ON RETURN@D
C
C     VARIABLES FLAGGED WITH * ARE NOT CHANGED IF THE GAUSS-NEWTON
C     SEARCH DIRECTION IS ACCEPTED
C
C     CODE    CONTAINS 1,-1 OR 2 TO INDICATE WHICH METHOD WAS USED
C             TO COMPUTE THE FINAL SEARCH DIRECTION
C  *  D1NRM   CONTAINS  II D1 II   D =(D1)
C  *  DNRM    CONTAINS  II D II       (D2)
C  *  B1NRM   CONTAINS  II B1 II
C  *  DX()    CONTAINS FINAL SEARCH DIRECTION
C  *  DXNORM  CONTAINS  II DX II
C     ERROR   INTEGER SCALAR-CONTAINS = 0 IF NO TROUBLE AT ALL
C             = -4 IF WE ARE NOT ALLOWED TO USE SECOND DERIVATIVES
C             = -5 IF NOT POSITIVE DEF. HESSIAN FROM NEWTON
C             = -9 IF TOO MANY(>5) NEWTON STEPS HAVE BEEN USED
C             = -10 AS USER STOP INDICATOR
C     EVAL    INTEGER SCALAR-CONTAINS NUMBER OF FUNCTION EVALUATION
C             DONE INSIDE THIS ROUTINE
C     BETAK   REAL SCALAR-CONTAINS  II D1 II + II B1 II
C     DIMA    INTEGER SCALAR-CONTAINS
C             = DIMENSION OF SUBSPACE USED WHEN DY1 IS COMPUTED
C               IF SUBSPACE MINIMIZATION IS USED
C             =-T IF THE METHOD OF NEWTON IS USED
C     DIMC2   INTEGER SCALAR-CONTAINS
C             = DIMENSION OF SUBSPACE USED WHEN DY2 IS COMPUTED
C               IF SUBSPACE MINIMIZATION IS USED
C             =-(N-T) IF THE METHOD OF NEWTON IS USED
C
C     WORKING AREAS@D
C
C     V2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C     WORK1() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C
C
C     COMMON VARIABLES CONTAINING INFORMATION CONCERNING PREVIOUS
C     TWO POINTS. THE SUFFICES KM2 AND KM1 IN THE NAMES OF THE
C     VARIABLES REPRESENT TIME STEP K-2 AND K-1
C     THESE VARIABLES ARE UPDATED ONLY INSIDE THE ROUTINE EVREST
C
      INTEGER RKAKM2,RKCKM2,KODKM2,RKAKM1,RKCKM1,KODKM1,TKM2,TKM1
      DOUBLE PRECISION
     *     BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,ALFKM2,
     1 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     2 PGRESS,PRELIN
      COMMON /PREC/ BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,
     1 ALFKM2,RKAKM2,RKCKM2,TKM2,KODKM2,
     2 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     3 RKAKM1,RKCKM1,TKM1,KODKM1,
     4 PGRESS,PRELIN
C
C     COMMON VARIABLES CONTAINING INFORMATION OF RESTART STEPS
C
      DOUBLE PRECISION
     *    BESTRK,BESTPG
      INTEGER NRREST,LATTRY
      COMMON /BACK/ BESTRK,BESTPG, NRREST,LATTRY
C
C     
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER IND
      DOUBLE PRECISION
     *    DNRM2
C
C     COMPUTE  D1APM1 = II D1 II   WHERE D1 CONSISTS OF THE RKCKM1-1
C     FIRST ELEMENTS OF THE VECTOR D  (SEE ABOVE)
C     RKCKM1 = DIMENSION OF SUBSPACE USED TO COMPUTE THE LAST BUT ONE
C     SEARCH DIRECTION.
C     HOWEVER, IF THE CURRENT WORKING SET HAS BEEN CHANGED SINCE THE
C     THE LATEST STEP RKCKM1 MUST BE MODIFIED APPROPRIATELY
C
      IF(RESTAR) GOTO 10
      IND=RKCKM1+TKM1-T
      IND=IND-1
      D1KM2=DNRM2(IND,D,1)
C
C     SET IND= 1 IF DX ON ENTRY IS ACCEPTED
C            =-1 IF SUBSPACE MINIMIZATION SHOULD BE USED
C            = 2 IF METHOD OF NEWTON IS USED
C
   10 CONTINUE
      CALL GNDCHK(B1NRM,D1NRM,DNRM,HSUM,K,RESTAR,D1KM2,ADD,M,N,
     1 DEL,ACTIVE,P,T,V,INACT,Q,H,EPSREL,RANKA,SCALE,DIAG,BETAK,IND)
      EVAL=0
      CODE=IND
      ERROR=0
      IF(IND.NE.1) GOTO 30
C
C     THE GAUSS-NEWTON SEARCH DIRECTION IS ACCEPTED
C
      DIMA=RANKA
      DIMC2=RANKC2
      RETURN
   30 CONTINUE
      IF(IND.EQ.2) GOTO 40
C
C     USE SUBSPACE MINIMIZATION TO RECOMPUTE THE SEARCH DIRECTION
C
      CALL SUBSPC(RESTAR,FSUM,C,MDC,M,N,RANKC2,F,P3,D3,
     1 A,MDA,T,RANKA,HSUM,P1,D2,P2,
     2 B,FMAT,MDF,PIVOT,GMAT,MDG,D,DX,WORK1,DIMA,DIMC2     )
      NRREST=NRREST+1
C
C     COMPUTE THE SEARCH DIRECTION BY USING DIMA COLUMNS OF MATRIX R
C     AND DIMC2 COLUMNS OF MATRIX U
C
      CALL SUBDIR(TIME,A,MDA,T,N,D1,P1,DIMA,RANKA,NOHOUS,B,FMAT,MDF,
     1 C,MDC,M,F,PIVOT,GMAT,MDG,D2,P2,P3,D3,DIMC2,INACT,Q,P4,RANKC2,
     2 CODE,SCALE,DIAG,D,DX,V1,D1NRM,DNRM,B1NRM,WORK1 )
      IF((DIMA.EQ.RANKA).AND.(DIMC2.EQ.RANKC2)) CODE=1
      GOTO 70
   40 CONTINUE
C
C     USE 2@DND DERIVATIVES IF WE ARE ALLOWED TO
C
      IF(SEC) GOTO 50
      ERROR=-4
      GOTO 70
   50 CONTINUE
      IF(KODKM1.NE.2) NRREST=0
      NRREST=NRREST+1
C
C     COMPUTE THE SEARCH DIRECTION BY USING THE METHOD OF NEWTON
C
      CALL NEWTON(FFUNC,HFUNC,X,N,C,MDC,M,RANKC2,F,P3,D3,V,A,MDA,
     1 ACTIVE,T,RANKA,D1,P1,P2,D2,B,H,L,MDF,PIVOT,GMAT,MDG,
     2 DX,EVAL,ERROR,FMAT,D,V1,V2                     )
      DIMA=-T
      DIMC2=-N+T
      IF(NRREST.GT.5) ERROR=-9
   70 CONTINUE
      DXNORM=DNRM2(N,DX,1)
      RETURN
      END
CSUBDIR
      SUBROUTINE SUBDIR(TIME,A,MDA,T,N,D1,P1,DIMA,RANKA,NOHOUS,B,
     1 FMAT,MDF,C,MDC,M,F,PIVOT,GMAT,MDG,D2,P2,P3,D3,DIMC2,INACT,Q,P4,
     2 RANKC2,CODE,SCALE,DIAG,D,DX,V1,D1NRM,DNRM,B1NRM,
     3 WORK)
      INTEGER TIME,MDA,T,N,DIMA,RANKA,NOHOUS,MDF,MDC,M,MDG,Q,
     1 DIMC2,RANKC2,CODE,SCALE
      INTEGER P1(1),P2(1),P3(1),INACT(1),P4(1)
      DOUBLE PRECISION
     *     D1NRM,DNRM,B1NRM
      DOUBLE PRECISION
     *     A(MDA,N),D1(1),B(1),FMAT(MDF,N),C(MDC,N),F(M),PIVOT(1),
     1 GMAT(MDG,N),D2(1),D3(1),DIAG(1),D(M),DX(N),V1(1),WORK(N)
C
C     COMPUTE A SEARCH DIRECTION (DX) BY SOLVING, FOR DY1, EITHER
C     THE SYSTEM L*DY1 = B   (1)   OR THE SYSTEM  R*DY1 = B1  (2)
C     USING DIMA ROWS OR COLUMNS OF THE MATRICES L AND R
C     RESPECTIVELY
C                  L IS RANKA*RANKA LOWER TRIANGULAR
C                  R IS RANKA*RANKA UPPER TRIANGULAR
C             T                  T
C     (L@D0)=P1 *A*Q1*FMAT    B=P1 *(-H)
C             T                   T
C     (R@D0)=Q2 *(L@D0)*P2     B1=Q2 *B
C
C     AND THE MATRIX A IS THE ORIGINAL JACOBIAN CORRESPONDING
C     TO THE CONSTRAINTS IN CURRENT WORKING SET
C     THEN THE SYSTEM           T
C                      U*DY2 =Q3 *(-F-C1*DY1)
C     IS SOLVED FOR DY2 (USING DIMC2 COLUMNS OF MATRIX U)
C     WHERE   (C1@DC2) = C*Q1*FMAT*P2
C
C             (U)     T
C             (0) = Q3 *C2*P3
C
C     AND THE MATRIX C IS THE ORIGINAL JACOBIAN OF THE RESIDUALS.
C     FINALY THE SEARCH DIRECTION IS COMPUTED BY FORMING
C     DX @D= Q1*FMAT*P2*(DY1)
C                      (P3*DY2)
C
C     ON ENTRY@D
C
C     TIME    INTEGER SCALAR CONTAINING =2 IF DELETION FROM CURRENT
C             WORKING SET HAS NOT BEEN DONE (I.E.FMAT=I)
C             >2 IF AT LEAST ONE CONSTRAINT HAS BEEN DELETED
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING MATRIX L AND INFO. TO FORM Q1 (SEE ABOVE)
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     D1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     P1()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING PERMUTATION MATRIX P1
C     DIMA    INTEGER SCALAR CONTAINING NUMBER OF COLUMNS OF MATRIX
C             R THAT SHOULD BE USED WHEN R*DY1=B1 IS SOLVED
C     RANKA   INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX A
C     NOHOUS  INTEGER SCALAR CONTAINING NUMBER OF HOUSEHOLDER
C             TRANSFORMATIONS USED TO FORM L IN  (L@D0)
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING   T        OR    T   T
C                        P1 *(-H)       Q2 *P1 *(-H)
C     FMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDF*N
C             CONTAINING A PRODUCT OF GIVENS ROTATION MATRICES
C             IF TIME>2. FMAT IS UNDEFINED IF TIME=2
C     MDF     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY FMAT
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*N
C             CONTAINING   (C1@DU)    (SEE ABOVE)  AND INFO. TO FORM Q3
C                          (   0)
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE VALUE OF THE RESIDUALS
C     PIVOT() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     GMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDG*N
C             CONTAINING MATRIX R AND INFO. TO FORM Q2 (SEE ABOVE)
C             IF CODE<>1. GMAT IS UNDEFINED IF CODE=1
C     MDG     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY GMAT
C     D2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q2 (IF IT IS USED)
C     P2()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING PERMUTATION MATRIX P2 (IF IT IS USED)
C     P3()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION N-RANKA
C             REPRESENTING PERMUTATION MATRIX P3
C     D3()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKC2
C             CONTAINING INFO. TO FORM Q3
C     DIMC2   INTEGER SCALAR CONTAINING NUMBER OF COLUMNS OF MATRIX
C             U THAT SHOULD BE USED TO SOLVE  U*DY2 = D
C             WHERE D=(D1)    T
C                     (D2)= Q3 *(-F-C1*DY1)
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION Q
C             CONTAINING INDECES FOR THE INACTIVE CONSTRAINTS
C     Q       INTEGER SCALAR CONTAINING NO. INACTIVE CONSTRAINTS
C     P4()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING INFO. TO COMPUTE A*DX FOR INACTIVE CONSTRAINTS
C     RANKC2  INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX C2
C     CODE    INTEGER SCALAR CONTAINING
C             = 1 IF  L*DY1 = B   SHOULD BE SOLVED FOR DY1
C             =-1 IF  R*DY1 = B1  SHOULD BE SOLVED FOR DY1
C     SCALE   INTEGER SCALAR =0 IF NO ROW SCALING OF MATRIX A HAS
C             BEEN DONE. >1 IF SCALING OF A HAS BEEN DONE
C     DIAG()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             REPRESENTING THE SCALING MATRIX IF IT HAS BEEN USED
C
C     ON RETURN@D
C
C     D()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINS      T
C                         Q3 *(-F-C1*DY1)
C     DX()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINS THE COMPUTED SEARCH DIRECTION
C     V1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M+T
C             CONTAINS THE COMPOUND VECTOR   (C*DX)
C                                            (A*DX)
C     D1NRM   REAL SCALAR-CONTAINS  II D1 II   (SEE ABOVE)
C     DNRM    REAL SCALAR-CONTAINS  II D II
C     B1NRM   REAL SCALAR-CONTAINS  II B1 II WHERE B1 CONTAINS
C             THE FIRST DIMA ELEMENTS OF B OR B1  (SEE ABOVE)
C
C     WORKING AREAS@D
C
C     WORK()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C
C     INTERNAL VARIABLES
C
      INTEGER I,I2,I3,K,NMT,J,NO,NOELEM
      DOUBLE PRECISION
     *     AITDX,DNRM2
*      write(10,*) 'In SUBDIR: code= ',code
      B1NRM=0.0D0
      IF(T.LE.0) GOTO 20
      DO 10 I=1,T
           DX(I)=B(I)
   10 CONTINUE
      B1NRM=DNRM2(DIMA,DX,1)
*      write(10,*) 'B1NRM= ',b1nrm
C
C     COMPUTE THE VECTOR AHAT*DX
C
      CALL ADX(CODE,GMAT,MDG,RANKA,DIMA,P1,D2,DX,T,NOHOUS,SCALE,DIAG,
     1 V1(M+1),WORK)
C
C     SOLVE FOR DY1 ONE OF THE STYSTEMS
C     L*DY1 = B       R*DY1 = B1
C
      IF(CODE.EQ.1) CALL LSOLVE(MDA,T,A,DX)
      IF(CODE.NE.1) CALL USOLVE(MDG,DIMA,GMAT,DX)
   20 CONTINUE
      DO 30 I=1,M
           D(I)=-F(I)
   30 CONTINUE
C
C     COMPUTE D@D=D-C1*DY1
C
      CALL YCOMP(DIMA,M,D,C,MDC,DX)
      DNRM=DNRM2(M,D,1)
*      write(10,*) 'DNRM (D-C1*DT1)= ', dnrm
C                    T
C     COMPUTE   D@D=Q3 *D
C
*      write(10,*) 'RANKC2= ',rankc2
      IF(RANKC2.LE.0) GOTO 50
      DO 40 I=1,RANKC2
           K=RANKA+I
           CALL H12PER(2,I,I+1,M,C(1,K),1,D3(I),D,1,M,1,C(I,K))
   40 CONTINUE
   50 CONTINUE
      D1NRM=DNRM2(DIMC2,D,1)
C
C     COMPUTE THE VECTOR C*DX
C
      K=RANKA+1
      NMT=N-RANKA
      CALL CDX(C,MDC,M,DIMA,DX,C(1,K),RANKC2,DIMC2,D3,D,V1)
      IF(NMT.LE.0) GOTO 80
      DO 60 I=1,NMT
           J=RANKA+I
           DX(J)=D(I)
   60 CONTINUE
C
C     SOLVE FOR DY2 THE SYSTEM  U*DY2 = D1
C
      CALL USOLVE(MDC,DIMC2,C(1,K),DX(K))
C
C     DO BACK TRANSFORMATIONS TO FORM
C     DX@D= Q1*FMAT*P2*(DY1)
C                     (P3*DY2)
C
      IF(DIMC2.EQ.NMT) GOTO 80
      K=DIMC2+1
      DO 70  I=K,NMT
           J=RANKA+I
           DX(J)=0.0D0
   70 CONTINUE
   80 CONTINUE
C
C     COMPUTE  DY2 @D= P3*DY2
C
      CALL PV(P3,NMT,DX(RANKA+1),N,1)
      IF(CODE.EQ.1) GOTO 100
C
C     COMPUTE DX @D= P2*DX
C
      CALL PV(P2,RANKA,DX,N,1)
  100 CONTINUE
      IF(TIME.LE.2) GOTO 110
      IF((TIME.EQ.3).AND.(T.EQ.0)) GOTO 110
C
C     COMPUTE DX @D= FMAT*DX
C
      CALL HXCOMP(FMAT,MDF,N,DX,WORK)
  110 CONTINUE
C
C     COMPUTE A*DX FOR THE CONSTRAINT WHICH HAS BEEN DELETED AT
C     THE CURRENT POINT
C
      NO=NOHOUS-T
      IF(NO.LE.0) GOTO 140
           IROW=T+1
           I2=INACT(Q)
           NOELEM=P4(I2)
           AITDX=0.0D0
           DO 120 J=1,NOELEM
                AITDX=AITDX+A(IROW,J)*DX(J)
  120      CONTINUE
           I3=M+Q+T
           V1(I3)=AITDX
           IF(SCALE.NE.0) V1(I3)=V1(I3)/DIAG(IROW)
  140 CONTINUE
      IF(NOHOUS.EQ.0) RETURN
C
C     COMPUTE DX @D= Q1*DX
C
      DO 160 I=1,NOHOUS
           K=NOHOUS-I+1
           CALL H12PER(2,K,K+1,N,A(K,1),MDA,D1(K),DX,1,MDA,1,PIVOT(K))
  160 CONTINUE
      RETURN
      END
CUPBND
      SUBROUTINE UPBND(A,MDA,Q,NH,T,N,H,INACT,P4,V1,M,DX,ALFUPP,IND)
      INTEGER MDA,Q,NH,T,N,M,IND
      INTEGER INACT(1),P4(1)
      DOUBLE PRECISION
     *     ALFUPP
      DOUBLE PRECISION
     *     A(MDA,N),H(1),V1(1),DX(N)
C
C     DETERMINE THE UPPER BOUND OF THE STEPLENGTH
C     I.E.  THE SMALLEST OF   -H (X)/A (X)*DX
C                               I     I
C     S.T. A (X)*DX < 0
C           I
C
C     WHERE I BELONGS TO THE INACTIVE SET
C     IF A (X)*DX < 0 FOR NO INDEX I THEN ALFUPP IS SET TO A LARGE VALUE
C         I
C
C     ON ENTRY@D
C
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING THE Q GRADIENTS CORRESPONDING TO THE INACTIVE
C             CONSTRAINTS
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     Q       INTEGER SCALAR CONTAINING NO. INACTIVE CONSTRAINTS
C     NH      INTEGER SCALAR CONTAINING NUMBER OF HOUSEHOLDER
C             TRANSFORMATIONS DONE TO FORM      T
C                                      (L@D0) =P1 *A*Q1
C     T       INTEGER SCALAR CONTAINING NO. CONSTRAINTS IN WORKING SET
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUES OF THE CONSTRAINTS
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION Q
C             CONTAINING INDECES FOR THE INACTIVE CONSTRAINTS
C     P4()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             REPRESENTING THE REORDERING OF CONSTRAINT GRADIENTS
C             DUE TO THE WORKING SET SUCH THAT P4(I) POINTS TO THE
C             ROW IN ARRAY A WHERE GRADENT NUMBER I IS MOVED
C     V1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M+L
C             CONTAINING THE COMPOUND MATRIX  (C*DX   )
C             AS M+T FIRST ELEMENTS           (AHAT*DX)
C     M       INTEGER SCALAR CONTAINING NO. OF RESIDUALS
C     DX()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE SEARCH DIRECTION
C
C     ON RETURN@D
C
C     V1()    NOW CONTAINS THE AUGMENTED COMPOUND MATRIX (C*DX   )
C                                                        (A*DX   )
C     ALFUPP  REAL SCALAR-CONTAINS THE UPPER BOUND (SEE ABOVE)
C     IND     INTEGER SCALAR  = 0 IF NO CONSTRAINT DEFINES ALFUPP
C             = INDEX FOR THE CONSTRAINT THAT DEFINES THE UPPER BOUND
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K,IR,IP,MPT,L
      DOUBLE PRECISION
     *     ZERO,BIG,AITDX,ALF
      DATA ZERO,BIG /0.0D0,1.0D6/
      ALFUPP=BIG
      IND=0
      MPT=M+T
      L=Q-NH+T
      IF(Q.LE.0) GOTO 50
      DO 40 I=1,Q
           K=INACT(I)
           IP=MPT+I
           IR=P4(K)
           IF(I.GT.L) GOTO 20
           AITDX=0.0D0
           DO 10 J=1,N
                AITDX=AITDX+A(IR,J)*DX(J)
   10      CONTINUE
           V1(IP)=AITDX
           GOTO 30
   20      CONTINUE
           AITDX=V1(IP)
   30      CONTINUE
           IF(AITDX.GE.ZERO) GOTO 40
           IF(H(K).LE. ZERO) GOTO 40
           ALF=-H(K)/AITDX
           IF(ALF.GT.ALFUPP) GOTO 40
           ALFUPP=ALF
           IND=K
   40 CONTINUE
   50 CONTINUE
      ALFUPP=DMIN1(ALFUPP,3.0D0)
      RETURN
      END
CEVADD
      SUBROUTINE EVADD(H,ACTIVE,T,BND,P,INACT,Q,IND,ITNO,ADD)
      INTEGER T,Q,BND,P,IND,ITNO
      INTEGER ACTIVE(1),INACT(1)
      DOUBLE PRECISION
     *     H(1)
      LOGICAL ADD
C
C     MOVE VIOLATED CONSTRAINTS TO THE WORKING SET
C
C     ON ENTRY@D
C
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING INDECES FOR THE CONSTRAINTS IN CURRENT
C             WORKING SET
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     BND     INTEGER SCALAR CONTAINING MIN(L,N)
C     P       INTEGER SCALAR CONTAINING NUMBER OF EQUALITY CONSTRAINTS
C     INACT() INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION Q
C             CONTAINING INDECES FOR THE INACTIVE CONSTRAINTS
C     Q       INTEGER SCALAR CONTAING NUMBER OF INACTIVE CONSTRAINTS
C     IND     INTEGER SCALAR CONTAINING = 0 IF THE LATEST STEPLENGTH
C             IS LESS THAN THE UPPER BOUND
C             = INDEX FOR THE CONSTRAINT THAT DEFINES THE UPPER BOUND
C     ITNO    INTEGER SCALAR CONTAINING THE ITERATION NUMBER
C
C     ON RETURN@D
C
C     ADD     LOGICAL SCALAR = FALSE IF NO CONSTRAINT IS ADDED
C             = TRUE IF ANY CONSTRAINT IS ADDED TO THE WORKING SET
C
C     IF ADD=TRUE ON RETURN THE ARRAYS ACTIVE AND INACT ARE UPDATED
C     AS WELL AS THE SCALARS T AND Q
C
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K,jj,kk,kind
      DOUBLE PRECISION
     *     EPS,DELTA,hmax
      DATA DELTA /0.1D0/
      eps=sqrt(drelpr)
      I=1
   10 CONTINUE
           IF(I.GT.Q) RETURN
           K=INACT(I)
           IF(H(K).LT.EPS) GOTO 15
           IF(.NOT.((K.EQ.IND).AND.(H(K).LT.DELTA))) GOTO 20
   15      CONTINUE
	   kind=0
           IF(T.GE.BND) then
	    kk=0
	    kind=1
	    hmax=0.0d0
	    do 17 j=1,t
	     jj=active(j)
*     write(10,*) 'h(jj)=' ,h(jj),' jj= ',jj
	     if(h(jj).gt.hmax)then
	      hmax=h(jj)
	      kk=j
             endif
   17       continue
	    if(kk.eq.0)then
	     hmax=100.0d0
	     do 18 j=1,t
	      jj=active(j)
	      if(abs(h(jj)).lt.hmax)then
	       hmax=abs(h(jj))
	       kk=j
              endif
   18        continue
	    endif
*     write(10,*) 'Deleted constraint h(kk)=  ',kk
	    call delete(active,inact,q,t,kk)
           endif
*     write(10,*) 'Added constraint: ',k 
           CALL ADDIT(ACTIVE,INACT,T,Q,I)
           J=BND+K-P
           IF(-1.EQ.ACTIVE(J)) ACTIVE(J)=ITNO
           IF(ACTIVE(J).EQ.0) ACTIVE(J)=1
           ADD=.TRUE.
	   if(kind.eq.1)i=q+1
           GOTO 10
   20      CONTINUE
           I=I+1
      GOTO 10
      END
CSCALV
      SUBROUTINE SCALV(V,FACTOR,N)
      INTEGER N
      DOUBLE PRECISION
     *     FACTOR,V(1)
C
C     FORM THE NEW CONTENTS OF THE VECTOR V AS
C            V(I)=1/FACTOR*V(I)  I=1,2,......,N
C
C     INTERNAL VARIABLE
C
      INTEGER I
      IF(N.LE.0) RETURN
      DO 10 I=1,N
           V(I)=V(I)/FACTOR
   10 CONTINUE
      RETURN
      END
CEVREST
      SUBROUTINE EVREST(X,U,N,M,K,FFUNC,FUNCEV,F,D1NRM,DNRM,FSUM,
     1 DIMC2,CODE,DXNORM,BETAK,ALPHA,ALFLOW,ACTIVE,H,L,T,
     2 HFUNC,B1NRM,HSUM,DIMA,ERROR,RESTAR  )
      INTEGER N,M,K,FUNCEV,DIMC2,CODE,L,T,DIMA,ERROR
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     D1NRM,DNRM,FSUM,DXNORM,BETAK,ALPHA,ALFLOW,B1NRM,HSUM
      DOUBLE PRECISION
     *     X(N),U(N),F(M),H(1)
      LOGICAL RESTAR
C
C     IF CURRENT STEP IS A FAILURE AND SUBSPACE MINIMIZATION WAS
C     USED WE RESTART AT THE PREVIOUS POINT.
c     We also restart at the previous point if the Newton method fails.
C
C     ON ENTRY@D
C
C     X()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE LATEST POINT
C     U()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE PREVIOUS POINT
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     K       INTEGER SCALAR CONTAINING ITERATION NUMBER
C     FFUNC   SUBROUTINE NAME-USED TO EVALUATE THE RESIDUALS
C     FUNCEV  INTEGER SCALAR CONTAINING TOTAL NUMBER OF FUNCTION
C             EVALUATIONS DONE SO FAR
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE VALUE OF THE RESIDUALS AT X
C     D1NRM   REAL SCALAR CONTAINING  II D1 II
C     DNRM    REAL SCALAR CONTAINING  II D II
C     FSUM    REAL SCALAR CONTAINING SUM OF SQUARED RESIDUALS AT U
C     DIMC2   INTEGER SCALAR CONTAINING NUMBER OF COLUMNS OF MATRIX
C             U USED WHEN   U*DY2 = D   IS SOLVED
C     CODE    INTEGER SCALAR CONTAINING
C             = 1 IF GAUSS-NEWTON SEARCH DIRECTION
C             =-1 IF SUBSPACE MINIMIZATION SEARCH DIRECTION
C             = 2 IF NEWTON SEARCH DIRECTION
C     DXNORM  REAL SCALAR CONTAINING NORM OF SEARCH DIRECTION
C     BETAK   REAL SCALAR CONTAINING  II D1 II + II B1 II
C     ALPHA   REAL SCALAR CONTAINING THE LATEST STEPLENGTH
C     ALFLOW  REAL SCALAR CONTAINING LOWER BOUND OF STEPLENGTH
C             USED IN LATEST STEP
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING INDECES FOR CONSTRAINTS IN CURRENT WORKING SET
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS AT X
C     L       INTEGER SCALAR CONTAINING TOTAL NUMBER OF CONSTRAINTS
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     HFUNC   SUBROUTINE NAME-USED TO EVALUATE THE CONSTRAINTS
C     B1NRM   REAL SCALAR CONTAINING  II B1 II
C     HSUM    REAL SCALAR CONTAINING SUM OF SQUARED CONSTRAINTS AT U
C     DIMA    INTEGER SCALAR CONTAINING NUMBER OF COLUMNS OF MATRIX R
C             USED WHEN   R*DY1 = B1  IS SOLVED
C     ERROR   INTEGER SCALAR CONTAINING
C             = 0 IF EVERY THING SEEMS OK
C             =-1 IF DX WAS NOT A DESCENT DIRECTION
C             =-2 IF ALPHA*II DX II IS SMALL
C             =-3 IF NOT POS. DEF. HESSIAN MATRIX IN NEWTON
C             =-4 IF NOT ALLOWED TO USE 2@DND DERIVATIVES
C
C     ON RETURN@D
C
C     RESTAR  = TRUE IF A RESTART IS SUGGESTED
C             = FALSE IF NO RESTART IS SUGGESTED
C     FSUM    CONTAINS SUM OF SQUARED RESIDUALS AT THE NEW POINT
C     HSUM    CONTAINS SUM OF SQUARED CONSTRAINTS IN CURRENT WORKING
C             SET AT THE NEW POINT
C     ERROR   < -10 TO INDICATE A POSSIBLE USER STOP
c             =-5 if Newton has failed
C
C     IF RESTAR=FALSE ON RETURN MANY COMMON VARIABLES ARE UPDATED
C     TO REPRESENT THE CORRECT HISTORY
C     IF RESTAR=TRUE ON RETURN THE FOLLOWING VARIABLES HAVE BEEN
C     CHANGED
C
C     X()     CONTAINS THE PREVIOUS POINT U
C     FUNCEV  INCREACED BY 1
C     F()     CONTAINS THE VALUE OF THE RESIDUALS AT PREVIOUS POINT U
C     H()     CONTAINS THE VALUE OF THE CONSTRAINTS AT PREVIOUS POINT U
C
C
C     COMMON VARIABLES CONTAINING INFORMATION CONCERNING PREVIOUS
C     TWO POINTS. THE SUFFICES KM2 AND KM1 IN THE NAMES OF THE
C     VARIABLES REPRESENT TIME STEP K-2 AND K-1
C     THESE VARIABLES ARE UPDATED ONLY INSIDE THE ROUTINE EVREST
C
      INTEGER RKAKM2,RKCKM2,KODKM2,RKAKM1,RKCKM1,KODKM1,TKM2,TKM1
      DOUBLE PRECISION
     *     BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,ALFKM2,
     1 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     2 PGRESS,PRELIN
      COMMON /PREC/ BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,
     1 ALFKM2,RKAKM2,RKCKM2,TKM2,KODKM2,
     2 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     3 RKAKM1,RKCKM1,TKM1,KODKM1,
     4 PGRESS,PRELIN
C
C     COMMON VARIABLES CONTAINING INFORMATION OF RESTART STEPS
C
      DOUBLE PRECISION
     *    BESTRK,BESTPG
      INTEGER NRREST,LATTRY
      COMMON /BACK/ BESTRK,BESTPG, NRREST,LATTRY
c
c     common for fixing Newton failures
c
      integer ifree
      common /negdir/ ifree
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER CTRL
      DOUBLE PRECISION
     *     DUMMY,SACTH,DNRM2,succes
      RESTAR=.FALSE.
c
c     Check if the Newton metod failed
c
*      succes=fsum+hsum-(dnrm2(m,f,1)**2+sacth(h,active,t))
*      if((abs(code).eq.2).and.(succes.le.0.0d0)) then
*       write(10,*) 'In EVREST: succes= ',succes
*       ifree=5
*       nrrest=0
*       goto 55
*      endif
C
C     CHECK IF SOMETHING HAS GONE WRONG IN THE LINESEARCH
C     AND POSSIBLY A RESTART IS SUGGESTED
C
      IF((LATTRY.EQ.0).AND.(BESTPG.GT.0.0D0)) GOTO 10
      IF((-1.EQ.ERROR).OR.(ERROR.LE.(-3))) GOTO 10
*      IF((-2.EQ.ERROR).AND.(ALPHA.LE.ALFLOW)) RESTAR=.TRUE.
      if(alpha.le.alflow)then
       restar=.true.
      endif
      IF(RESTAR) GOTO 50
   10 CONTINUE
C
C     NO RESTART UPDATE HISTORY VARIABLES
C
      K=K+1
      IF(CODE.NE.2) NRREST=0
      LATTRY=MAX0(DIMC2,DIMA)
      BETKM2=BETKM1
      D1KM2=D1KM1
      DKM2=DKM1
      FSQKM2=FSQKM1
      B1KM2=B1KM1
      HSQKM2=HSQKM1
      DXNKM2=DXNKM1
      ALFKM2=ALFKM1
      RKAKM2=RKAKM1
      RKCKM2=RKCKM1
      TKM2=TKM1
      KODKM2=KODKM1
      BETKM1=BETAK
      D1KM1=D1NRM
      DKM1=DNRM
      FSQKM1=FSUM
      B1KM1=B1NRM
      HSQKM1=HSUM
      DXNKM1=DXNORM
      ALFKM1=ALPHA
      RKAKM1=DIMA
      RKCKM1=DIMC2
      TKM1=T
      KODKM1=CODE
      IF(-1.EQ.ERROR) GOTO 55
      IF(ERROR.LT.0) RETURN
      HSUM=SACTH(H,ACTIVE,T)
      HSQKM2=HSUM
      FSUM=DNRM2(M,F,1)**2
      RETURN
   50 CONTINUE
C
C     COUNT NUMBER OF RESTARTS AT CURRENT POINT AND SAVE LATEST
C     DIMENSIONS USED TO COMPUTE THE SEARCH DIRECTION
C
      NRREST=NRREST+1
      RKAKM1=DIMA
      RKCKM1=DIMC2
      IF(K.NE.0) GOTO 55
      D1KM1=D1NRM
      B1KM1=B1NRM
   55 CONTINUE
C
C     RESTART FROM PREVIOUS POINT
C
      CALL SAVEXK(U,N,X)
      if(abs(code).eq.2) error=-5
      CTRL=-1
      CALL FFUNC(X,N,F,M,CTRL,DUMMY,1)
      IF(CTRL.LT.(-10)) ERROR=CTRL
      CTRL=-1
      CALL HFUNC(X,N,H,L,CTRL,DUMMY,1)
      IF(CTRL.LT.(-10)) ERROR=CTRL
      ALPHA=ALFKM1
      FUNCEV=FUNCEV+1
      RETURN
      END
COUTPUT
      SUBROUTINE OUTPUT(IPRINT,K,UNIT,GRES,W,ACTIVE,
     1 SPEED)
      INTEGER IPRINT,K,UNIT
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     GRES,SPEED
      DOUBLE PRECISION
     *     W(1)
C
C     IF IPRINT>0
C       THEN WRITE SOME INFO. EVERY IPRINT STEP ON UNIT
C       ELSE NO PRINTING IS DONE
C
C     ON ENTRY@D
C
C     IPRINT  INTEGER SCALAR CONTAINING PRINTING STEPSIZE
C     K       INTEGER SCALAR CONTAINING ITERATION NUMBER
C     UNIT    INTEGER SCALAR CONTAINING LOGICAL UNIT NUMBER FOR
C             OUTPUT FILE
C                                         T
C     GRES    REAL SCALAR CONTAINING  II A *V-G II
C     W()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING PENALTY WEIGHTS FOR CONSTRAINTS
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING INDECES FOR CONSTRAINTS IN CURRENT WORKING SET
C
C     ON RETURN@D
C
C     SPEED   REAL SCALAR-CONTAINS AN ESTIMATE OF THE CONVERGENCE
C             FACTOR
C
C
C     COMMON VARIABLES CONTAINING INFORMATION CONCERNING PREVIOUS
C     TWO POINTS. THE SUFFICES KM2 AND KM1 IN THE NAMES OF THE
C     VARIABLES REPRESENT TIME STEP K-2 AND K-1
C     THESE VARIABLES ARE UPDATED ONLY INSIDE THE ROUTINE EVREST
C
      INTEGER RKAKM2,RKCKM2,KODKM2,RKAKM1,RKCKM1,KODKM1,TKM2,TKM1
      DOUBLE PRECISION
     *     BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,ALFKM2,
     1 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     2 PGRESS,PRELIN
      COMMON /PREC/ BETKM2,D1KM2,DKM2,FSQKM2,HSQKM2,B1KM2,DXNKM2,
     1 ALFKM2,RKAKM2,RKCKM2,TKM2,KODKM2,
     2 BETKM1,D1KM1,DKM1,FSQKM1,HSQKM1,B1KM1,DXNKM1,ALFKM1,
     3 RKAKM1,RKCKM1,TKM1,KODKM1,
     4 PGRESS,PRELIN
C
C     COMMON VARIABLES CONTAINING INFORMATION OF RESTART STEPS
C
      DOUBLE PRECISION
     *    BESTRK,BESTPG
      INTEGER NRREST,LATTRY
      COMMON /BACK/ BESTRK,BESTPG, NRREST,LATTRY
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER ITNO,I,J
      DOUBLE PRECISION
     *     WMAX
      IF(IPRINT.LE.0) RETURN
      ITNO=K-1
      IF((ITNO/IPRINT*IPRINT).NE.ITNO) RETURN
      SPEED=0.0D0
      IF(ITNO.NE.0) SPEED=BETKM1/BETKM2
      WMAX=0.0D0
      IF(TKM1.LE.0) GOTO 20
      DO 10 I=1,TKM1
        J=ACTIVE(I)
        IF(W(J).GT.WMAX) WMAX=W(J)
   10 CONTINUE
   20 CONTINUE
      IF(ITNO.EQ.0) WRITE(UNIT,1000)
      IF(TKM1.GT.0) WRITE(UNIT,1010) ITNO,FSQKM1,HSQKM1,GRES,DXNKM1,
     1RKAKM1,RKCKM1,ALFKM1,SPEED,WMAX,PRELIN,PGRESS,(ACTIVE(I),I=1,TKM1)
      IF(TKM1.LE.0) WRITE(UNIT,1010) ITNO,FSQKM1,HSQKM1,GRES,DXNKM1,
     1 RKAKM1,RKCKM1,ALFKM1,SPEED,WMAX,PRELIN,PGRESS
      RETURN
 1000 FORMAT(////10X,41HCOLLECTED INFORMATION FOR ITERATION STEPS
     1 //5H   K ,11H  FSUM(K)  ,11H  HSUM(K)  ,10H  LAGRES  ,
     2 10H  DXNORM  ,5HKODA ,4HKODC,10H   ALPHA  ,10HCONV.SPEED,
     3 10H  MAX(W)  ,10H PREDICTED,10H REDUCTION,12H WORKING SET )
 1010 FORMAT(I4,2E11.3,2E10.3,I4,I5,5E10.3,1X,6I3/(105X,6I3))
      END
CADX
      SUBROUTINE ADX(CODE,GMAT,MDG,RANKA,DIMA,P1,D2,B,T,NOHOUS,SCALE,
     1 DIAG,HPRIM,W)
      INTEGER CODE,MDG,RANKA,DIMA,T,NOHOUS,SCALE
      INTEGER P1(1)
      DOUBLE PRECISION
     *     GMAT(MDG,1),D2(1),B(1),DIAG(1),HPRIM(1),W(1)
C                                 -1
C     COMPUTE HPRIM@D= AHAT*DX=DIAG  *P1*Q2*(B1)
C                                          ( 0)
C
C     IF CODE=1 THEN      -1
C             AHAT*DX=DIAG  *P1*B
C               ELSE      -1
C             AHAT*DX=DIAG  *P1*Q2*(B1)    WHERE B1 IS THE FIRST DIMA
C                                  ( 0)    ELEMENTS OF B
C
C     ON ENTRY@D
C
C     CODE    INTEGER SCALAR CONTAINING
C             = 1 IF GAUSS-NEWTON SEARCH DIRECTION
C             =-1 IF SUBSPACE MINIMIZATION
C             = 2 IF NEWTON SEARCH DIRECTION
C     GMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDG*N
C             CONTAINING INFO. TO FORM Q2 (IF IT IS USED)
C     MDG     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY GMAT
C     RANKA   INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX A
C     DIMA    INTEGER SCALAR CONTAINING NUMBER OF ELEMENTS IN B THAT
C             SHOULD BE CONSIDDERED AS NON ZERO
C     P1()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             REPRESENTING PERMUTATION MATRIX P1
C     D2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q2  (IF IT IS USED)
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING    T   T
C                         Q2 *P1 *(-H)
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     NOHOUS  INTEGER SCALAR CONTAINING NO. OF HOUSEHOLDER
C             TRANSFORMATIONS DONE TO FORM (L@D0)
C     SCALE   INTEGER SCALAR CONTAINING =0 IF NO ROW SCALING OF
C             MATRIX A HAS BEEN DONE. >0 IF SCALING HAS BEEN DONE
C     DIAG()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             REPRESENTING THE DIAGONAL SCALING MATRIX (IF IT IS USED)
C
C     ON RETURN@D
C
C     HPRIM() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINS AHAT*DX COMPUTED IN ONE OF THE TWO WAYS
C             INDICATED ABOVE
C
C     WORKING AREAS@D
C
C     W()     SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C
C     INTERNAL VARIABLES
C
      INTEGER I,K
      IF(DIMA.EQ.T) GOTO 20
      K=DIMA+1
      DO 10 I=K,T
           B(I)=0.0D0
   10 CONTINUE
   20 CONTINUE
      DO 30 I=1,T
           HPRIM(I)=B(I)
   30 CONTINUE
      IF(CODE.EQ.1) GOTO 50
C
C     COMPUTE  HPRIM@D=Q2*(B1)
C                        ( 0)
C
      DO 40 I=1,RANKA
           K=RANKA+1-I
           CALL H12PER(2,K,K+1,T,GMAT(1,K),1,D2(K),HPRIM,1,T,1,
     1      GMAT(K,K))
   40 CONTINUE
   50 CONTINUE
C
C     COMPUTE  HPRIM@D=P1*HPRIM
C
      IF(T.LT.NOHOUS) GOTO 60
      CALL PV(P1,T,HPRIM,T,1)
      GOTO 80
   60 CONTINUE
      CALL PSPECF(T,P1,HPRIM,W)
      DO 70 I=1,T
        HPRIM(I)=W(I)
   70 CONTINUE
   80 CONTINUE
      IF(SCALE.LE.0) RETURN
C                         -1
C     COMPUTE  HPRIM@D=DIAG  *HPRIM
C
      DO 90 I=1,T
           HPRIM(I)=HPRIM(I)/DIAG(I)
   90 CONTINUE
      RETURN
      END
CLTOUP
      SUBROUTINE LTOUP(A,MDA,RANKA,T,B,MDG,P2,GMAT,D2)
      INTEGER MDA,RANKA,T,MDG
      INTEGER P2(1)
      DOUBLE PRECISION
     *     A(MDA,1),B(1),GMAT(MDG,1),D2(1)
C
C     TRANSFORM  (L@D0) TO UPPER TRIANGULAR FORM  (R@D0)
C     BY FORMING           T
C               (R@D0) =  Q2 *(L@D0)*P2
C     LATER ON THE SYSTEM                 T
C     (L@D0)*X=B   WILL BE SOLVED SO  B@D=Q2 *B
C
C     ON ENTRY@D
C
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING MATRIX L AND INFO. TO FORM MATRIX Q1
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     RANKA   INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX A
C     T       INTEGER SCALAR CONTAINING NO. OF PARAMETERS
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING   T
C                        P1 *(-H)
C     MDG     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY GMAT
C
C     ON RETURN@D
C                        T
C     B()     CONTAINS Q2 *B
C     P2()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINS A REPRESENTATION OF PERMUTATION MATRIX P2
C     GMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDG*N
C             CONTAINS THE MATRIX R AND INFO. TO FORM Q2
C     D2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINS INFO. TO FORM MATRIX Q2
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,CMAX
      DOUBLE PRECISION
     *     COLLNG
      CALL PERMIN(P2,RANKA)
C
C     MOVE MATRIX L TO ARRAY GMAT
C
      DO 20 I=1,T
           DO 10 J=1,RANKA
                IF(I.LT.J) GMAT(I,J)=0.0D0
                IF(I.GE.J) GMAT(I,J)=A(I,J)
   10      CONTINUE
   20 CONTINUE
C
C     TRANSFORM L TO UPPER TRIANGULAR FORM
C
      DO 30 I=1,RANKA
C
C     FIND LONGEST COLUMN AND PERMUTE IF NECESSARY
C
           CALL COLMAX(T,RANKA,GMAT,MDG,I,I,CMAX,COLLNG)
           P2(I)=CMAX
           CALL PRMCOL(GMAT,MDG,T,I,CMAX)
C
C     CONSTRUCT A REFLECTION AND APPLY FROM THE LEFT ON MATRIX L
C     AND FROM THE LEFT ON VECTOR B
C
           CALL H12PER(1,I,I+1,T,GMAT(1,I),1,D2(I),GMAT(1,I+1),
     1               1,MDG,RANKA-I,GMAT(I,I))
           CALL H12PER(2,I,I+1,T,GMAT(1,I),1,D2(I),B,1,T,1,
     1               GMAT(I,I))
   30 CONTINUE
      RETURN
      END
CSACTH
      DOUBLE PRECISION
     *FUNCTION SACTH(H,ACTIVE,T)
      INTEGER T
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     H(1)
C
C     COMPUTE SACTH=THE SUM OF SQUARED CONSTRAINTS FROM THE CURRENT
C     WORKING SET
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     SUM
      SUM=0.0D0
      IF(T.LE.0) GOTO 20
      DO 10 I=1,T
           J=ACTIVE(I)
           SUM=SUM+H(J)**2
   10 CONTINUE
   20 CONTINUE
      SACTH=SUM
      RETURN
      END
CSAVEXK
      SUBROUTINE SAVEXK(X,N,U)
      INTEGER N
      DOUBLE PRECISION
     *     X(N),U(N)
C
C     STORE X(I) IN U(I)  I=1,2,....,N
C
C     INTERNAL VARIABLE
C
      INTEGER I
      DO 10 I=1,N
           U(I)=X(I)
   10 CONTINUE
      RETURN
      END
CATOLOW
      SUBROUTINE ATOLOW(T,N,P1,A,MDA,TOL,PRANKA,D1,G)
      INTEGER T,N,MDA,PRANKA
      INTEGER P1(1)
      DOUBLE PRECISION
     *     TOL,A(MDA,N),D1(1),G(N)
C
C     THIS ROUTINE TRANSFORMS THE T*N (T<=N) MATRIX A TO LOWER
C     TRIANGULAR                                    ==========
C     FORM BY MULTIPLYING WITH AN ORTHOGONAL MATRIX Q1 AND A PERMUTA-
C     TION MATRIX P1 SO THAT
C                        P1(TR)*A*Q1 = (L@D0)
C     THE PURPOSE IS TO SOLVE FOR V, THE SYSTEM    A(TR)*V = G   (1)
C     THEREFOR THE TRANSFORMATION  G@D= Q1(TR)*G   IS ALSO DONE.
C
C     ON ENTRY
C
C     T    INTEGER SCALAR CONTAINING NO. OF ROWS IN MATRIX A
C          AND LENGTH OF ARRAYS P1,D1
C     N    INTEGER SCALAR CONTAINING NO. OF COLUMNS IN MATRIX A AND
C          LENGTH OF ARRAY G
C     A(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N CONTAINING
C          THE MATRIX A THAT SHALL BE TRIANGULARIZED
C     MDA  INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C          MDA MUST BE >=T
C     TOL  REAL SCALAR CONTAINING A SMALL VALUE USED TO DETERMINE
C          PSEUDO RANK OF MATRIX A
C     G()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N CONTAINING
C          THE GRADIENT OF THE OBJECTIVE FUNCTION AT CURRENT POINT
C          WHICH IS THE RIGHT HAND SIDE OF SYSTEM (1) ABOVE
C
C     ON RETURN
C
C        L IS STORED IN THE LOWER PART OF A
C        THE NORMALS (EXCEPT ONE ELEMENT) THAT MAKES UP THE MATRIX Q1
C        ARE STORED IN THE ROWS OF THE ARRAY A
C        P1 HOLDS THE PERMUTATION ORDER OF ROWS IN MATRIX A
C        D1(I) I=1,2,....,T HOLDS THE MISSING ELEMENT OF A NORMAL
C        PRANKA IS THE PSEUDORANK OF THE MATRIX A (NORMALLY =T) WHEN
C        TOL IS USED AS A SMALL POSITIVE NUMBER
C        G IS SET TO Q1(TR)*G
C
C     INTERNAL VARIABLES
C
      INTEGER I,IMAX,KRANK,LDIAG
      DOUBLE PRECISION
     *     RMAX
      PRANKA=T
      IF(T.EQ.0) RETURN
      LDIAG=MIN0(T,N)
      CALL PERMIN(P1,LDIAG)
      DO 50 I=1,LDIAG
C
C     FIND LONGEST ROW AND DO PERMUTATIONS IF NECESSARY
C
      KRANK=I
      CALL ROWMAX(T,N,A,MDA,I,I,IMAX,RMAX)
      IF(RMAX.LT.TOL) GOTO 60
      P1(I)=IMAX
      CALL PRMROW(A,MDA,N,I,IMAX)
C
C     CONSTRUCT A REFLECTION AND APPLY IT FROM THE RIGHT ON MATRIX A
C
      CALL H12PER(1,I,I+1,N,A(I,1),MDA,D1(I),A(I+1,1),MDA,1,T-I,A(I,I))
C
C     APPLY IT FORM THE LEFT ON VECTOR G (R.H. SIDE IN  A(TR)*V=G )
C
      CALL H12PER(2,I,I+1,N,A(I,1),MDA,D1(I),G,1,N,1,A(I,I))
      KRANK=I+1
   50 CONTINUE
   60 CONTINUE
      PRANKA=KRANK-1
      RETURN
      END
CC2TOUP
      SUBROUTINE C2TOUP(M,NMP,C2,MDC,TOL,P3,PRANKC,D3)
      INTEGER M,NMP,MDC,PRANKC
      INTEGER P3(1)
      DOUBLE PRECISION
     *     TOL
      DOUBLE PRECISION
     *     C2(MDC,1),D3(1)
C
C     NMP=N-PSEUDORANK OF MATRIX A
C
C     THIS ROUTINE TRANSFORMS THE M*NMP (M>=NMP) MATRIX C2 TO UPPER
C                                                       ===========
C     TRIANGULAR FORM BY MULTIPLYING WITH AN ORTHOGONAL MATRIX Q3 AND
C     A PERMUTATION MATRIX P3 SO THAT
C                                       Q3(TR)*C2*P3 = (U)
C                                                      (0)
C     ON ENTRY
C
C     M    INTEGER SCALAR CONTAINING NO. OF ROWS IN MATRIX C2
C     NMP  INTEGER SCALAR CONTAINING NO. OF COLUMNS IN MATRIX C2
C          AND LENGTH OF ARRAYS P3,D3
C     C2(,)REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*NMP
C          CONTAINING THE MATRIX C2 TO TRIANGULARIZE
C     MDC  INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C2
C          MDC MUST BE>=M
C     TOL  REAL SCALAR CONTAINING A SMALL VALUE USED TO DETERMINE
C          PSEUDO RANK OF MATRIX C2
C
C     ON RETURN
C        U IS STORED IN THE UPPER PART OF C2
C        THE NORMALS (EXCEPT ONE ELEMENT) THAT MAKES UP THE MATRIX Q3
C        ARE STORED IN THE COLUMNS OF THE ARRAY C2
C        P3 HOLDS PERMUTATION ORDER OF COLUMNS IN MATRIX C2
C        D3(I) I=1,2,....,NMP HOLDS THE MISSING ELEMENT OF A NORMAL
C        PRANKC IS THE PSEUDORANK OF THE MATRIX C2 (NORMALLY=NMP) WHEN
C        TOL IS USED AS A SMALL POSITIVE NUMBER
C
C     INTERNAL VARIABLES
C
      INTEGER K,KMAX,KRANK,LDIAG
      DOUBLE PRECISION
     *     RMAX,U11
      PRANKC=MIN0(M,NMP)
      IF(NMP.EQ.0 .OR. M.EQ.0) RETURN
      CALL PERMIN(P3,NMP)
      LDIAG=PRANKC
      DO 50 K=1,LDIAG
C
C     FIND LONGEST COLUMN AND DO PERMUTATIONS IF NECESSARY
C
      CALL COLMAX(M,NMP,C2,MDC,K,K,KMAX,RMAX)
      P3(K)=KMAX
      CALL PRMCOL(C2,MDC,M,K,KMAX)
C
C     CONSTRUCT A REFLECTION AND APPLY IT FROM THE LEFT ON MATRIX C2
C
      CALL H12PER(1,K,K+1,M,C2(1,K),1,D3(K),C2(1,K+1),1,MDC,NMP-K,
     1    C2(K,K))
   50 CONTINUE
C
C     DETERMINE PSEUDO RANK OF MATRIX C2
C
      KRANK=0
      U11=DABS(C2(1,1))
      DO 60 K=1,LDIAG
        IF(DABS(C2(K,K)).LE.TOL*U11) GOTO 70
        KRANK=K
   60 CONTINUE
   70 CONTINUE
      PRANKC=KRANK
      RETURN
      END
CCDX
      SUBROUTINE CDX(C1,MDC,M,DIMA,B1,C2,RANKC2,DIMC2,D2,DV,FPRIM)
      INTEGER MDC,M,DIMA,RANKC2,DIMC2
      DOUBLE PRECISION
     *     C1(MDC,1),B1(1),C2(MDC,1),D2(1),DV(M),FPRIM(M)
C
C     COMPUTE THE ORTHOGONAL PROJECTION OF THE VECTOR OF RESIDUALS (F)
C     ONTO THE COLUMN SPACE OF THE JACOBIAN
C     I.E.
C          FPRIM@D= C1*B1+Q3*(DV1)  (1)  WHERE  DV= (DV1) RANKC2*1
C                           ( 0 )                  (DV2) (M-RANKC2)*1
C
C     ON ENTRY
C
C     C1(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*DIMA
C           CONTAINING THE MATRIX C1 OF ORDER M*DIMA
C     MDC   INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAYS C1,C2
C           MDC MUST BE > M
C     M     INTEGER SCALAR CONTAINING NO. OF ROWS IN MATRICES C1 AND C2
C           LENGTH OF ARRAYS DV,FPRIM
C     DIMA INTEGER SCALAR CONTAINING NO. OF COLUMNS IN MATRIX C1
C           AND LENGTH OF ARRAY B1
C     B1()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION DIMA
C           CONTAINING THE VECTOR B1 OF (1) ABOVE
C     C2(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*RANKC2
C           CONTAINING INFO. TO FORM MATRIX Q3 OF (1) ABOVE
C     RANKC2 INTEGER SCALAR CONTAINING PSEUDO RANK OF ORIGINAL MATRIX
C           C2 EMANATING FROM THE JACOBIAN OF THE OBJECTIVE FUNCTION
C     DIMC2  INTEGER SCALAR CONTAINING NO. OF ELEMENTS IN DV THAT
C            SHOULD BE CONSIDDERED AS NONZERO
C     D2()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKC2
C           CONTAINING MORE INFO. NEEDED TO FORM MATRIX Q3 OF (1)
C     DV()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M CONTAINING
C           THE CONCATENATED VECTORS DV1 AND DV2 OF (1) ABOVE
C
C     ON RETURN
C
C     FPRIM() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M CONTAINS
C             THE COMPUTED VALUE OF C1*B1+Q3*(DV1)
C                                            ( 0 )
C     INTERNAL VARIABLES
C
      INTEGER I,K
      DOUBLE PRECISION
     *     SUM
      DO 10 I=1,M
           FPRIM(I)=DV(I)
           IF(I.GT.DIMC2) FPRIM(I)=0.0D0
   10 CONTINUE
      IF(RANKC2.LE.0) GOTO 30
C
C     FORM FPRIM = Q3*(DV1)
C                     ( 0 )
C
      DO 20 I=1,RANKC2
           K=RANKC2+1-I
           CALL H12PER(2,K,K+1,M,C2(1,K),1,D2(K),FPRIM,1,M,1,C2(K,K))
   20 CONTINUE
   30 CONTINUE
C
C     FORM FPRIM@D= FPRIM+C1*B1
C
      IF(DIMA.LE.0) GOTO 60
      DO 50 I=1,M
           SUM=0.0D0
           DO 40 K=1,DIMA
                SUM=SUM+C1(I,K)*B1(K)
   40      CONTINUE
           FPRIM(I)=FPRIM(I)+SUM
   50 CONTINUE
   60 CONTINUE
      RETURN
      END
CROWMAX
      SUBROUTINE ROWMAX(M,N,A,MDA,IS,JS,IMAX,RMAX)
      INTEGER M,N,MDA,IS,JS,IMAX
      DOUBLE PRECISION
     *     RMAX
      DOUBLE PRECISION
     *     A(MDA,N)
C
C     FIND LONGEST ROW AMONG ROWS IS,IS+1,...,M  IN THE M*N MATRIX A
C     THE ELEMENTS CONSIDDERED IN EACH ROW START IN COLUMN JS AND END
C     IN COLUMN N
C                      N
C      RMAX@D=MAXIMUM(SIGMA A(I,J)**2)
C              I     J=JS
C     WHERE I=IS,IS+1,...,M
C     IMAX IS SET TO THE ROWNUMBER FOR WHICH THE MAXIMUM IS ATTAINED
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     ROWSUM
      RMAX=-1.0D0
      DO 20 I=IS,M
      ROWSUM=0.0D0
           DO 10 J=JS,N
           ROWSUM=ROWSUM+A(I,J)**2
   10      CONTINUE
      IF(ROWSUM.LE.RMAX) GOTO 20
      RMAX=ROWSUM
      IMAX=I
   20 CONTINUE
      RETURN
      END
CCOLMAX
      SUBROUTINE COLMAX(M,N,A,MDA,IS,JS,JMAX,RMAX)
      INTEGER M,N,MDA,IS,JS,JMAX
      DOUBLE PRECISION
     *     RMAX
      DOUBLE PRECISION
     *     A(MDA,N)
C
C     FIND LONGEST COLUMN AMONG JS,JS+1,.....,N IN THE M*N MATRIX A
C     THE ELEMENTS CONSIDDERED IN EACH COLUMN START IN ROW IS AND
C     END IN ROW M
C                     M
C     RMAX@D=MAXIMUM(SIGMA A(I,J)**2)
C             J     I=IS
C     WHERE J=JS,JS+1,.....,N
C     JMAX IS SET TO THE COLUMN NUMBER FOR WHICH THE MAXIMUM
C     IS ATTAINED
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     COLSUM
      RMAX=-1.0D0
      DO 20 J=JS,N
      COLSUM=0.0D0
           DO 10 I=IS,M
           COLSUM=COLSUM+A(I,J)**2
   10      CONTINUE
      IF(COLSUM.LE.RMAX) GOTO 20
      RMAX=COLSUM
      JMAX=J
   20 CONTINUE
      RETURN
      END
CPRMROW
      SUBROUTINE PRMROW(A,MDA,N,I,K)
      INTEGER N,MDA,I,K
      DOUBLE PRECISION
     *     A(MDA,N)
C
C     CHANGE ROWS I AND K OF THE MATRIX A
C     N IS THE LENGTH OF A ROW
C
C     INTERNAL VARIABLES
C
      INTEGER J
      DOUBLE PRECISION
     *     TEMP
      IF(I.EQ.K) RETURN
      DO 10 J=1,N
      TEMP=A(I,J)
      A(I,J)=A(K,J)
      A(K,J)=TEMP
   10 CONTINUE
      RETURN
      END
CPRMCOL
      SUBROUTINE PRMCOL(A,MDA,M,J,K)
      INTEGER MDA,M,J,K
      DOUBLE PRECISION
     *     A(MDA,1)
C
C     CHANGE COLUMN J AND K OF THE MATRIX A
C     M IS THE LENGTH OF A COLUMN
C
C     INTERNAL VARIABLES
C
      INTEGER I
      DOUBLE PRECISION
     *     TEMP
      IF(J.EQ.K) RETURN
      DO 10 I=1,M
      TEMP=A(I,J)
      A(I,J)=A(I,K)
      A(I,K)=TEMP
   10 CONTINUE
      RETURN
      END
CPTRV
      SUBROUTINE PTRV(P,M,V,MDV,N)
      INTEGER M,MDV,N
      INTEGER P(1)
      DOUBLE PRECISION
     *     V(MDV,1)
C
C     P IS A PERMUTATION MATRIX   T(1,J1)*T(2,J2)*......*T(M,JM)
C     THE ARRAY P CONTAINS THE VALUES J1,J2,....,JM
C     PERMUTE ROWS IN MATRIX V BY FORMING
C               V@D=P(TR)*V
C
      IF(M.LE.0 .OR. N.LE.0) RETURN
      DO 10 I=1,M
      CALL PRMROW(V,MDV,N,I,P(I))
   10 CONTINUE
      RETURN
      END
CVPTR
      SUBROUTINE VPTR(P,M,V,MDV,N)
      INTEGER M,MDV,N
      INTEGER P(1)
      DOUBLE PRECISION
     *     V(MDV,1)
C
C     P IS A PERMUTATION MATRIX T(1,J1)*T(2,J2)*........*T(M,JM)
C     THE ARRAY P CONTAINS THE VALUES J1,J2,......,JM
C     PERMUTE COLUMNS IN MATRIX V BY FORMING
C         V@D=V*P(TR)
C
      IF(M.LE.0 .OR. N.LE.0) RETURN
      DO 10 I=1,M
           K=M+1-I
           CALL PRMCOL(V,MDV,M,K,P(K))
   10 CONTINUE
      RETURN
      END
CPV
      SUBROUTINE PV(P,M,V,MDV,N)
      INTEGER M,MDV,N
      INTEGER P(1)
      DOUBLE PRECISION
     *     V(MDV,1)
C
C     P IS A PERMUTATION MATRIX   T(1,J1)*T(2,J2)*.......*T(M,JM)
C     THE ARRAY P CONTAINS THE VALUES  J1,J2,.....,JM
C     PERMUTE ROWS IN MATRIX V BY FORMING
C               V@D=P*V
C
      IF(M.LE.0 .OR. N.LE.0) RETURN
      DO 10 I=1,M
      K=M+1-I
      CALL PRMROW(V,MDV,N,K,P(K))
   10 CONTINUE
      RETURN
      END
CVP
      SUBROUTINE VP(V,MDV,M,N,P)
      INTEGER MDV,M,N
      INTEGER P(1)
      DOUBLE PRECISION
     *     V(MDV,1)
C
C     P IS A PERMUTATION MATRIX   T(1,J1)*T(2,J2)*.......*T(N,JN)
C     THE ARRAY P CONTAINS THE VALUES J1,J2,......,JN
C     PERMUTE COLUMNS IN MATRIX V BY FORMING
C               V@D=V*P
C
      IF(M.LE.0 .OR. N.LE.0) RETURN
      DO 10 J=1,N
      CALL PRMCOL(V,MDV,M,J,P(J))
   10 CONTINUE
      RETURN
      END
CH12PER
C     SUBROUTINE H12PER(MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV,PIVEL)
C
C      ***********************************************************
C      THIS IS A MODIFIED H12(......)  ROUTINE  (PER LINDSTROM)
C
C      THE LAST PARAMETER (PIVEL) IS THE PIVOT ELEMENT
C
C      ***********************************************************
C     CONSTRUCTION AND/OR APPLICATION OF A SINGLE
C     HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B
C
C     MODE    = 1 OR 2   TO SELECT ALGORITHM  H1  OR  H2 .
C     LPIVOT IS THE INDEX OF THE PIVOT ELEMENT.
C     L1,M   IF L1 .LE. M   THE TRANSFORMATION WILL BE CONSTRUCTED TO
C            ZERO ELEMENTS INDEXED FROM L1 THROUGH M.   IF L1 GT. M
C            THE SUBROUTINE DOES AN IDENTITY TRANSFORMATION.
C     U(),IUE,UP    ON ENTRY TO H1 U() CONTAINS THE PIVOT VECTOR.
C                   IUE IS THE STORAGE INCREMENT BETWEEN ELEMENTS.
C                                       ON EXIT FROM H1 U() AND UP
C                   CONTAIN QUANTITIES DEFINING THE VECTOR U OF THE
C                   HOUSEHOLDER TRANSFORMATION.   ON ENTRY TO H2 U()
C                   AND UP SHOULD CONTAIN QUANTITIES PREVIOUSLY COMPUTED
C                   BY H1.  THESE WILL NOT BE MODIFIED BY H2.
C     C()    ON ENTRY TO H1 OR H2 C() CONTAINS A MATRIX WHICH WILL BE
C            REGARDED AS A SET OF VECTORS TO WHICH THE HOUSEHOLDER
C            TRANSFORMATION IS TO BE APPLIED.  ON EXIT C() CONTAINS THE
C            SET OF TRANSFORMED VECTORS.
C     ICE    STORAGE INCREMENT BETWEEN ELEMENTS OF VECTORS IN C().
C     ICV    STORAGE INCREMENT BETWEEN VECTORS IN C().
C     NCV    NUMBER OF VECTORS IN C() TO BE TRANSFORMED. IF NCV .LE. 0
C            NO OPERATIONS WILL BE DONE ON C().
C     PIVEL      IS THE PIVOT ELEMENT
C
      SUBROUTINE H12PER(MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV,PIVEL)
      INTEGER MODE,LPIVOT,L1,M,IUE,ICE,ICV,NCV
      DOUBLE PRECISION
     *     UP,PIVEL
      DOUBLE PRECISION
     *     U(IUE,M), C(1)
C
C     INTERNAL VARIABLES
C
      INTEGER I,INCR,I2,I3,I4,J
      DOUBLE PRECISION
     *     CL,CLINV,ONE,SM1
      DOUBLE PRECISION SM,B
      ONE=1.0D0
C
      IF (0.GE.LPIVOT.OR.LPIVOT.GE.L1.OR.L1.GT.M) RETURN
      CL=DABS(PIVEL)
      IF (MODE.EQ.2) GO TO 60
C                            ****** CONSTRUCT THE TRANSFORMATION. ******
          DO 10 J=L1,M
   10     CL=DMAX1(DABS(U(1,J)),CL)
      IF (CL) 130,130,20
   20 CLINV=ONE/CL
      SM=(DBLE(PIVEL)*CLINV)**2
          DO 30 J=L1,M
   30     SM=SM+(DBLE(U(1,J))*CLINV)**2
C                              CONVERT DBLE. PREC. SM TO SNGL. PREC. SM1
      SM1=SM
      CL=CL*DSQRT(SM1)
      IF (PIVEL) 50,50,40
   40 CL=-CL
   50 UP=PIVEL-CL
      PIVEL=CL
      GO TO 70
C            ****** APPLY THE TRANSFORMATION  I+U*(U**T)/B  TO C. ******
C
   60 IF (CL) 130,130,70
   70 IF (NCV.LE.0) RETURN
      B=DBLE(UP)*PIVEL
C                       B  MUST BE NONPOSITIVE HERE.  IF B = 0., RETURN.
C
      IF (B) 80,130,130
   80 B=ONE/B
      I2=1-ICV+ICE*(LPIVOT-1)
      INCR=ICE*(L1-LPIVOT)
          DO 120 J=1,NCV
          I2=I2+ICV
          I3=I2+INCR
          I4=I3
          SM=C(I2)*DBLE(UP)
              DO 90 I=L1,M
              SM=SM+C(I3)*DBLE(U(1,I))
   90         I3=I3+ICE
          IF (SM) 100,120,100
  100     SM=SM*B
          C(I2)=C(I2)+SM*DBLE(UP)
              DO 110 I=L1,M
              C(I4)=C(I4)+SM*DBLE(U(1,I))
  110         I4=I4+ICE
  120     CONTINUE
  130 RETURN
      END
CCH
      SUBROUTINE CH(M,N,C,MDC,H,MDH,V)
      INTEGER M,N,MDC,MDH
      DOUBLE PRECISION
     *     C(MDC,N),H(MDH,N),V(N)
C
C     FORM PRODUCT   C@D=C*H
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K
      DOUBLE PRECISION
     *     S1
      DO 50 I=1,M
           DO 10 K=1,N
           V(K)=C(I,K)
   10      CONTINUE
           DO 30 J=1,N
           S1=0.0D0
                DO 20 K=1,N
                S1=S1+V(K)*H(K,J)
   20           CONTINUE
           C(I,J)=S1
   30      CONTINUE
   50 CONTINUE
      RETURN
      END
CHXCOMP
      SUBROUTINE HXCOMP(H,MDH,N,X,S)
      INTEGER MDH,N
      DOUBLE PRECISION
     *     H(MDH,N),X(N),S(N)
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     S1
      DO 10 I=1,N
      S(I)=X(I)
   10 CONTINUE
      DO 50 I=1,N
      S1=0.0D0
           DO 40 J=1,N
           S1=S1+H(I,J)*S(J)
   40      CONTINUE
      X(I)=S1
   50 CONTINUE
      RETURN
      END
CGIVEN2
      SUBROUTINE GIVEN2(C,S,X,Y)
      DOUBLE PRECISION
     *     C,S,X,Y
C
C     APPLY THE ROTATION COMPUTED BY GIVEN1 TO  (X,Y)
C
C     X = (C S)(X)     Y = (S -C)(X)
C              (Y)               (Y)
C
C     INTERNAL VARIABLE
C
      DOUBLE PRECISION
     *     XT
      XT=C*X+S*Y
      Y=S*X-C*Y
      X=XT
      RETURN
      END
CPSPECF
      SUBROUTINE PSPECF(N,P,W,F)
      INTEGER N,P(N)
      DOUBLE PRECISION
     *     W(N),F(N)
C
C     P CONTAINS A PERMUTATION MATRIX THAT HOLDS THE LOCATION
C     OF THE ORIGINAL ELEMENTS
C     I.E.
C          P(K) SAYS WHERE ELEMENT K IS MOVED
C
C     INTERNAL VARIABLES
C
      INTEGER I,K
      IF(N.LE.0) RETURN
      DO 10 K=1,N
      I=P(K)
      F(K)=W(I)
   10 CONTINUE
      RETURN
      END
CPROD1
      SUBROUTINE PROD1(H,MDH,S,P,BETA,J,TP1)
      INTEGER MDH,J,TP1
      DOUBLE PRECISION
     *     H(MDH,1),S(TP1),P(TP1),BETA(TP1)
C
C     FORM PRODUCT OF GIVENS MATRICES
C     AND TRANSPOSE IT
C
C     INTERNAL VARIABLES
C
      INTEGER I,IP1,K
      IF(J.GT.TP1) RETURN
      DO 20 I=J,TP1
      IP1=I+1
      IF(IP1.LE.TP1) H(IP1,I)=S(I)
           DO 10 K=I,TP1
           H(I,K)=P(K)*BETA(I)
   10      CONTINUE
   20 CONTINUE
      RETURN
      END
CCQHP2
      SUBROUTINE CQHP2(TIME,C,MDC,M,N,T,PRANKA,PIVOT,NA,A,MDA,D1,H,MDH,
     1    P2,V)
      INTEGER TIME,MDC,M,N,T,PRANKA,NA,MDH
      INTEGER P2(N)
      DOUBLE PRECISION
     *     C(MDC,N),A(MDA,N),H(MDH,N),D1(1),V(N),PIVOT(1)
C
C     COMPUTE  C@D= C*Q1*H*P2     WHERE
C             Q1 IS ORTHOGONAL STORED IN ARRAY A AND D1 IN A SPECIAL WAY
C              H IS PRODUCT OF GIVENS ROTATIONS
C              P2 IS A PERMUTATION MATRIX
C
C     INTERNAL VARIABLE
C
      INTEGER I
      IF(NA.EQ.0) RETURN
C
C     COMPUTE    C@D=C*Q1
      DO 10 I=1,NA
      CALL H12PER(2,I,I+1,N,A(I,1),MDA,D1(I),C,MDC,1,M,PIVOT(I))
   10 CONTINUE
      IF(TIME.LE.2) GOTO 20
      IF((TIME.EQ.3).AND.(T.EQ.0)) GOTO 20
C
C     COMPUTE   C@D=C*H
C
      CALL CH(M,N,C,MDC,H,MDH,V)
   20 CONTINUE
      IF(T.EQ.PRANKA) RETURN
C
C     COMPUTE   C@D=C*P2
C
      CALL VP(C,MDC,M,PRANKA,P2)
      RETURN
      END
CSIGNCH
      SUBROUTINE SIGNCH(TIME,P1,V,T,ACTIVE,BND,BETKM1,GNDNRM,ITNO,
     1 SCALE,DIAG,GRES,H,KP,L,J,S,P2,WORK)
      INTEGER TIME,T,BND,ITNO,SCALE,KP,L,J,S
      INTEGER P1(1),ACTIVE(1)
      DOUBLE PRECISION
     *     BETKM1,GNDNRM,GRES
      DOUBLE PRECISION
     *     V(1),DIAG(1),P2(1),H(1),WORK(1)
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     ROWI,SQREL,DELTA,E,TAU
      INTEGER TM1,I,K,KP1,IVAL
      DATA IVAL,DELTA,TAU /4,10.0D0,0.5D0/
C
C     DETERMINE S.    THE CONSTRAINT THAT SHALL BE DELETED FROM
C                     THE CURRENT WORKING SET
C     S IS SET TO 0   IF NO CONSTRAINT SHALL BE DELETED
C     S IS SET TO K   (KP<K<=T) CONSTRAINT TO BE DELETED
C
C     J IS SET TO THE CORRESPONDING ROW NUMBER IN P1(TR)*DIAG*A
C                     IF A ROW SHALL BE DELETED
C
      S=0
      IF(KP.EQ.T) RETURN
C
C     LOOK FOR GREATEST NEGATIVE MULTIPLIER(DIFFERENT FROM ZERO)
C     AMONG MULTIPLIERS CORRESPONDING TO CONSTRAINTS DEFINED AS
C     INEQUALITIES
C
      E=0.0D0
      SQREL=DSQRT(DRELPR)
      KP1=KP+1
      DO 5 I=KP1,T
         K=ACTIVE(I)
         IF(SCALE.EQ.0) ROWI=DIAG(I)
         IF(SCALE.NE.0) ROWI=1.0D0/DIAG(I)
         IF(-SQREL .LT. V(I)*ROWI) GOTO 5
         IF(V(I)*ROWI.GE.E)   GOTO 5
         E=V(I)*ROWI
         S=I
    5 CONTINUE
      IF(GRES .GT. (-E*DELTA)) S=0
      IF(S.EQ.0) RETURN
      K=ACTIVE(S)
      I=BND+K-KP
      IF(ACTIVE(I) .EQ. 1) GOTO 10
      IF(((ITNO-ACTIVE(I)).LT.IVAL).AND.(BETKM1.GT.TAU*GNDNRM)) S=0
      IF(S.EQ.0) RETURN
   10 CONTINUE
      ACTIVE(I)=-1
      IF(BETKM1.LE.TAU*GNDNRM) CALL UNSCR(ACTIVE,BND,L,KP)
      IF(TIME.GE.3) GOTO 40
C
C     TRANSFORM THE TRANPOSITION VECTOR P1 TO A ORDER VECTOR
C
      DO 20 I=1,T
           P2(I)=DBLE(I)+0.1D0
   20 CONTINUE
C
C     PERMUTE THE ORDER VECTOR
C
      CALL PV(P1,T,P2,T,1)
      DO 30 I=1,T
           P1(I)=IDINT(P2(I))
   30 CONTINUE
   40 CONTINUE
      J=P1(S)
      TM1=T-1
      IF(TM1.LT.1) RETURN
C
C     FORM ORDER VECTOR OF DIMENSION T-1
C
      DO 50 I=1,T
           IF(I.LT.J) P2(I)=DBLE(I)+0.1D0
           IF(I.EQ.J) P2(I)=0.0D0
           IF(I.GT.J) P2(I)=DBLE(I-1)+0.1D0
   50 CONTINUE
      CALL PSPECF(T,P1,P2,WORK)
      DO 60 I=1,T
           P1(I)=IDINT(WORK(I))
           IF(P1(I).EQ.0) K=I
   60 CONTINUE
      IF(K.EQ.T) RETURN
      DO 70 I=K,TM1
           P1(I)=P1(I+1)
   70 CONTINUE
      RETURN
      END
CREORD
      SUBROUTINE REORD(A,MDA,T,N,BV,J,S,ACTIVE,INACT,KQ,P4,U,
     1 ISCALE,DIAG)
      INTEGER MDA,T,N,J,S,KQ,ISCALE
      INTEGER ACTIVE(1),INACT(1),P4(1)
      DOUBLE PRECISION
     *     A(MDA,N),BV(1),DIAG(1),U(1)
C
C     DELETE COLUMN J AND COMPRESS THE UPPER TRIANGULAR MATRIX R
C     DELETE ELEMENT J AND COMPRESS THE VECTOR BV
C     DELETE ELEMENT S IN SCALING MATRIX DIAG AND COMPRESS IT
C
C     R(TR)  (T*T)   IS STORED AS THE FIRST T COLUMNS OF THE ARRAY A
C
C     CHANGES ARE DONE TO THE ACTIVE AND INACTIVE SETS
C
C     ON ENTRY@D
C
C     A(,)         SEE EXPLANATION IN SUBROUTINE MULEST
C     MDA          LEADING DIMENSION OF THE ARRAY A
C     T            INTEGER SCALAR CONTAINING NO. OF CONSTRAINTS IN WORKING SET
C     N            INTEGER SCALAR CONTAINING NO. OF VARIABLES
C     BV()         SEE EXPLANATION IN SUBROUTINE MULEST
C     J            INTEGER SCALAR CONTAINING THE ROW NUMBER OF THE ROW IN THE
C                  LOWER TRIANGULAR MATRIX L TO BE DELETED
C     S            INTEGER SCALAR CONTAINING THE CORRESPONDING ROW NUMBER IN THE
C                  ORIGINAL MATRIX A
C     ACTIVE()     SEE EXPLANATION IN SUBROUTINE WRKSET
C     INACT()      SEE EXPLANATION IN SUBROUTINE WRKSET
C     KQ           INTEGER SCALAR CONTAINING THE NO. OF CONSTRAINTS IN THE
C                  CURRENT INACTIVE SET
C     P4()         SEE EXPLANATION IN SUBROUTINE WRKSET
C     ISCALE       SEE EXPLANATION SUBROUTINE MULEST
C     DIAG()       SEE EXPLANATION IN SUBROUTINE MULEST
C
C     ON RETURN@D
C
C     A(,)         A(I,K)@D=A(I+1,K) ;I=J,J+1,.....,T-1
C                    AND K=1,2,......,J
C     T            T@D=T-1
C     BV()         BV(I)@D=BV(I+1) ; I=J,J+1,....,T-1
C     ACTIVE()     ONE CONSTRAINT NO. IS SUBTRACTED
C     INACT()      ONE CONSTRAINT NO. IS ADDED
C     KQ           KQ@D=KQ+1
C     P4()         P4(J)@D= THE NO. OF ELEMENTS IN ROW NO. J OF THE LOWER
C                  TRIANGULAR MATRIX L
C
C     WORKING AREA@D
C
C     U()          REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C
C     INTERNAL VARIABLES
C
      INTEGER TM1,I,IP1,K
      DOUBLE PRECISION
     *     TEMP
      TM1=T-1
      IF(J.EQ.T) GOTO 30
      DO 5 I=1,J
        U(I)=A(J,I)
    5 CONTINUE
      DO 20 I=J,TM1
      IP1=I+1
           DO 10 K=1,J
           A(I,K)=A(IP1,K)
   10      CONTINUE
      BV(I)=BV(IP1)
   20 CONTINUE
      DO 25 I=1,J
        A(T,I)=U(I)
   25 CONTINUE
   30 CONTINUE
      IF((ISCALE.EQ.0).OR.(S.EQ.T)) GOTO 50
      TEMP=DIAG(S)
      DO 40 I=S,TM1
      DIAG(I)=DIAG(I+1)
   40 CONTINUE
      DIAG(T)=TEMP
   50 CONTINUE
C
C     SAVE NO. OF ELEMENTS IN ROW CORRESPONDING TO CONSTRAINT NO. S
C
      K=ACTIVE(S)
      P4(K)=J
      CALL DELETE(ACTIVE,INACT,KQ,T,S)
      RETURN
      END
CATSOLV
      SUBROUTINE ATSOLV(A,MDA,T,B,X,N,RESIDU)
      INTEGER MDA,T,N
      DOUBLE PRECISION
     *     A(MDA,N),B(N),X(1),RESIDU
C
C     A CONTAINS ( L@D0 ) WHERE L IS T*T LOWER TRIANGULAR
C
C     SOLVE FOR X THE SYSTEM
C         L*X = B
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K,L
      DOUBLE PRECISION
     *     S1,DNRM2
      IF(T.EQ.0) GOTO 55
      DO 50 K=1,T
      J=T-K+1
      L=J+1
      S1=0.0D0
      IF(L.GT.T) GOTO 40
           DO 10 I=L,T
           S1=S1+X(I)*A(I,J)
   10      CONTINUE
   40 CONTINUE
      X(J)=(B(J)-S1)/A(J,J)
   50 CONTINUE
   55 CONTINUE
C
C     COMPUTE THE NORM OF THE RESIDUAL L*X-B
C     IF T=0    THEN  II B II IS COMPUTED WHICH IS THE NORM OF THE
C     GRADIENT OF THE OBJECTIVE FUNCTION
C
      RESIDU=DNRM2(N-T,B(T+1),1)
      RETURN
      END
C     HELP ROUTINES (FILE 2) FOR ENLSIP
C     DOUBLE PRECISION VERSION 841005
C
CGRAD
      SUBROUTINE GRAD(A,MDA,M,N,F,G)
      DOUBLE PRECISION
     *     A(MDA,N),F(M),G(N)
C
C     COMPUTE THE GRADIENT G(X) TO  0.5* II F(X) II**2       T
C            WHERE  F(X) = (F1(X),F2(X),...............FM(X))
C     THE MATRIX A  (M*N)  IS THE JACOBIAN OF  F(X)
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     GS
      DO 20 I=1,N
      GS=0.0D0
          DO 10 J=1,M
          GS=GS+A(J,I)*F(J)
   10     CONTINUE
      G(I)=GS
   20 CONTINUE
      RETURN
      END
CQUAMIN
      SUBROUTINE QUAMIN(X,FX,W,FW,V,FV,U)
      DOUBLE PRECISION
     *    X,FX,W,FW,V,FV,U
C
C     COMPUTE THE MINIMUM POINT U OF A QUADRATIC POLYNOMIAL PASSING
C     THROUGH (V,F(V)), (W,F(W)) AND (X,F(X))
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     D1,D2,S,Q
      D1=FV-FX
      D2=FW-FX
      S=(W-X)*(W-X)*D1-(V-X)*(V-X)*D2
      Q=2.0D0*((V-X)*D2-(W-X)*D1)
      U=X-S/Q
      RETURN
      END
CDELETE
      SUBROUTINE DELETE(OA,OI,Q,T,K)
      INTEGER Q,T,K
      INTEGER OA(1),OI(1)
C
C     REMOVE CONSTRAINT K FROM THE ACTIVE SET AND
C     PLACE IT IN THE INACTIVE SET
C
C     INTERNAL VARIABLE
C
      INTEGER I
      Q=Q+1
      OI(Q)=OA(K)
      DO 10 I=K,T
      OA(I)=OA(I+1)
   10 CONTINUE
      T=T-1
      RETURN
      END
CADDIT
      SUBROUTINE ADDIT(OA,OI,T,Q,K)
      INTEGER T,Q,K
      INTEGER OA(1),OI(1)
C
C     ADD A CONSTRAINT TO THE ACTIVE SET
C
C     INTERNAL VARIABLE
C
      INTEGER I
      T=T+1
      OA(T)=OI(K)
      DO 10 I=K,Q
      OI(I)=OI(I+1)
   10 CONTINUE
      Q=Q-1
      RETURN
      END
CLINEC
      SUBROUTINE LINEC(XOLD,P,F,V1,M,N,ALPHA,PSIZER,DPSIZE,ALFLOW,
     1  FFUNC,HFUNC,H,HNEW,ACTIVE,T,INACT,Q,L,W,ALFUPP,FNEW,V2,G,
     2  PSIALF,XDIFF,EVAL,EXIT)
      EXTERNAL FFUNC,HFUNC
      INTEGER M,N,T,Q,L,EVAL,EXIT
      INTEGER ACTIVE(1),INACT(1)
      DOUBLE PRECISION
     *     ALPHA,PSIZER,DPSIZE,ALFLOW,ALFUPP,PSIALF,XDIFF
      DOUBLE PRECISION
     *     XOLD(N),P(N),F(1),W(1),FNEW(1),V1(1),V2(1),G(N)
      DOUBLE PRECISION
     *     H(1),HNEW(1)
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C
C
C     THIS IS A LINE SEARCH ROUTINE FOR CONSTRAINED LEAST
C     SQUARES PROBLEMS
C
C     COMPUTE THE STEPLENGTH ALPHA FOR THE ITERATION
C     XNEW@D=XOLD+ALPHA*P
C     WHERE   XOLD IS THE CURRENT POINT
C             P    IS THE SEARCH DIRECTION
C     ALPHA IS CLOSE TO THE SOLUTION OF THE PROBLEM
C             MINIMIZE  PSI(ALPHA)
C     WITH THE RESTRICTION  0<ALFLOW<=ALPHA<=ALFUPP
C     HOWEVER, IF WE ARE FORCED TO TAKE A PURE GOLDSTEIN-ARMIJO STEP
C     THE LOWER BOUND CAN BE SLIGHTLY DECREASED
C
C     PSI(ALPHA)=0.5*(IIF(XOLD+ALPHA*P)II**2+
C                +SIGMA(W(I)*H (XOLD+ALPHA*P)**2)
C                  I          I
C
C     WHERE I BELONG TO THE CURRENT WORKING SET
C
C     F(X)= (F1(X),F2(X),.........,FM(X)) TRANSPOSE
C     H(X)= (H1(X),H2(X),............,HL(X)) TRANSPOSE
C
C     ON ENTRY@D
C     XOLD(N)      REAL ARRAY OF LENGTH N-THE CURRENT POINT.CHANGED
C                  ON RETURN
C     P(N)         REAL ARRAY OF LENGTH N-SEARCH DIRECTION
C     F(M+L)       REAL ARRAY OF LENGTH M+L -F(1)....F(M) CONTAIN THE
C                  VALUE OF F(X) AT THE CURRENT POINT.CHANGED ON RETURN
C     V1(M+L)      REAL ARRAY 0F LENGTH M+L CONTAINING THE COMPOUND
C                  VECTOR (C*P) WHERE C AND A ARE THE JACOBIANS
C                         (AHAT*P)
C     M            INTEGER-NO. OF FUNCTIONS IN F(X)=F1(X).......,FM(X)
C     N            INTEGER-NO. OF UNKNOWNS
C     ALPHA        REAL-THE DISIRED STEPLENGTH.CHANGED ON EXIT
C     PSIZER       REAL-PSI(ALPHA) AT ALPHA=0
C     DPSIZE       REAL SCALAR CONTAINING THE DERIVATIVE OF PSI(ALPHA)
C                  AT ALPHA=0
C     ALFLOW       REAL-FIX LOWER BOUND OF THE STEPLENGTH
C     FFUNC        SUBROUTINE NAME-USER WRITTEN SUBROUTINE WHICH
C                  EVALUATES THE FUNCTION F(X)
C     HFUNC        SUBROUTINE NAME-USER WRITTEN SUBROUTINE WHICH
C                  EVALUATES THE CONSTRAINTS H(X)
C                  BOTH FFUNC AND HFUNC MUST BE WRITTEN AS FOLLOWS
C                  (WITH THE OBVIOUS CHANGES FOR HFUNC)
C
C                  SUBROUTINE FFUNC(X,N,F,M,CTRL,C,MDC)
C                  INTEGER N,M,CTRL,MDC
C                  REAL X(N),F(M),C(MDC,N)
C                  -----------------------
C                  CTRL CAN HAVE 3 DIFFERENT VALUES ON ENTRY
C         CTRL= 1  MEANS EVALUATE THE FUNCTIONS AT THE POINT X AND
C                  RETURN THIS VECTOR IN THE ARRAY F IF THE FUNCTIONS
C                  ARE COMPUTABLE.
C                  ON RETURN THE USER CAN INDICATE UNCOMPUTABILITY BY
C                  SETTING CTRL=-1
C                  DO NOT ALTER ARRAY X.
C         CTRL=-1  MEANS EVALUATE THE FUNCTIONS AT THE POINT X AND
C                  RETURN THIS VECTOR IN THE ARRAY F IF THE FUNCTIONS
C                  ARE COMPUTABLE. DO NOT ALTER ARRAY X.
C                  POSSIBLE UNCOMPUTABILITY OF THE FUNCTIONS MUST BE
C                  INDICATED BY SETTING CTRL TO A VALUE <-10 ON RETURN
C         CTRL= 2  MEANS CALCULATE THE JACOBIAN OF F(X) AT THE POINT X
C                  AND RETURN THIS MATRIX IN THE ARRAY C IF THE JACOBIAN
C                  IS SUPPLIED ANALYTICALLY.
C                  POSSIBLE UNCOMPUTABILITY OF THE JACOBIAN MUST BE
C                  INDICATED BY SETTING CTRL TO A VALUE <-10 ON RETURN
C                  IF THE USER WANTS THE JACOBIAN BEING COMPUTED
C                  NUMERICALLY THAT SHOULD BE INDICATED BY SETTING
C                  CTRL=0 ON RETURN.
C                  DO NOT ALTER ARRAYS X AND F.
C                  ------------------------------
C                  RETURN
C                  END
C     H(L)         REAL ARRAY OF LENGTH L-VALUE OF THE CONSTRAINTS AT
C                  THE CURRENT POINT.CHANGED ON EXIT
C     ACTIVE(T)    INTEGER ARRAY OF LENGTH T=INDECIES FOR THE T ACTIVE
C                  CONSTRAINTS
C     T            INTEGER-NO. OF ACTIVE CONSTRAINTS
C     INACT(Q)     INTEGER ARRAY OF LENGTH Q -INDECEC FOR THE INACTIVE
C                  CONSTRAINTS
C     Q            INTEGER - NO. OF INACTIVE CONSTRAINTS
C     L            INTEGER-TOTAL NO. OF CONSTRAINTS
C     ALFUPP       REAL-FIX UPPER BOUND OF THE STEPLENGTH DUE TO ANY
C                  INACTIVE CONSTRAINT
C
C     ON RETURN@D
C     XOLD(N)      THE NEW POINT
C     F(M)         THE VALUE OF F(X) AT THE NEW POINT
C     ALPHA        THE COMPUTED STEPLENGTH
C     H(L)         THE VALUE OF THE CONSTRAINTS AT THE NEW POINT
C     PSIALF       REAL-PSI(ALPHA) AT THE NEW POINT
C     XDIFF        REAL-THE 2-NORM  II XOLD-XNEW II
C     EXIT         INTEGER-  =-1 IF THE SEARCH DIRECTION IS NOT A
C                                DESCENT DIRECTION.
C                            =-2 IF PMAX*ALPHA<DSQRT(DRELPR)
C                                  OR ALPHA<ALFLOW
C                            =-3 IF FIRST GUESS OF STEPLENGTH MAKES THE
C                                RESIDUALS OR THE CONSTRAINTS
C                                UNCOMPUTABLE
C                            <-10 AS A USER STOP INDICATOR
C                            = 0  OTHERWISE
C     EVAL    INTEGER- THE NO. OF EVALUATIONS OF THE RESIDUALS INSIDE
C                   THIS ROUTINE
C
C     WORKING AREAS@D
C     FNEW(M+L)    REAL ARRAY OF LENGTH M+L
C     HNEW(L)      REAL ARRAY OF LENGTH L
C     V2(M+L)      REAL ARRAY OF LENGTH M+L
C     G(N)         REAL ARRAY OF LENGTH N
C
C     INTERNAL VARIABLES
C
      INTEGER CTRL,I,K,MPL,MPT
      DOUBLE PRECISION
     *     ALFK,ALFKM1,ALFKM2,ALFKP1,ALFMAX,ALFMIN,BETA,DIFF,
     1 ETA,GAMMA,PBETA,PK,PMAX,PSIK,PSIKM1,PSIKM2,TAU,XEL,XMIN,
     2 DNRM2,PSI
      LOGICAL REDUCE
*      write(10,*) 'In LINEC'
*      write(10,*) 'alpha,psizer,dpsize: ',alpha,psizer,dpsize
      K=0
      XDIFF=0.0D0
      PSIKM1=PSIZER
      MPT=M+T
      MPL=M+L
C
C     SET VALUES OF CONSTANTS ETA,TAU,GAMMA
C     COMPUTE ALFMIN,ALFMAX,ALFK
C
      CALL LINC1(P,N,ALPHA,ALFLOW,ALFUPP,ETA,TAU,GAMMA,
     2  ALFMIN,ALFMAX,ALFK,PMAX)
      EXIT=0
      ALFKM1=ALFK
*      write(10,*) 'alfk= ',alfk
C
C     COMPUTE PSIK=PSI(ALF0) AND TEST UNCOMPUTABILITY
C
      CTRL=1
      PSIK=PSI(XOLD,P,N,ALFK,G,FNEW,M,FFUNC,HNEW,T,L,ACTIVE,HFUNC,W,
     1       CTRL)
*      write(10,*) 'After PSI-call. alfk= ',alfk
      K=K+1
      IF(-1.EQ.CTRL) EXIT=-3
      IF(EXIT.LT.0) GOTO 1020
      DIFF=PSIZER-PSIK
C
C     COMPUTE THE VECTOR V2 SO THAT A ONE DIMENSIONAL
C     MINIMIZATION IN R(M) CAN BE DONE
C
      CALL LINC2(M,N,V1,FNEW,F,ALFK,H,HNEW,T,ACTIVE,W,INACT,Q,L,V2)
C
C     SET XMIN = THE BEST OF THE POINTS 0 AND ALF0
C
      IF(DIFF.GE.0.0D0) XMIN=ALFK
      IF(DIFF.LT.0.0D0) XMIN=0.0D0
C
C     MINIMIZE IN R(M). USE TWO POINTS @D 0 AND ALF0
C     NEW SUGGESTION OF STEPLENGTH IS ALFKP1
C     PK IS THE VALUE OF THE APPROXIMATING FUNCTION AT ALFKP1
C
      CALL MINRM(F,V1,V2,MPL,ALFMIN,ALFMAX,XMIN,ALFKP1,PK,BETA,PBETA)
*      write(10,*) 'After MINRM-call. alfkp1= ',alfkp1
      IF(ALFKP1.EQ.BETA) GOTO 20
      IF(PK.LE.PBETA) GOTO 20
      IF(BETA.GT.ALFK) GOTO 20
      ALFKP1=BETA
      PK=PBETA
   20 CONTINUE
      ALFKM1=0.0D0
      PSIKM1=PSIZER
      CALL UPDATE(ALFKM2,PSIKM2,ALFKM1,PSIKM1,ALFK,PSIK,ALFKP1)
C
C     TEST TERMINATION CONDITION AT ALPHA = ALF0
C
*      write(10,*) 'diff,tau,dpsize,alfkm1,psikm1,gamma,psizer='
*      write(10,*) diff,tau,dpsize,alfkm1,psikm1,gamma,psizer
      IF(.NOT.((-DIFF.LE.TAU*DPSIZE*ALFKM1) .OR.
     9  (PSIKM1.LT.GAMMA*PSIZER) )) GOTO 100
*      write(10,*) 'Armijo satisfied at alf0'
C
C     TERMINATION CONDITION SATISFIED AT ALPHA = ALF0
C
   30 CONTINUE
      DIFF=PSIZER-PSIK
C
C     CHECK IF ESSENTIAL REDUCTION IS LIKELY
C
      CALL REDC(ALFKM1,PSIKM1,ALFK,PK,DIFF,ETA,XOLD,P,F,
     3  G,FNEW,M,N,FFUNC,H,HNEW,HFUNC,T,L,ACTIVE,W,K,PSIK,REDUCE)
      IF(K.LT.(-10)) GOTO 1030
      IF(.NOT.REDUCE) GOTO 1000
*      write(10,*) 'Essential reduction is likely'
C
C     THE VALUE OF THE OBJECTIVE FUNCTION CAN MOST LIKELY BE REDUCED
C
C     MINIMIZE IN R(N). USE THREE POINTS@D ALFKM2,ALFKM1,ALFK
C     NEW SUGGESTION OF THE STEPLENGTH IS ALFKP1
C     PK IS THE VALUE OF THE APPROXIMATING FUNCTION AT ALFKP1
C
      CALL MINRN(ALFK,PSIK,ALFKM1,PSIKM1,ALFKM2,PSIKM2,ALFMIN,
     4   ALFMAX,PMAX,DRELPR,ALFKP1,PK)
      CALL UPDATE(ALFKM2,PSIKM2,ALFKM1,PSIKM1,ALFK,PSIK,ALFKP1)
      GOTO 30
  100 CONTINUE
C
C     TERMINATION CONDITION NOT SATISFIED AT ALPHA = ALF0
C
C     COMPUTE PSIK=PSI(ALF1)
C
      CTRL=-1
      PSIK=PSI(XOLD,P,N,ALFK,G,FNEW,M,FFUNC,HNEW,T,L,ACTIVE,HFUNC,W,
     1        CTRL)
      IF(CTRL.LT.(-10)) K=CTRL
      IF(K.LT.0) GOTO 1030
C
C     TEST TERMINATION CONDITION AT ALPHA = ALF1
C
      DIFF=PSIZER-PSIK
      IF(.NOT.((-DIFF.LE.TAU*DPSIZE*ALFK) .OR.
     1  (PSIK.LT.GAMMA*PSIZER)  )) GOTO 200
C
C
C     TERMINATION CONDITION SATISFIED AT ALPHA = ALF1
C
C     CHECK IF ALF0 IS SOMEWHAT GOOD
C
      IF(PSIZER.GT.PSIKM1) GOTO 120
C
C     MINIMIZE IN R(M). USE TWO POINTS@D 0 AND ALF1
C     NEW SUGGESTION OF STEPLENGTH IS ALFKP1
C     PK IS THE VALUE OF THE APPROXIMATING FUNCTION AT ALFKP1
C
      XMIN=ALFK
      CALL CONCAT(FNEW,M,HNEW,ACTIVE,T,INACT,Q,W)
      DO 110 I=1,MPL
      V2(I)=((FNEW(I)-F(I))/ALFK-V1(I))/ALFK
  110 CONTINUE
      CALL MINRM(F,V1,V2,MPL,ALFMIN,ALFMAX,XMIN,ALFKP1,PK,BETA,PBETA)
      IF(ALFKP1.EQ.BETA) GOTO 115
      IF(PK.LE.PBETA) GOTO 115
      IF(BETA.GT.ALFK) GOTO 115
      ALFKP1=BETA
      PK=PBETA
  115 CONTINUE
      ALFKM1=0.0D0
      PSIKM1=PSIZER
      GOTO 130
  120 CONTINUE
C
C     MINIMIZE IN R(N). USE THREE POINTS  0,ALF0 AND ALF1
C     NEW SUGGESTION OF THE STEPLENGTH IS ALFKP1
C     PK IS THE VALUE OF THE APPROXIMATING FUNCTION AT ALFKP1
C
      CALL MINRN(ALFK,PSIK,ALFKM1,PSIKM1,ALFKM2,PSIKM2,ALFMIN,
     5  ALFMAX,PMAX,DRELPR,ALFKP1,PK)
  130 CONTINUE
      K=K+1
  140 CONTINUE
      DIFF=PSIZER-PSIK
      CALL UPDATE(ALFKM2,PSIKM2,ALFKM1,PSIKM1,ALFK,PSIK,ALFKP1)
C
C     CHECK IF ESSENTIAL REDUCTION IS LIKELY
C
      CALL REDC(ALFKM1,PSIKM1,ALFK,PK,DIFF,ETA,XOLD,P,F,
     6  G,FNEW,M,N,FFUNC,H,HNEW,HFUNC,T,L,ACTIVE,W,K,PSIK,REDUCE)
      IF(K.LT.(-10)) GOTO 1030
      IF(.NOT.REDUCE) GOTO 1000
C
C     MINIMIZE IN R(N). USE THREE POINTS@D ALFKM2,ALFKM1 AND ALFK
C     NEW SUGGESTION OF STEPLENGTH IS ALFKP1
C     PK IS THE VALUE OF THE APPROXIMATING FUNCTION AT ALFKP1
C
      CALL MINRN(ALFK,PSIK,ALFKM1,PSIKM1,ALFKM2,PSIKM2,ALFMIN,
     7  ALFMAX,PMAX,DRELPR,ALFKP1,PK)
      GOTO 140
  200 CONTINUE
C
C     TAKE A PURE GOLDSTEIN-ARMIJO STEP
C
      K=K+1
      CALL GAC(XOLD,P,F,M,N,FFUNC,HFUNC,H,ACTIVE,T,L,W,K,ALFMIN,EXIT,
     8  G,FNEW,PSIZER,DPSIZE,ALFK,PSIK,TAU,PMAX,DRELPR)
      IF(K.LT.(-10)) GOTO 1030
      IF(-2.EQ.EXIT) CALL CHDER(DPSIZE,PSIZER,XOLD,P,M,N,FFUNC,ACTIVE,
     9             T,W,L,HFUNC,K,EXIT,G,FNEW,HNEW,ALFK,PSIK)
      IF(K.LT.(-10)) GOTO 1030
      ALFKM1=ALFK
      PSIKM1=PSIK
 1000 CONTINUE
*      write(10,*) 'Just after 1000 continue'
C
C     COMPUTE THE NEW POINT AND THE DIFFERENCE II XOLD-XNEW II
C
      DIFF=0.0D0
      DO 1010 I=1,N
      XEL=ALFKM1*P(I)
      XOLD(I)=XOLD(I)+XEL
      G(I)=XEL
 1010 CONTINUE
      XDIFF=DNRM2(N,G,1)
 1020 CONTINUE
      ALPHA=ALFKM1
      PSIALF=PSIKM1
      EVAL=K
      RETURN
 1030 CONTINUE
C
C     A USER STOP INDICATOR IS DETECTED
C
      EXIT=K
      RETURN
      END
CCONCAT
      SUBROUTINE CONCAT(F,M,H,ACTIVE,T,INACT,Q,W)
      INTEGER T,Q
      DOUBLE PRECISION
     *     F(M),H(1),W(1)
      INTEGER ACTIVE(1),INACT(1)
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K
      IF(T.EQ.0) GOTO 20
      DO 10 I=1,T
      J=M+I
      K=ACTIVE(I)
      F(J)=DSQRT(W(K))*H(K)
   10 CONTINUE
   20 CONTINUE
      IF(Q.LE.0) RETURN
      DO 30 I=1,Q
           J=M+T+I
           K=INACT(I)
           F(J)=0.0D0
           IF(H(K).LE. 0.0D0) F(J)=DSQRT(W(K))*H(K)
   30 CONTINUE
      RETURN
      END
CLINC2
      SUBROUTINE LINC2(M,N,V1,FNEW,F,ALFK,H,HNEW,T,
     1  ACTIVE,W,INACT,Q,L,V2)
      INTEGER M,N,T,Q,L
      INTEGER ACTIVE(1),INACT(1)
      DOUBLE PRECISION
     *     ALFK,W(1)
      DOUBLE PRECISION
     *     FNEW(1),F(1),H(1),HNEW(1),V1(1),V2(1)
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K,MPI,MPL
      CALL CONCAT(F,M,H,ACTIVE,T,INACT,Q,W)
      CALL CONCAT(FNEW,M,HNEW,ACTIVE,T,INACT,Q,W)
      IF(T.LE.0) GOTO 20
      DO 10 I=1,T
           MPI=M+I
           J=ACTIVE(I)
           V1(MPI)=DSQRT(W(J))*V1(MPI)
   10 CONTINUE
   20 CONTINUE
      IF(Q.LE.0) GOTO 40
      DO 30 I=1,Q
           MPI=M+T+I
           K=INACT(I)
           IF(H(K).LE. 0.0D0) V1(MPI)=DSQRT(W(K))*V1(MPI)
           IF(H(K).GT. 0.0D0) V1(MPI)=0.0D0
   30 CONTINUE
   40 CONTINUE
      MPL=M+L
      DO 60 I=1,MPL
           V2(I)=((FNEW(I)-F(I))/ALFK-V1(I))/ALFK
   60 CONTINUE
      RETURN
      END
CREDC
      SUBROUTINE REDC(ALF,PSIALF,ALFK,PK,DIFF,ETA,XOLD,P,F,XNEW,
     1  FNEW,M,N,FFUNC,H,HNEW,HFUNC,T,L,ACTIVE,W,K,PSIK,REDUCE)
      EXTERNAL FFUNC,HFUNC
      INTEGER M,N,K,T,L
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     XOLD(N),P(N),F(M),XNEW(N),FNEW(M),H(1),HNEW(1),W(1)
      DOUBLE PRECISION
     *     ALF,PSIALF,ALFK,PK,DIFF,ETA,PSIK
      LOGICAL REDUCE
C
C     INTERNAL VARIABLES
C
      INTEGER I,CTRL
      DOUBLE PRECISION
     *     DELTA,PSI
      DATA DELTA /0.2D0/
C
C     REDUCE IS SET TO TRUE IF ESSENTIAL REDUCTION IN THE
C     OBJECTIVE FUNCTION IS LIKELY
C     OTHERWISE REDUCE IS SET TO FALSE
C
      IF(PSIALF-PK.LT.ETA*DIFF) GOTO 40
      DO 10 I=1,M
      F(I)=FNEW(I)
   10 CONTINUE
      IF(L.EQ.0) GOTO 30
      DO 20 I=1,L
      H(I)=HNEW(I)
   20 CONTINUE
   30 CONTINUE
      CTRL=-1
      PSIK=PSI(XOLD,P,N,ALFK,XNEW,FNEW,M,FFUNC,HNEW,T,L,ACTIVE,
     1 HFUNC,W,CTRL)
      IF(CTRL.LT.(-10)) K=CTRL
      IF(K.LT.0) RETURN
      K=K+1
      REDUCE=.TRUE.
      IF(.NOT.((PSIALF-PSIK.LT.ETA*DIFF)  .AND.
     2   (PSIK.GT.DELTA*PSIALF))) RETURN
C
C     TERMINATE BUT CHOOSE THE BEST POINT OUT OF ALF AND ALFK
C
      IF(PSIALF.LE.PSIK) GOTO 70
      ALF=ALFK
      PSIALF=PSIK
   40 CONTINUE
      DO 50 I=1,M
      F(I)=FNEW(I)
   50 CONTINUE
      IF(L.EQ.0) GOTO 70
      DO 60 I=1,L
      H(I)=HNEW(I)
   60 CONTINUE
   70 CONTINUE
      REDUCE=.FALSE.
      RETURN
      END
CGAC
      SUBROUTINE GAC(XOLD,P,F,M,N,FFUNC,HFUNC,H,ACTIVE,T,L,W,K,ALFMIN,
     1   EXIT,XNEW,FNEW,PSI0,DPSI0,U,PSIU,TAU,PMAX,DRELPR)
      EXTERNAL FFUNC,HFUNC
      INTEGER M,N,K,T,L,EXIT
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     PSI0,DPSI0,U,PSIU,TAU,PMAX,DRELPR,ALFMIN
      DOUBLE PRECISION
     *     XOLD(N),P(N),F(M),XNEW(N),FNEW(M),H(1),W(1),PSI
C
C     THIS IS A ROUTINE FOR CONSTRAINED LEAST SQUARES PROBLEMS
C     THAT HALFES THE VALUE OF U UNTIL A GOLDSTEIN-ARMIJO
C     CONDITION IS SATISFIED OR UNTIL THE STEPLENGTH TIMES THE
C     NORM OF THE SEARCH DIRECTION IS BELOW DSQRT(REL.PREC.)
C
C     PSI(ALPHA)=0.5*(II F(XOLD+ALPHA*P) II**2+
C                SIGMA(W(I)*H (XOLD+ALPHA*P)**2)
C                  I          I
C
C     WHERE I BELONGS TO THE CURRENT WORKING SET
C     CHOOSE ALPHA=X SO THAT
C                  PSI(X)<=PSI(0)+TAU*X*DPSI(0)   (1)
C     WE KNOW THAT PSI(U)>PSI(0)+TAU*U*DPSI(0)
C     THE SIMPLEST WE CAN DO IS TO SET   U=U*0.5 AND
C     TEST IF CONDITION  (1) IS SATISFIED FOR X=U
C
C
C     INTERNAL VARIABLES
      INTEGER CTRL
      DOUBLE PRECISION
     *     PSIX,SQRREL,X
      CTRL=-1
      SQRREL=DSQRT(DRELPR)
      PSIX=PSI0
      X=U
   10 CONTINUE
      IF((PMAX*X.LT.SQRREL).OR.(X.LE.ALFMIN)) EXIT=-2
      IF(-2.EQ.EXIT) GOTO 20
      X=X*0.5D0
      PSIX=PSI(XOLD,P,N,X,XNEW,F,M,FFUNC,H,T,L,ACTIVE,HFUNC,W,CTRL)
      IF(CTRL.LT.(-10)) K=CTRL
      IF(K.LT.0) RETURN
      K=K+1
      IF(PSIX.GT.PSI0+TAU*X*DPSI0) GOTO 10
   20 CONTINUE
      U=X
      PSIU=PSIX
      RETURN
      END
CLINC1
      SUBROUTINE LINC1(P,N,ALPHA,ALFLOW,ALFUPP,ETA,TAU,
     1  GAMMA,ALFMIN,ALFMAX,ALFK,PMAX)
      INTEGER N
      DOUBLE PRECISION
     *     P(N)
      DOUBLE PRECISION
     *     ALPHA,ALFLOW,ALFUPP,ETA,TAU,GAMMA,ALFMIN,ALFMAX,
     2  ALFK,PMAX
C
C     INTERNAL VARIABLE
C
      INTEGER I
      DOUBLE PRECISION
     *    ABSP
      ETA=0.3D0
      TAU=0.25D0
      GAMMA=0.4D0
      ALFMAX=ALFUPP
      ALFMIN=ALFLOW
      ALFK=DMIN1(ALPHA,ALFMAX)
      PMAX=0.0D0
      DO 10 I=1,N
      ABSP=DABS(P(I))
      IF(ABSP.GT.PMAX)PMAX=ABSP
   10 CONTINUE
      RETURN
      END
CMINRN
      SUBROUTINE MINRN(X,FX,W,FW,V,FV,ALFMIN,ALFMAX,PMAX,DRELPR,U,PU)
      DOUBLE PRECISION
     *     X,FX,W,FW,V,FV,ALFMIN,ALFMAX,PMAX,DRELPR,U,PU
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     EPS,T1,T2,T3
      EPS=DSQRT(DRELPR)/PMAX
      U=X
      PU=FX
      IF(DABS(V-X).LT.EPS .OR. DABS(W-X).LT.EPS .OR. DABS(W-V).LT.EPS)
     1   RETURN
      CALL QUAMIN(X,FX,W,FW,V,FV,U)
      U=DMIN1(U,ALFMAX)
      U=DMAX1(U,ALFMIN)
      T1=(U-X)*(U-V)*FW/(W-X)/(W-V)
      T2=(U-W)*(U-V)*FX/(X-W)/(X-V)
      T3=(U-W)*(U-X)*FV/(V-X)/(V-W)
      PU=T1+T2+T3
      RETURN
      END
CUPDATE
      SUBROUTINE UPDATE(X,FX,W,FW,V,FV,U)
      DOUBLE PRECISION
     *     X,FX,W,FW,V,FV,U
      X=W
      FX=FW
      W=V
      FW=FV
      V=U
      RETURN
      END
CMINRM1
      SUBROUTINE MINRM1(V0,V1,V2,M,SQNV0,SQNV1,SQNV2,SCV0V1,
     1   SCV0V2,SCV1V2)
      INTEGER M
      DOUBLE PRECISION
     *     V0(M),V1(M),V2(M)
      DOUBLE PRECISION
     *     SQNV0,SQNV1,SQNV2,SCV0V1,SCV0V2,SCV1V2,DNRM2
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     SC1,SC2,SC3,V0NORM,V1NORM,V2NORM
      V0NORM=DNRM2(M,V0,1)
      V1NORM=DNRM2(M,V1,1)
      V2NORM=DNRM2(M,V2,1)
      SQNV0=V0NORM**2
      SQNV1=V1NORM**2
      SQNV2=V2NORM**2
      IF(V0NORM.NE. 0.0D0) CALL SCALV(V0,V0NORM,M)
      IF(V1NORM.NE. 0.0D0) CALL SCALV(V1,V1NORM,M)
      IF(V2NORM.NE. 0.0D0) CALL SCALV(V2,V2NORM,M)
      SC1=0.0D0
      SC2=0.0D0
      SC3=0.0D0
      DO 10 I=1,M
      SC1=SC1+V0(I)*V1(I)
      SC2=SC2+V0(I)*V2(I)
      SC3=SC3+V1(I)*V2(I)
   10 CONTINUE
      SCV0V1=SC1*V0NORM*V1NORM
      SCV0V2=SC2*V0NORM*V2NORM
      SCV1V2=SC3*V1NORM*V2NORM
      IF(V0NORM.NE. 0.0D0) CALL SCALV(V0,1.0D0/V0NORM,M)
      IF(V1NORM.NE. 0.0D0) CALL SCALV(V1,1.0D0/V1NORM,M)
      IF(V2NORM.NE. 0.0D0) CALL SCALV(V2,1.0D0/V2NORM,M)
      RETURN
      END
CMINRM2
      SUBROUTINE MINRM2(SQNV1,SQNV2,SCV0V1,SCV0V2,SCV1V2,P,Q,
     1   DELTA,A1DIV3)
      DOUBLE PRECISION
     *     SQNV1,SQNV2,SCV0V1,SCV0V2,SCV1V2,P,Q,DELTA,A1DIV3
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     A1,A2,A3
      A1=1.5D0*SCV1V2/SQNV2
      A2=0.5D0*(SQNV1+2.0D0*SCV0V2)/SQNV2
      A3=0.5D0*SCV0V1/SQNV2
      P=A2-A1*A1/3.0D0
      Q=A3-A1*A2/3.0D0+2.0D0*A1*A1*A1/27.0D0
      DELTA=(Q/2.0D0)**2+(P/3.0D0)**3
      A1DIV3=A1/3.0D0
      RETURN
      END
CMINRM
      SUBROUTINE MINRM(V0,V1,V2,M,ALFMIN,ALFMAX,XMIN,X,PX,Y,PY)
      INTEGER M
      DOUBLE PRECISION
     *     V0(M),V1(M),V2(M)
      DOUBLE PRECISION
     *     ALFMIN,ALFMAX,XMIN,X,PX,Y,PY
C
C     A SUBROUTINE WHICH FINDS THE POINT X WHERE THE FUNCTION
C     P(X)= 0.5*II V0+V1*X+V2*X**2 II**2  IS MINIMIZED.
C     V0,V1 AND V2 BELONG TO R(M) AND X IS A SCALAR
C     THE VALUES OF V0,V1 AND V2 ARE BASED ON TW0 FUNCTION
C     VALUES @D  F(0) AND F(ALPHA)
C     THE FUNCTION P(X) IS ALWAYS >=0 AND IT IS A POLYNOMIAL
C     OF 4@DTH DEGREE
C     THE MINIMUM VALUE OF P(X) IS ATTAINED AT A POINT X WHERE
C     THE FIRST DERIVATIVE OF P(X)=DP(X) IS ZERO
C     DP(X) IS A POLYNOMIAL OF 3@DRD DEGREE
C     IN CASE OF THREE ROOTS (X1<X2<X3), X2 CORRESPONDS TO A LOCAL
C     MAXIMUM. CHOOSE THE ONE (OF X1 AND X3) THAT IS AT THE SAME
C     SIDE OF THE MAXIMUM AS XMIN IS PROVIDED NO EXTRAPOLATION
C     IS DONE
C     HOWEVER,THE MINIMUM POINT X MUST LIE IN THE INTERVALL
C     (ALFMIN,ALFMAX)
C     PX IS SET TO P(X) AT THE MINIMUM POINT
C     WHERE P(X) IS THE POLYNOMIAL ABOVE
C     Y IS SET TO THE OTHER MINIMIZER OF P(X)  (IF TWO ARE DETERMINED)
C     OTHERWISE Y IS SET TO THE SAME AS X IS SET
C     PY = P(Y)
C
C
C     INTERNAL VARIABLES
C
      INTEGER K
      DOUBLE PRECISION
     *     A1DIV3,BETA,B2,B3,D,DELTA,DM,EPS,ERROR,HM,H0,P,PBISS,
     1 PPRIM,Q,SCV0V1,SCV0V2,SCV1V2,SQNV0,SQNV1,SQNV2,X0,X1,X2,X3,
     2 POL3,POL4
      DATA EPS /1.0D-4/
C
C     COMPUTE NORMS SQUARED AND SCALAR PRODUCTS
C
      CALL MINRM1(V0,V1,V2,M,SQNV0,SQNV1,SQNV2,SCV0V1,SCV0V2,SCV1V2)
      BETA=2.0D0*SCV0V2+SQNV1
      B2=3.0D0*SCV1V2
      B3=2.0D0*SQNV2
      PPRIM=POL3(SCV0V1,BETA,B2,B3,XMIN)
      PBISS=BETA+6.0D0*SCV1V2*XMIN+6.0D0*SQNV2*XMIN**2
      H0=DABS(PPRIM/PBISS)
      DM=DABS(6.0D0*SCV1V2+12.0D0*SQNV2*XMIN)+24.0D0*H0*SQNV2
C
C     DETERMINE IF DP(X)=0 SHALL BE SOLVED BY USING NEWTONS METHOD
C
      HM=DMAX1(H0,1.0D0)
      IF(PBISS.GT.20.0D0*HM*DM) GOTO 40
C
C     COMPUTE QUANTITIES P,Q,DELTA AND A1DIV3 SO THAT THE SOLUTION OF
C     X**3+A1*X**2+A2*X+A3=0    IS   X=T-A1/3
C     WHERE T SOLVES     T**3+P*T+Q=0
C
      CALL MINRM2(SQNV1,SQNV2,SCV0V1,SCV0V2,SCV1V2,P,Q,DELTA,A1DIV3)
C
C     MATHEMATICALLY WE DESTINGWISH THREE DIFFERENT CASES
C     IF DELTA>0 THEN DF(X)=0 HAS ONE REAL ROOT
C     IF DELTA=0 THEN DF(X)=0 HAS ONE SINGLE AND ONE DOUBLE REAL ROOT
C     IF DELTA<0 THEN DF(X)=0 HAS THREE DIFFERENT REAL ROOTS
C
C     IF DELTA=0 THE ONLY ROOT OF INTEREST IS THE SINGLE ONE,SO
C     NUMERICALLY WE DISTINGWISH TWO CASES ,DELTA>=0 AND
C     DELTA<0
C
      IF(DELTA.LT.0.0D0) GOTO 30
C
C     DELTA>=0 ONE INTERESTING ROOT. X
C
      CALL ONER(Q,DELTA,A1DIV3,X)
      Y=X
      GO TO 100
   30 CONTINUE
C
C     DELTA<0  TWO INTERESTING ROOTS.  Y AND Z, Y<Z
C
      CALL TWOR(P,Q,DELTA,A1DIV3,X1,X2,X3)
C
C     CHOOSE X= X1 OR X2 OR X3
C
      CALL CHOOSE(X1,X2,X3,XMIN,V0,V1,V2,M,X,Y,PY)
      GOTO 100
   40 CONTINUE
      DELTA=1.0D0
C
C     ITERATE USING NEWTONS METHOD
C
      K=0
      X0=XMIN
   50 CONTINUE
      PPRIM=POL3(SCV0V1,BETA,B2,B3,X0)
      PBISS=BETA+6.0D0*SCV1V2*X0+6.0D0*SQNV2*X0*X0
      D=-PPRIM/PBISS
      X=X0+D
      ERROR=2.0D0*DM*D*D/DABS(PBISS)
      X0=X
      K=K+1
      IF(ERROR.GT.EPS .AND. K.LT.3) GOTO 50
      Y=X
  100 CONTINUE
C
C     MAKE THE MINIMUM POINT X LIE IN THE INTERVALL
C     (ALFMIN,ALFMAX) AND EVALUATE F(X) AT THE MINIMUM POINT
C
      X=DMIN1(X,ALFMAX)
      X=DMAX1(X,ALFMIN)
      PX=POL4(V0,V1,V2,M,X)
      Y=DMIN1(Y,ALFMAX)
      Y=DMAX1(Y,ALFMIN)
      IF(DELTA.LT.0.0D0) GOTO 110
      Y=X
      PY=PX
  110 CONTINUE
      RETURN
      END
CONER
      SUBROUTINE ONER(Q,DELTA,A1DIV3,X)
      DOUBLE PRECISION
     *     Q,DELTA,A1DIV3,X
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     ARG1,ARG2,A3RD,SQD,S1,S2,T
      SQD=DSQRT(DELTA)
      ARG1=(-Q/2.0D0+SQD)
      S1=DSIGN(1.0D0,ARG1)
      ARG2=(-Q/2.0D0-SQD)
      S2=DSIGN(1.0D0,ARG2)
      A3RD=1.0D0/3.0D0
      T=S1*DABS(ARG1)**A3RD+S2*DABS(ARG2)**A3RD
      X=T-A1DIV3
      RETURN
      END
CTWOR
      SUBROUTINE TWOR(P,Q,DELTA,A1DIV3,X1,X2,X3)
      DOUBLE PRECISION
     *     P,Q,DELTA,A1DIV3,X1,X2,X3
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     EPS,FI,PI,SQD,T,TANFI
      EPS=1.0D-8
      SQD=DSQRT(-DELTA)
      IF(DABS(Q).GT. (2.0D0*EPS*SQD)) GOTO 10
      FI=DATAN(1.0D0)*2.0D0
      GOTO 20
   10 CONTINUE
      TANFI=DABS(2.0D0*SQD/Q)
      FI=DATAN(TANFI)
   20 CONTINUE
      T=2.0D0*DSQRT(-P/3.0D0)
      IF(Q.GT.0.0D0) T=-T
      X1=T*DCOS(FI/3.0D0)-A1DIV3
      PI=4.0D0*DATAN(1.0D0)
      X2=T*DCOS((FI+2.0D0*PI)/3.0D0)-A1DIV3
      X3=T*DCOS((FI+4.0D0*PI)/3.0D0)-A1DIV3
      RETURN
      END
CCHOOSE
      SUBROUTINE CHOOSE(X1,X2,X3,XMIN,V0,V1,V2,M,ROOT1,
     1    ROOT2,PROOT2)
      INTEGER M
      DOUBLE PRECISION
     *     X1,X2,X3,XMIN,ROOT1,ROOT2,PROOT2
      DOUBLE PRECISION
     *     V0(M),V1(M),V2(M)
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION
     *     X,Y,Z,POL4
      X=DMIN1(X1,X2,X3)
      Z=DMAX1(X1,X2,X3)
      IF(X1.LE.X2 .AND. X1.LE.X3) Y=DMIN1(X2,X3)
      IF(X2.LE.X1 .AND. X2.LE.X3) Y=DMIN1(X1,X3)
      IF(X3.LE.X1 .AND. X3.LE.X2) Y=DMIN1(X1,X2)
      IF(XMIN.LE.Y) ROOT1=X
      IF(XMIN.LE.Y) ROOT2=Z
      IF(XMIN.GT.Y) ROOT1=Z
      IF(XMIN.GT.Y) ROOT2=X
      PROOT2=POL4(V0,V1,V2,M,ROOT2)
      RETURN
      END
CPOL4
      DOUBLE PRECISION
     *FUNCTION POL4(V0,V1,V2,M,X)
      INTEGER M
      DOUBLE PRECISION
     *     V0(M),V1(M),V2(M)
      DOUBLE PRECISION
     *     X
C
C     INTERNAL VARIABLES
C
      INTEGER I
      DOUBLE PRECISION
     *     P,S
      S=0.0D0
      DO 10 I=1,M
      P=V0(I)+X*(V1(I)+V2(I)*X)
      S=S+P*P
   10 CONTINUE
      POL4=0.5D0*S
      RETURN
      END
CPOL3
      DOUBLE PRECISION
     *FUNCTION POL3(A0,A1,A2,A3,X)
      DOUBLE PRECISION
     * A0,A1,A2,A3,X
      POL3=A0+X*(A1+X*(A2+A3*X))
      RETURN
      END
CPSI
      DOUBLE PRECISION
     *FUNCTION PSI(XOLD,P,N,ALFK,XNEW,FNEW,M,FFUNC,HNEW,T,L,ACTIVE,
     1 HFUNC,W,CTRL)
      INTEGER N,M,T,L,CTRL
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     ALFK
      DOUBLE PRECISION
     *     XOLD(N),P(N),XNEW(N),FNEW(M),HNEW(1),W(1)
C
C     INTERNAL VARIABLES
C
      INTEGER I,FCTRL,HCTRL
      DOUBLE PRECISION
     *     DUMMY,DNRM2,HSUM
      DO 10 I=1,N
         XNEW(I)=XOLD(I)+ALFK*P(I)
   10 CONTINUE
      FCTRL=CTRL
      CALL FFUNC(XNEW,N,FNEW,M,FCTRL,DUMMY,1)
      HCTRL=CTRL
      CALL HFUNC(XNEW,N,HNEW,L,HCTRL,DUMMY,1)
      IF(CTRL.EQ.1) GOTO 20
C
C     CTRL = -1 ON ENTRY
C
      IF((-1.EQ.FCTRL).AND.(-1.EQ.HCTRL))PSI=0.5D0*(DNRM2(M,FNEW,1)**2
     1                                  +HSUM(ACTIVE,T,HNEW,W,L))
      IF((FCTRL.LT.(-10)).OR.(HCTRL.LT.(-10))) CTRL=MIN0(FCTRL,HCTRL)
      RETURN
   20 CONTINUE
      IF((FCTRL.EQ.1).AND.(HCTRL.EQ.1)) PSI=0.5D0*(DNRM2(M,FNEW,1)**2
     1                             +HSUM(ACTIVE,T,HNEW,W,L))
      IF((FCTRL.NE.1).OR.(HCTRL.NE.1)) CTRL=-1
      RETURN
      END
CPERMIN
      SUBROUTINE PERMIN(P,N)
      INTEGER P(N)
C
C     INITIATE A PERMUTATION RECORD
C
C     INTERNAL VARIABLE
C
      INTEGER I
      DO 10 I=1,N
      P(I)=I
   10 CONTINUE
      RETURN
      END
CHESSF
      SUBROUTINE HESSF(FFUNC,B,MDB,X,N,V,F1,F2,M,IER)
      INTEGER MDB,N,M,IER
      DOUBLE PRECISION
     *     B(MDB,N),X(N),V(M),F1(M),F2(M)
C
C     COMPUTE THE N*N MATRIX             M
C                                 B @D= SIGMA(V *G )
C                                       K=1   K  K
C     WHERE G   IS THE HESSIAN OF F (X)
C            K                     K
C
C
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER J,K,L,CTRL
      DOUBLE PRECISION
     *     ATHIRD,EPS1,EPS2,EPSK,EPSJ,XK,XJ,DUMMY,SUM
      IER=0
      CTRL=-1
      ATHIRD=1.0D0/3.0D0
      EPS2=DRELPR**ATHIRD
      EPS1=EPS2
      DO 30 K=1,N
           XK=X(K)
           EPSK=DMAX1(DABS(XK),1.0D0)*EPS2
           DO 20 J=1,K
                XJ=X(J)
                EPSJ=DMAX1(DABS(XJ),1.0D0)*EPS1
                X(K)=XK+EPSK
                X(J)=X(J)+EPSJ
                CALL FFUNC(X,N,F1,M,CTRL,DUMMY,1)
                IF(CTRL.LT.(-10)) GOTO 40
                X(K)=XK
                X(J)=XJ
                X(K)=XK+EPSK
                X(J)=X(J)-EPSJ
                CALL FFUNC(X,N,F2,M,CTRL,DUMMY,1)
                IF(CTRL.LT.(-10)) GOTO 40
                CALL PLUS(F1,-1.0D0,F2,M)
                X(K)=XK
                X(J)=XJ
                X(K)=XK-EPSK
                X(J)=X(J)+EPSJ
                CALL FFUNC(X,N,F2,M,CTRL,DUMMY,1)
                IF(CTRL.LT.(-10)) GOTO 40
                CALL PLUS(F1,-1.0D0,F2,M)
                X(K)=XK
                X(J)=XJ
                X(K)=XK-EPSK
                X(J)=X(J)-EPSJ
                CALL FFUNC(X,N,F2,M,CTRL,DUMMY,1)
                IF(CTRL.LT.(-10)) GOTO 40
                CALL PLUS(F1,1.0D0,F2,M)
                X(K)=XK
                X(J)=XJ
                SUM=0.0D0
                DO 10 L=1,M
                     SUM=SUM+F1(L)/(4.0D0*EPSK*EPSJ)*V(L)
   10           CONTINUE
                B(K,J)=SUM
                IF(K.EQ.J) GOTO 20
                B(J,K)=SUM
   20      CONTINUE
   30 CONTINUE
      RETURN
C
C     A USER STOP INDICATOR IS DETECTED
C
   40 CONTINUE
      IER=CTRL
      RETURN
      END
CHESSH
      SUBROUTINE HESSH(HFUNC,B,MDB,X,N,V,ACTIVE,T,F1,F2,M,IER)
      INTEGER MDB,N,T,M,IER
      INTEGER ACTIVE(T)
      DOUBLE PRECISION
     *     B(MDB,N),X(N),V(T),F1(M),F2(M)
C
C     COMPUTE THE N*N MATRIX             T
C                            B =  B -  SIGMA(V *G )
C                                       K=1   K  K
C     WHERE G   IS THE HESSIAN OF H (X) AND K IN CURRENT WORKING SET
C            K                     K
C
C
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K,L,CTRL
      DOUBLE PRECISION
     *     ATHIRD,EPS1,EPS2,EPSK,EPSJ,XK,XJ,DUMMY,SUM
      IER=0
      CTRL=-1
      ATHIRD=1.0D0/3.0D0
      EPS2=DRELPR**ATHIRD
      EPS1=EPS2
      DO 30 K=1,N
           XK=X(K)
           EPSK=DMAX1(DABS(XK),1.0D0)*EPS2
           DO 20 J=1,K
                DO 5 I=1,T
                    F1(I)=0.0D0
    5           CONTINUE
                XJ=X(J)
                EPSJ=DMAX1(DABS(XJ),1.0D0)*EPS1
                X(K)=XK+EPSK
                X(J)=X(J)+EPSJ
                CALL HFUNC(X,N,F2,M,CTRL,DUMMY,1)
                IF(CTRL.LT.(-10)) GOTO 40
                CALL PRESS(F2,ACTIVE,T,1.0D0,F1)
                X(K)=XK
                X(J)=XJ
                X(K)=XK+EPSK
                X(J)=X(J)-EPSJ
                CALL HFUNC(X,N,F2,M,CTRL,DUMMY,1)
                IF(CTRL.LT.(-10)) GOTO 40
                CALL PRESS(F2,ACTIVE,T,-1.0D0,F1)
                X(K)=XK
                X(J)=XJ
                X(K)=XK-EPSK
                X(J)=X(J)+EPSJ
                CALL HFUNC(X,N,F2,M,CTRL,DUMMY,1)
                IF(CTRL.LT.(-10)) GOTO 40
                CALL PRESS(F2,ACTIVE,T,-1.0D0,F1)
                X(K)=XK
                X(J)=XJ
                X(K)=XK-EPSK
                X(J)=X(J)-EPSJ
                CALL HFUNC(X,N,F2,M,CTRL,DUMMY,1)
                IF(CTRL.LT.(-10)) GOTO 40
                CALL PRESS(F2,ACTIVE,T,1.0D0,F1)
                X(K)=XK
                X(J)=XJ
                SUM=0.0D0
                DO 10 L=1,T
                     SUM=SUM+F1(L)/(4.0D0*EPSK*EPSJ)*V(L)
   10           CONTINUE
                B(K,J)=B(K,J)-SUM
                IF(K.EQ.J) GOTO 20
                B(J,K)=B(K,J)
   20      CONTINUE
   30 CONTINUE
      RETURN
C
C     A USER STOP INDICATOR IS DETECTED
C
   40 CONTINUE
      IER=CTRL
      RETURN
      END
CPRESS
      SUBROUTINE PRESS(F2,ACTIVE,T,FACTOR,F1)
      INTEGER T
      INTEGER ACTIVE(T)
      DOUBLE PRECISION
     *     FACTOR
      DOUBLE PRECISION
     *     F2(1),F1(1)
C
C     COMPUTE F1(I)@D= F1(I)+FACTOR*F2(K)
C     WHERE K BELONGS TO THE CURRENT WORKING SET
C
C     INTERNAL VARIABLES
C
      INTEGER I,K
      DO 10 I=1,T
           K=ACTIVE(I)
           F1(I)=F1(I)+FACTOR*F2(K)
   10 CONTINUE
      RETURN
      END
CPLUS
      SUBROUTINE PLUS(F1,FACTOR,F2,M)
      INTEGER M
      DOUBLE PRECISION
     *     FACTOR
      DOUBLE PRECISION
     *     F1(M),F2(M)
C
C     COMPUTE  F1@D= FACTOR*F2+F1
C
C     INTERNAL VARIABLE
C
      INTEGER I
      DO 10 I=1,M
           F1(I)=F1(I)+FACTOR*F2(I)
   10 CONTINUE
      RETURN
      END
CCHDER
      SUBROUTINE CHDER(DPSIZE,PSIZER,XOLD,P,M,N,FFUNC,ACTIVE,T,W,L,
     1 HFUNC,K,EXIT,XNEW,FNEW,HNEW,ALFK,PSIK)
      INTEGER M,N,K,T,L,EXIT
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     DPSIZE,PSIZER,ALFK,PSIK
      DOUBLE PRECISION
     *     XOLD(N),P(N),W(1),XNEW(N),FNEW(M),HNEW(1),PSI
      EXTERNAL FFUNC,HFUNC
C
C     MAKE A CONSISTENCY CHECK OF THE DERIVATIVE APPROXIMATION
C     BASED ON THE JACOBIAN MATRIX
C     THE FUNCTION UNDER CONSERN IS
C       PSI(ALPHA) = F(XOLD+ALPHA*P)+SIGMA(W(I)*H (XOLD+ALPHA*P)**2)
C                                      I         I
C
C     ON ENTRY
C
C     DPSIZE THE DERIVATIVE OF PSI(ALPHA) AT ALPHA=0 COMPUTED
C            BY P(TR)*G(XOLD), WHERE G(X) IS THE GRADIENT OF PSI(X)
C     PSIZER PSI(0)
C     XOLD() CONTAINS THE STARTING POINT OF THE LINESEARCH
C     P()    CONTAINS THE SEARCH DIRECTION
C     M      NO. OF RESIDUALS IN THE VECTOR VALUED FUNCTION F(X)
C     N      NO. OF UNKNOWNS
C     FFUNC  SUBROUTINE NAME FOR USER WRITTEN ROUTINE WHICH EVALUATES
C            THE RESIDUALS
C     ACTIVE() CONTAINS INDECES FOR CONSTRAINTS IN CURRENT WORKING SET
C     T      NO. OF CONSTRAINTS IN CURRENT WORKING SET
C     W()    CONTAINS PENALTY WEIGHTS CORRESPONDING TO CONSTRAINTS
C     L      TOTAL NO. OF CONSTRAINTS
C     HFUNC  SUBROUTINE NAME FOR USER WRITTEN ROUTINE WHICH EVALUATES
C            THE CONSTRAINTS
C     K      NO. OF FUNCTION EVALUATIONS DONE SO FAR IN THE LINESEARCH
C     EXIT   =-2
C     ALFK   THE ALPHA VALUE FOR WHICH THE DIFFERENCES ARE COMPUTED
C     PSIK   PSI(ALFK)
C
C     ON RETURN
C
C     K      INCREASED BY 1 OR SET A VALUE <-10 TO
C            INDICATE A USER STOP
C     EXIT   SET = -1 IF INCONSISTENCY IS DETECTED
C
C     WORKING AREAS
C
C     XNEW() OF DIMENSION N
C     FNEW() OF DIMENSION M+L
C     HNEW() OF DIMENSION L
C
C     INTERNAL VARIABLES
C
      INTEGER CTRL
      DOUBLE PRECISION
     *     DPSIFO,DPSIBA,DPSICE,MAXDIF,PSIMK
C
C     COMPUTE PSI(-ALFK)
C
      CTRL=-1
      PSIMK=PSI(XOLD,P,N,-ALFK,XNEW,FNEW,M,FFUNC,HNEW,T,L,ACTIVE,
     2        HFUNC,W,CTRL)
      IF(CTRL.LT.(-10)) K=CTRL
      IF(K.LT.0) RETURN
      K=K+1
C
C     COMPUTE APPROXIMATIONS OF THE DERIVATIVE BY USING FORWARD,
C     BACKWARD AND CENTRAL DIFFERENCES
C
      DPSIFO=(PSIK-PSIZER)/ALFK
      DPSIBA=(PSIZER-PSIMK)/ALFK
      DPSICE=(PSIK-PSIMK)/2.0D0/ALFK
      MAXDIF=DABS(DPSIFO-DPSIBA)
      MAXDIF=DMAX1(MAXDIF,DABS(DPSIFO-DPSICE))
      MAXDIF=DMAX1(MAXDIF,DABS(DPSIBA-DPSICE))
      IF((DABS(DPSIFO-DPSIZE).GT.MAXDIF).AND.
     3      (DABS(DPSICE-DPSIZE).GT.MAXDIF)) EXIT=-1
      RETURN
      END
CPREGN
      SUBROUTINE PREGN(S,SN,B,BN,MINDIM,PRANK,DIM)
      INTEGER MINDIM,PRANK,DIM
      DOUBLE PRECISION
     *     SN,BN
      DOUBLE PRECISION
     *     S(1),B(1)
C
C     GN-STEP IN PREVIOUS STEP
C     TAKE DIM AS THE LARGEST K (MINDIM<=K<=PRANK-1) FOR WHICH
C     S(K)<SMAX*SN AND B(K)>RMIN*BN
C     IF NO SUCH K EXISTS TAKE DIM=PRANK-1 PROVIDED (PRANK-1)>=MINDIM
C
C     INTERNAL VARIABLES
C
      INTEGER I,K,M1
      DOUBLE PRECISION
     *     RMIN,SMAX
      DATA SMAX,RMIN /0.2D0,0.5D0/
      M1=PRANK-1
      K=MINDIM
      IF(MINDIM.GT.M1) GOTO 20
      DO 10 I=MINDIM,M1
           K=M1-I+MINDIM
           IF((S(K).LT.SMAX*SN).AND.(B(K).GT.RMIN*BN)) GOTO 20
   10 CONTINUE
      DIM=MAX0(MINDIM,PRANK-1)
      RETURN
   20 CONTINUE
      DIM=K
      RETURN
      END
CPRESUB
      SUBROUTINE PRESUB(S,B,BN,RABS,PRANK,KM1RNK,PGRESS,PRELIN,
     1 ASPREV,ALFKM1,DIM)
      INTEGER PRANK,DIM,KM1RNK
      DOUBLE PRECISION
     *     BN,RABS,PGRESS,PRELIN,ASPREV,ALFKM1
      DOUBLE PRECISION
     *     S(1),B(1)
C
C     SUBSPACE MINIMIZATION IN LATEST STEP
C
C     INTERNAL VARIABLES
C
      INTEGER I,I1
      DOUBLE PRECISION
     *     STEPB,PGB1,PGB2,PREDB,RLENB,C2
      DATA STEPB,PGB1,PGB2,PREDB,RLENB,C2
     1  /0.2D0,0.3D0,0.1D0,0.7D0,2.0D0,100.0D0/
C
C     IF THE LATEST STEP WAS FAIRLY GOOD THE DIMENSION MUST NOT
C     BE DECREASED
C
      IF((ALFKM1.GE.STEPB).OR.(PGRESS.GT.PGB1*PRELIN**2).OR.
     1  (PGRESS.GT.PGB2*ASPREV**2) ) GOTO 10
C
C     A BAD STEP
C
      DIM=MAX0(1,KM1RNK-1)
      IF((KM1RNK.GT.1).AND.(B(DIM).GT.RABS*BN)) RETURN
   10 CONTINUE
      DIM=KM1RNK
      IF((B(DIM).GT.PREDB*BN).AND.(RLENB*S(DIM).LT.S(DIM+1))) RETURN
C
C     TEST POSSIBLE RANK DEFICIENCY
C
      IF(C2*S(DIM).LT.S(DIM+1)) RETURN
      I1=KM1RNK+1
      DO 20 I=I1,PRANK
           DIM=I
           IF(B(I).GT.PREDB*BN) GOTO 30
   20 CONTINUE
   30 CONTINUE
      RETURN
      END
CJACDIF
      SUBROUTINE JACDIF(X,N,F,M,FFUNC,C,MDC,W1,IER)
      INTEGER N,M,MDC,IER
      DOUBLE PRECISION
     *     X(N),F(M),C(MDC,N),W1(M)
C
C     COMPUTE THE M*N JACOBIAN OF F(X) AT THE CURRENT POINT BY
C     USING FORWARD DIFFERENCES
C
C     ON ENTRY
C
C     X()  CONTAINS THE CURRENT POINT
C     N    IS THE LENGTH OF THE ARRAY X
C     F()  CONTAINS THE VECTOR OF RESIDUALS AT CURRENT POINT
C     M    IS THE LENGTH OF THE ARRAYS F AND W1
C     MDC  IS THE LEADING DIMENSION OF THE ARRAY C
C
C     ON RETURN
C
C     C(,) CONTAINS THE APPROXIMATED JACOBIAN IN THE M*N UPPER PART
C     IER  A VALUE < -10 TO INDICATE A POSSIBLE USER STOP
C          UNCHANGED OTHERWISE
C
C
C     COMMON VARIABLES CONTAINING MACHINE DEPENDENT CONSTANTS
C     DRELPR = DOUBLE RELATIVE PRECISION
C
      DOUBLE PRECISION
     *    DRELPR
      COMMON /MACHIN/ DRELPR
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,CTRL
      DOUBLE PRECISION
     *     DELTA,XTEMP,DELTAJ
      DELTA=DSQRT(DRELPR)
      DO 20 J=1,N
           XTEMP=X(J)
           DELTAJ=DMAX1(DABS(XTEMP),1.0D0)*DELTA
           X(J)=XTEMP+DELTAJ
           CTRL=-1
           CALL FFUNC(X,N,W1,M,CTRL,C,MDC)
           IF(CTRL.LT.(-10)) GOTO 30
           DO 10 I=1,M
                C(I,J)=(W1(I)-F(I))/DELTAJ
   10      CONTINUE
           X(J)=XTEMP
   20 CONTINUE
      RETURN
C
C     A USER STOP INDICATOR IS DETECTED
C
   30 CONTINUE
      IER=CTRL
      RETURN
      END
CLSOLVE
      SUBROUTINE LSOLVE(NDIM,N,A,B)
C
C LSOLVE SOLVES THE LOWER TRIANGULAR SYSTEM AX = B
C
      DOUBLE PRECISION
     *     A(NDIM,1),B(1)
C
C     INTERNAL VARIABLES
C
      INTEGER J,JM,K
      DOUBLE PRECISION
     *     S
      IF(N.LE.0) RETURN
      B(1)=B(1)/A(1,1)
      IF(N.EQ.1) RETURN
      DO 20 J=2,N
      S=B(J)
      JM=J-1
           DO 10 K=1,JM
           S=S-A(J,K)*B(K)
   10      CONTINUE
      B(J)=S/A(J,J)
   20 CONTINUE
      RETURN
      END
CUSOLVE
      SUBROUTINE USOLVE(NDIM,N,A,B)
      DOUBLE PRECISION
     *     A(NDIM,1),B(1)
C
C USOLVE SOLVES THE UPPER TRIANGULAR SYSTEM AX=B
C
C     INTERNAL VARIABLES
C
      INTEGER J,JC,JP,K,NM
      DOUBLE PRECISION
     *     S
      IF(N.LE.0) RETURN
      B(N)=B(N)/A(N,N)
      IF(N.EQ.1) RETURN
      NM=N-1
      DO 20 JC=1,NM
      J=N-JC
      S=B(J)
      JP=J+1
           DO 10 K=JP,N
           S=S-A(J,K)*B(K)
   10      CONTINUE
      B(J)=S/A(J,J)
   20 CONTINUE
      RETURN
      END
CYCOMP
      SUBROUTINE YCOMP(KP1,KQ,D,C1,MDC,X1)
      DOUBLE PRECISION
     *     D(KQ),C1(MDC,1),X1(1)
C
C THIS ROUTINE COMPUTES
C    D = D - C1*X1
C
C     INTERNAL VARIABLES
C
      INTEGER J,K
      DOUBLE PRECISION
     *     SUM
      IF(KQ.LE.0 .OR. KP1.LE.0) RETURN
      DO 20 J=1,KQ
      SUM=0.0D0
           DO 10 K=1,KP1
           SUM=SUM+C1(J,K)*X1(K)
   10      CONTINUE
      D(J)=D(J)-SUM
   20 CONTINUE
      RETURN
      END
CJTRJ
      SUBROUTINE JTRJ(GMAT,MDG,N,W)
      INTEGER MDG,N
      DOUBLE PRECISION
     *     GMAT(MDG,N),W(N)
C
C                                        T
C     FORM THE N*N SYMMETRIC MATRIX  GMAT *GMAT   AND STORE
C     IN GMAT
C                                      T
C     FIRST FORM THE LOWER PART OF GMAT *GMAT  AND STORE IN THE
C     LOWER PART OF GMAT
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K
      DOUBLE PRECISION
     *     SUM
      DO 40 J=1,N
           DO 10 I=1,N
                W(I)=GMAT(I,J)
   10      CONTINUE
           DO 30 K=J,N
                SUM=0.0D0
                DO 20 I=1,N
                     SUM=SUM+GMAT(I,K)*W(I)
   20           CONTINUE
                GMAT(K,J)=SUM
   30      CONTINUE
   40 CONTINUE
C
C     MOVE THE LOWER PART OF GMAT TO THE UPPER PART OF GMAT
C
      IF(N.EQ.1) RETURN
      DO 60 I=2,N
           K=I-1
           DO 50 J=1,K
                GMAT(J,I)=GMAT(I,J)
   50      CONTINUE
   60 CONTINUE
      RETURN
      END
CNEWTON
      SUBROUTINE NEWTON(FFUNC,HFUNC,X,N,C,MDC,M,RANKC2,F,P3,D3,
     1 V,A,MDA,ACTIVE,T,RANKA,D1,P1,P2,D2,B,H,L,MDF,PIVOT,GMAT,MDG,
     2 DX,EVAL,ERROR,FMAT,D,V1,V2     )
      INTEGER N,MDC,M,RANKC2,MDA,T,RANKA,L,MDF,MDG,EVAL,ERROR
      INTEGER ACTIVE(1),P3(1),P1(1),P2(1)
      DOUBLE PRECISION
     *     X(N),C(MDC,N),F(M),D3(1),V(1),A(MDA,N),D1(1),D2(1),
     1 B(1),H(1),PIVOT(1),GMAT(MDG,N),DX(N),FMAT(MDF,N),
     2 D(M),V1(M),V2(M)
      EXTERNAL FFUNC,HFUNC
C
C     COMPUTE THE SEARCH DIRECTION (DX) BY MINIMIZING
C           T   T                         T   T
C     0.5*DX *(C *C - FMAT + GMAT)*DX + (C *F) *DX
C     S.T.
C           (L@D0)*DY = B1   IF RANK(A)=T
C           (R@D0)*DY = B2   IF RANK(A)<T
C     WHERE
C                 T                T
C         (L@D0)=P1 *A*Q1     B1=-P1 *H    DX=Q1*DY
C
C                 T                  T
C         (R@D0)=Q2 *(L@D0)*P2    B2=Q2 *B1 DX=Q1*P2*DY
C     AND
C                 T                        M
C        FMAT = SIGMA(V(I)*K )    GMAT = SIGMA(F(I)*G )
C                I=1        I             I=1        I
C
C     K  = HESSIAN OF CONSTRAINT H  WHERE I IS IN CURRENT WORKING SET
C      I                          I
C
C     G  = HESSIAN OF RESIDUAL NUMBER I
C      I
C
C     MOREOVER     (C1@DC2)=C*Q1*P2
C
C                  (U)    T
C                  (0)= Q3 *C2*P3
C
C     ON ENTRY@D
C
C     FFUNC   SUBROUTINE NAME-USED TO EVALUATE RESIDUALS
C     HFUNC   SUBROUTINE NAME-USED TO EVALUATE CONSTRAINTS
C     X()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINING THE CURRENT POINT
C     N       INTEGER SCALAR CONTAINING NUMBER OF PARAMETERS
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*N
C             CONTAINING  (C1@DU)  AND INFO. TO FORM Q3
C                         (   0)
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     RANKC2  INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX C2
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE VALUE OF THE RESIDUALS AT X
C     P3()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION N-RANKA
C             REPRESENTING PERMUTATION MATRIX P3
C     D3()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N-RANKA
C             CONTAINING INFO. TO FORM Q3
C     V()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING ESTIMATES OF LAGRANGE MULTIPLIERS
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING MATRIX L AND INFO. TO FORM Q1
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     ACTIVE()INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING INDECES FOR THE CONSTRAINTS IN CURRENT
C             WORKING SET
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS IN
C             CURRENT WORKING SET
C     RANKA   INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX A
C     D1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     P1()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             REPRESENTING PERMUTATION MATRIX P1
C     P2()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             REPRESENTING PERMUTATION MATRIX P2 (IF IT IS USED)
C     D2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q2 (IF IT IS USED)
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING    T   T           T
C                         Q2 *P1 *(-H) OR P1 *(-H)
C     H()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C             CONTAINING THE VALUE OF THE CONSTRAINTS AT X
C     L       INTEGER SCALAR CONTAINING TOTAL NUMBER OF CONSTRAINTS
C     MDF     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY FMAT
C     PIVOT() REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKA
C             CONTAINING INFO. TO FORM Q1
C     GMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDG*N
C             CONTAINING MATRIX R AND INFO. TO FORM Q2 (IF IT IS USED)
C     MDG     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY GMAT
C
C     ON RETURN@D
C
C     DX()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C             CONTAINS THE COMPUTED SEARCH DIRECTION
C             (PROVIDED ERROR=0)
C     EVAL    INTEGER SCALAR-CONTAINS NUMBER OF FUNCTION EVALUATIONS
C             DONE INSIDE THIS ROUTINE
C     ERROR   INTEGER SCALAR = 0 IF NO TROUBLE
C             =-3 IF THE REDUCED HESSIAN MATRIX IS NOT POS. DEF.
C             < -10 AS A USER STOP INDICATOR
C
C     WORKING AREAS@D
C
C     FMAT(,) REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDF*N
C     D(),V1(),V2() REAL SINGLY SUBSCRIPTED ARRAYS ALL OF DIMENSION M
C
C     INTERNAL VARIABLES
C
      INTEGER I,TP1,NMT,J,INFO,NMR
      TP1=RANKA+1
      NMT=N-T
      NMR=N-RANKA
C
C     MOVE -F TO D
C
      DO 10 I=1,M
              D(I)=-F(I)
   10 CONTINUE
C                    T      T
C     FORM  D@D= P3*(U @D0)*Q3 *D
C
      CALL P3UTQ3(P3,NMT,C(1,TP1),MDC,D3,NMR,D,M,1,V2)
C                     T      T
C     FORM C1@D= P3 *(U @D0)*Q3 *C1
C
      CALL P3UTQ3(P3,NMT,C(1,TP1),MDC,D3,NMR,C,M,RANKA,V2)
      IF(RANKA.EQ.0) GOTO 30
C                 -1                  -1
C     FORM DY1@D= R  *B2   OR   DY1@D= L  *B1
C     STORE IN DX(I) I=1,2,...,RANKA
C
      DO 20 I=1,RANKA
           DX(I)=B(I)
   20 CONTINUE
      IF(T.EQ.RANKA) CALL LSOLVE(MDA,T,A,DX)
      IF(T.GT.RANKA) CALL USOLVE(MDG,RANKA,GMAT,DX)
      IF(RANKA.EQ.N) GOTO 80
C                    T T     T
C     FORM C2@D= (U*P3 ) *U*P3
C
   30 CONTINUE
      CALL C2TC2(C(1,TP1),MDC,NMR,P3,NMT,V2)
C                      M
C     COMPUTE GMAT@D= SIGMA(F(I)*G )
C                     I=1        I
C
      CALL HESSF(FFUNC,GMAT,MDG,X,N,F,V1,V2,M,ERROR)
      IF(ERROR.LT.(-10)) RETURN
      EVAL=2*N*(N+1)
      IF(T.EQ.0) GOTO 40
C                             T
C     COMPUTE GMAT@D= GMAT - SIGMA(V(I)*K )
C                            I=1        I
C
      CALL HESSH(HFUNC,GMAT,MDG,X,N,V,ACTIVE,T,V1,V2,L,ERROR)
      IF(ERROR.LT.(-10)) RETURN
C
C               (E11 E12)      T   T
C     COMPUTE E=(       ) @D= P2 *Q1 *GMAT*Q1*P2  (STORE IN GMAT)
C               (E21 E22)
C
      CALL ECOMP(P2,A,MDA,N,D1,PIVOT,RANKA,T,GMAT,MDG)
   40 CONTINUE
C                         T
C     COMPUTE W22@D= E22+C2 *C2   (STORE IN GMAT(I,J) I=RANKA+1,...,N
C                                                   J=RANKA+1,...,N
C                         T
C     COMPUTE W21@D= E21+C2 *C1  (STORE IN GMAT(I,J) I=RANKA+1,...,N
C                                                   J=1,2,...,RANKA
C
      CALL WCOMP(GMAT(TP1,1),MDG,C,MDC,NMR,N)
      IF(RANKA.EQ.0) GOTO 50
C                         T
C     FORM D@D= -W21*DY1-C2 *F
C
      CALL YCOMP(RANKA,NMR,D,GMAT(TP1,1),MDG,DX)
   50 CONTINUE
      DO 60 I=1,NMR
           J=RANKA+I
           DX(J)=D(I)
   60 CONTINUE
C
C     SOLVE  W22*DY2 = D
C
      CALL DCHDC(GMAT(TP1,TP1),MDG,NMR,V2,1,0,INFO)
      ERROR=0
      IF(NMR.EQ.INFO) GOTO 70
C
C     MATRIX W22 IS NOT POSITIVE DEFINTE
C
      ERROR=-3
      RETURN
   70 CONTINUE
      CALL DPOSL(GMAT(TP1,TP1),MDG,NMR,DX(TP1))
C
C     BACKTRANSFORM
C
      IF(T.EQ.RANKA) GOTO 80
C
C     PERMUTE ELEMENTS IN DX
C
      CALL PV(P2,RANKA,DX,N,1)
   80 CONTINUE
      IF(RANKA.EQ.0) RETURN
C
C     COMPUTE DX@D= Q1*DX
C
      DO 90 I=1,RANKA
           J=RANKA-I+1
           CALL H12PER(2,J,J+1,N,A(J,1),MDA,D1(J),DX,1,MDA,1,
     1             PIVOT(J))
   90 CONTINUE
      RETURN
      END
CP3UTQ3
      SUBROUTINE P3UTQ3(P3,NMT,C2,MDC,D3,RANKC2,C,M,RANKA,V2)
      INTEGER NMT,MDC,RANKC2,M,RANKA
      INTEGER P3(1)
      DOUBLE PRECISION
     *     C2(MDC,1),D3(1),C(MDC,1),V2(M)
C                       T      T
C     COMPUTE  C@D= P3*(U @D0)*Q3 *C
C
C     ON ENTRY@D
C
C     P3()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION NMT
C             REPRESENTING PERMUTATION MATRIX P3
C     NMT     INTEGER SCALAR CONTAINING THE VALUE N-T
C     C2(,)   REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*RANKC2
C             CONTAINING MATRIX U AND INFO. TO FORM Q3
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF THE ARRAYS
C             C2 AND C
C     D3()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKC2
C             CONTAINING INFO. TO FORM Q3
C     RANKC2  INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX C2
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*RANKA
C             CONTAINING MATRIX C1
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     RANKA   INTEGER SCALAR CONTAINING PSEUDO RANK OF MATRIX A
C
C     ON RETURN
C
C     C(,)    CONTAINS THE MATRIX PRODUCT DEFINED ABOVE
C
C     WORKING AREA@D
C
C     V2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K
      DOUBLE PRECISION
     *     SUM
C                    T
C     COMPUTE  C@D= Q3 *C
C
      IF(RANKC2.LE.0) GOTO 60
      DO 10 I=1,RANKC2
           CALL H12PER(2,I,I+1,M,C2(1,I),1,D3(I),C,1,MDC,RANKA,C2(I,I))
   10 CONTINUE
C                    T
C     COMPUTE  C@D= (U @D0)*C
C
      DO 50 J=1,RANKA
           DO 20 K=1,RANKC2
                V2(K)=C(K,J)
   20      CONTINUE
           DO 40 I=1,RANKC2
                SUM=0.0D0
                DO 30 K=1,I
                   SUM=SUM+C2(K,I)*V2(K)
   30           CONTINUE
                C(I,J)=SUM
   40      CONTINUE
   50 CONTINUE
   60 CONTINUE
C
C     COMPUTE  C@D= P3*C
C
      CALL PV(P3,NMT,C,MDC,RANKA)
      RETURN
      END
CC2TC2
      SUBROUTINE C2TC2(C2,MDC,RANKC2,P3,NMT,V2)
      INTEGER MDC,RANKC2,NMT
      INTEGER P3(1)
      DOUBLE PRECISION
     *     C2(MDC,1),V2(1)
C                        T T     T
C     COMPUTE  C2@D= (U*P3 ) *U*P3
C
C     ON ENTRY@D
C
C     C2(,)   REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*RANKC2
C             CONTAINING THE UPPER TRIANGULAR MATRIX U
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C2
C     RANKC2  INTEGER SCALAR CONTAINING THE ORDER OF MATRIX U
C     P3()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION NMT
C             REPRESENTING PERMUTATION MATRIX P3
C     NMT     INTEGER SCALAR CONTAINING THE VALUE N-T
C
C     ON RETURN@D
C
C     C2(,)   CONTAINS THE MATRIX PRODUCT DEFINED ABOVE
C
C     WORKING AREA@D
C
C     V2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION RANKC2
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K
C
C     ZERO THE LOWER PART OF U
C
      IF(RANKC2.LE.1) GOTO 30
      DO 20 I=2,RANKC2
           K=I-1
           DO 10 J=1,K
                C2(I,J)=0.0D0
   10      CONTINUE
   20 CONTINUE
   30 CONTINUE
C
C     PERMUTE COLUMNS IN U
C
      CALL VPTR(P3,NMT,C2,MDC,RANKC2)
      IF(RANKC2.LE.0) RETURN
C                     T
C     COMPUTE  C2@D= C2 *C2
C
      CALL JTRJ(C2,MDC,RANKC2,V2)
      RETURN
      END
CECOMP
      SUBROUTINE ECOMP(P2,A,MDA,N,D1,PIVOT,RANKA,T,GMAT,MDG)
      INTEGER MDA,N,RANKA,T,MDG
      INTEGER P2(1)
      DOUBLE PRECISION
     *     A(MDA,N),D1(1),PIVOT(1),GMAT(MDG,N)
C                       T   T
C     COMPUTE  GMAT@D= P2 *Q1 *GMAT*Q1*P2
C                           T
C     BY FORMING   GMAT@D= Q1 *GMAT*Q1
C     AND THEN DO THE PERMUTATION IF P2 IS DIFFERENT FROM THE
C     IDENTITY MATRIX
C
C     INTERNAL VARIABLE
C
      INTEGER I
      DO 10 I=1,RANKA
           CALL H12PER(2,I,I+1,N,A(I,1),MDA,D1(I),GMAT,MDG,1,N,
     1                 PIVOT(I))
   10 CONTINUE
      DO 20 I=1,RANKA
           CALL H12PER(2,I,I+1,N,A(I,1),MDA,D1(I),GMAT,1,MDG,N,
     1               PIVOT(I))
   20 CONTINUE
      IF(T.EQ.RANKA) RETURN
C
C     DO THE PERMUTATION
C
      CALL PTRV(P2,RANKA,GMAT,MDG,RANKA)
      CALL VP(GMAT,MDG,RANKA,RANKA,P2)
      RETURN
      END
CWCOMP
      SUBROUTINE WCOMP(W,MDW,C,MDC,NMT,N)
      INTEGER MDW,MDC,NMT,N
      DOUBLE PRECISION
     *     W(MDW,N),C(MDC,N)
C
C     COMPUTE  W@D= W+C     WHERE
C     BOTH W AND C ARE NMT*N
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DO 20 I=1,NMT
           DO 10 J=1,N
                W(I,J)=W(I,J)+C(I,J)
   10      CONTINUE
   20 CONTINUE
      RETURN
      END
CHSUM
      DOUBLE PRECISION
     *FUNCTION HSUM(ACTIVE,T,H,W,L)
      INTEGER T,L
      INTEGER ACTIVE(1)
      DOUBLE PRECISION
     *     H(L),W(L)
C
C     COMPUTE THE CONSTRAINT PART OF THE MERIT FUNCTION
C
C     HSUM @D= SIGMA(W(I)*H(I)**2)+SIGMA(W(J)*MIN(0,H(J))**2)
C     WHERE
C            INDEX I BELONGS TO CURRENT WORKING SET
C            INDEX J BELONGS TO CURRENT INACTIVE SET
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     HVAL
      HSUM=0.0D0
      IF(L.LE.0) RETURN
      DO 70 J=1,L
           IF(T.LE.0) GOTO 40
           DO 30 I=1,T
                IF(J.EQ.ACTIVE(I)) GOTO 50
   30      CONTINUE
   40      CONTINUE
           HVAL=DMIN1(0.0D0,H(J))
           GOTO 60
   50      CONTINUE
           HVAL=H(J)
   60      CONTINUE
           HSUM=HSUM+W(J)*HVAL**2
   70 CONTINUE
      RETURN
      END
CUNSCR
      SUBROUTINE UNSCR(ACTIVE,BND,L,P)
      INTEGER BND,L,P
      INTEGER ACTIVE(1)
C
C     UNSCRAMBLE THE ARRAY WHICH HOLDS INFORMATION OF THE
C     APPEARANCE IN WORKING SET
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,LMP
      LMP=L-P
      IF(LMP.LE.0) GOTO 20
      DO 10 I=1,LMP
           J=BND+I
           IF(ACTIVE(J).EQ.(-1)) ACTIVE(J)=0
           IF(ACTIVE(J).GE.   2) ACTIVE(J)=1
   10 CONTINUE
   20 CONTINUE
      RETURN
      END
CPREOBJ
      SUBROUTINE PREOBJ(C,MDC,M,RANKA,DX,F,T,FC1DY1,C1DY1)
      INTEGER MDC,M,RANKA,T
      DOUBLE PRECISION
     *     FC1DY1,C1DY1
      DOUBLE PRECISION
     *     C(MDC,1),DX(1),F(M)
C
C     COMPUTE            T
C              FC1DY1 = F *C1*DY1
C               C1DY1 = II C1*DY1 II**2
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     VELEM
      FC1DY1=0.0D0
      C1DY1=0.0D0
      IF(T.LE.0) RETURN
      DO 30 I=1,M
           VELEM=0.0D0
           DO 20 J=1,RANKA
                VELEM=VELEM+C(I,J)*DX(J)
   20      CONTINUE
           FC1DY1=FC1DY1+F(I)*VELEM
           C1DY1=C1DY1+VELEM**2
   30 CONTINUE
      RETURN
      END
CNZESTM
      SUBROUTINE NZESTM(A,MDA,RANKA,T,B,V,W,U)
      INTEGER MDA,RANKA,T
      DOUBLE PRECISION
     *     A(MDA,RANKA),B(T),V(T),W(T),U(T)
C
C     COMPUTE THE NONZERO FIRST ORDER LAGRANGE MULTIPLIER
C     ESTIMATE BY FORMING               T -1
C                         VNZ @D= VL-(A*A )  *H
C     WHERE VL = THE LEAST SQUARES FIRST ORDER ESTIMATE
C           A  = THE JACOBIAN OF THE CONSTRAINTS IN WORKING SET
C           H  = THE VALUE OF THE CONSTRAINTS IN WORKING SET
C
C     ON ENTRY@D
C
C     A()     REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*RANKA
C             CONTAININNG MATRIX L IN THE DECOMPOSITION   T
C                                                      P1 *A*Q1 = (L@D0)
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     RANKA   INTEGER SCALAR CONTAINING THE ORDER OF MATRIX L
C     T       INTEGER SCALAR CONTAINING NO. OF CONSTRAINTS IN WORKING SET
C     B()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING   T
C                        P1 *(-H)
C     V()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINING   T
C                        P1 *VL
C
C     ON RETURN@D
C                        T        T   -T  -1
C     V()     CONTAINS P1 *VL + P1 *(L  *L  *B)
C
C     WORKING AREAS@D
C
C     W(),U() REAL SINGLY SUBSCRIPTED ARRAYS OF DIMENSION T
C
C     INTERNAL VARIABLES
C
      INTEGER I
      DOUBLE PRECISION
     *     RES
      DO 10 I=1,T
           W(I)=B(I)
   10 CONTINUE
C                   -1
C     COMPUTE W @D= L  *W
C
      CALL LSOLVE(MDA,RANKA,A,W)
C                   -T
C     COMPUTE U @D= L  *W
C
      CALL ATSOLV(A,MDA,RANKA,W,U,T,RES)
      DO 20 I=1,T
           V(I)=V(I)+U(I)
   20 CONTINUE
      RETURN
      END
CLEAEST
      SUBROUTINE LEAEST(A,MDA,T,F,M,V1,C,MDC,P1,SCALE,DIAG,V2,V,RES)
      INTEGER MDA,T,M,MDC,SCALE
      DOUBLE PRECISION
     *     RES
      INTEGER P1(1)
      DOUBLE PRECISION
     *     A(MDA,1),F(M),V1(M),C(MDC,1),DIAG(1),V2(1),V(1)
C
C     COMPUTE A SPECIAL LEAST SQUARES ESTIMATE OF LAGRANGE
C     MULTIPLIERS
C
C     SOLVE       T      T
C                A *V = C *(F+C*DX)     (1)
C
C     ON ENTRY@D
C
C     A(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDA*N
C             CONTAINING THE LOWER TRIANGULAR MATRIX L IN     T
C                                                     (L@D0)=P1 *A*D*Q1
C             AND INFO. TO FORM THE MATRIX Q1
C     MDA     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY A
C     T       INTEGER SCALAR CONTAINING NUMBER OF CONSTRAINTS
C             IN CURRENT WORKING SET
C     F()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE VALUES OF THE RESIDUALS
C     M       INTEGER SCALAR CONTAINING NUMBER OF RESIDUALS
C     V1()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION M
C             CONTAINING THE PRODUCT C*DX
C     C(,)    REAL DOUBLY SUBSCRIPTED ARRAY OF DIMENSION MDC*N
C             CONTAINING    (C1 @D U) WHERE  (C1@DC2)=C*Q1*FMAT*P2
C               T           (     0)    FMAT AND P2 MAY BE THE IDENTITY
C             Q3 *C2*P2=(U)
C                       (0)
C     MDC     INTEGER SCALAR CONTAINING LEADING DIMENSION OF ARRAY C
C     P1()    INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             REPRESENTING THE PERMUTATION MATRIX P1
C     SCALE   INTEGER SCALAR =0 IF NO ROW SCALING OF MATRIX A HAS
C             BEEN DONE. >0 IF SCALING HAS BEEN DONE
C     DIAG()  REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             REPRESENTING THE DIAGONAL SCALING MATRIX D IN
C             A*D
C
C
C     ON RETURN@D
C
C     V()     REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C             CONTAINS THE SOLUTION V OF SYSTEM (1) ABOVE
C     RES     REAL SCALAR CONTAINS THE RESIDUAL OF (1) ABOVE
C
C     WORKING AREA@D
C
C     V2()    REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C
C     INTERNAL VARIABLES
C
      INTEGER I,J
      DOUBLE PRECISION
     *     SUM
      IF(T.LE.0) RETURN
C                  T
C     FORM G1 @D= C1 *(F+C*DX)
C
      DO 30 J=1,T
           SUM=0.0D0
           DO 20 I=1,M
             SUM=SUM+C(I,J)*(F(I)+V1(I))
   20      CONTINUE
           V2(J)=SUM
   30 CONTINUE
C
C     SOLVE  L(TR)*V = G1
C
      CALL ATSOLV(A,MDA,T,V2,V,T,RES)
C
C     PERMUTE
C
      CALL PV(P1,T,V,T,1)
      IF(SCALE.EQ.0) RETURN
      DO 50 I=1,T
        V(I)=DIAG(I)*V(I)
   50 CONTINUE
      RETURN
      END
CEUCMOD
      SUBROUTINE EUCMOD(CTRL,W,L,PSET,N,Y,TAU,WOLD)
      INTEGER CTRL,L,N
      INTEGER PSET(1)
      DOUBLE PRECISION
     *     TAU
      DOUBLE PRECISION
     *     W(1),Y(1),WOLD(1)
C
C     SOLVE THE PROBLEM
C
C           MINIMIZE II W II       (EUCLIDEAN NORM)
C      S.T.
C           Y(TR)*W >= TAU     (1)
C              W(I) >= WOLD(I) (2)
C
C     ON ENTRY@D
C
C     CTRL         INTEGER SCALAR CONTAINING AN INDICATOR
C                  = 1 WHEN THE >SIGN IN (1) IS NOT PRESENT
C                  = 2 WHEN THE >SIGN IN (1) IS PRESENT
C     W()          REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C                  CONTAINING WOLD (I.E. THE PENALTY CONSTANTS USED IN
C                  THE LATEST STEP)
C     L            INTEGER SCALAR CONTAINING THE TOTAL NUMBER OF
C                  CONSTRAINTS
C     PSET()       INTEGER SINGLY SUBSCRIPTED ARRAY OF DIMENSION N
C                  CONTAINING INDECES FOR THE POSITIVE ELEMENTS IN THE
C                  VECTOR Y
C     N            INTEGER SCALAR CONTAINING THE NUMBER OF POSITIVE Y(I)@DS
C     Y()          REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION T
C                  CONTAINING THE VECTOR Y IN PROBLEM (1)
C                  (DESTROYED ON RETURN)
C     TAU          REAL SCALAR CONTAING THE CONSTANT TAU IN (1)
C
C     ON RETURN@D
C
C     W()          CONTAINS THE NEW PENALTY CONSTANTS DERIVED BY SOLVING
C                  PROBLEM (1) ABOVE
C
C     WORKING AREA@D
C
C     WOLD()       REAL SINGLY SUBSCRIPTED ARRAY OF DIMENSION L
C
C     INTERNAL VARIABLES
C
      INTEGER I,J,K,NRUNCH,ISTOP
      DOUBLE PRECISION
     *     YTY,TAUNEW,SUM,CONST,PROD,YNORM,DNRM2
      IF(N.LE.0) RETURN
      DO 5 I=1,L
        WOLD(I)=W(I)
    5 CONTINUE
      YNORM=DNRM2(N,Y,1)
      YTY=YNORM**2
      IF(YNORM.NE. 0.0D0) CALL SCALV(Y,YNORM,N)
      TAUNEW=TAU
      SUM=0.0D0
      NRUNCH=N
   20 CONTINUE
           TAUNEW=TAUNEW-SUM
           IF(YTY.EQ. 0.0D0) CONST=1.0D0
           IF(YTY.NE. 0.0D0) CONST=TAUNEW/YTY
           YTY=0.0D0
           SUM=0.0D0
           ISTOP=NRUNCH
           K=1
   30      CONTINUE
                IF(K.GT.NRUNCH) GOTO 70
                I=PSET(K)
                PROD=CONST*Y(K)*YNORM
                IF(PROD .LT. WOLD(I)) GOTO 40
                W(I)=PROD
                YTY=YTY+Y(K)**2
                K=K+1
                GOTO 60
   40           CONTINUE
                SUM=SUM+W(I)*Y(K)*YNORM
                DO 50 J=K,NRUNCH
                   PSET(J)=PSET(J+1)
                   Y(J)=Y(J+1)
   50           CONTINUE
                NRUNCH=NRUNCH-1
   60           CONTINUE
           GOTO 30
   70      CONTINUE
           YTY=YTY*YNORM*YNORM
           IF((NRUNCH.LE.0).OR.(CTRL.EQ.2)) GOTO 80
      IF(ISTOP.NE.NRUNCH) GOTO 20
   80 CONTINUE
      RETURN
      END
C     LINPACK ROUTINES FOR ENLSIP
C     DOUBLE PRECISION VERSION 841005
C
CDPOSL
      SUBROUTINE DPOSL(A,LDA,N,B)
      INTEGER LDA,N
      DOUBLE PRECISION A(LDA,1),B(1)
C
C     DPOSL SOLVES THE DOUBLE PRECISION SYMMETRIC POSITIVE DEFINITE
C     SYSTEM A * X = B
C     USING THE FACTORS COMPUTED BY DPOCO OR DPOFA.
C
C     ON ENTRY
C
C        A       DOUBLE PRECISION(LDA, N)
C                THE OUTPUT FROM DPOCO OR DPOFA.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  A .
C
C        N       INTEGER
C                THE ORDER OF THE MATRIX  A .
C
C        B       DOUBLE PRECISION(N)
C                THE RIGHT HAND SIDE VECTOR.
C
C     ON RETURN
C
C        B       THE SOLUTION VECTOR  X .
C
C     ERROR CONDITION
C
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS
C        A ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES
C        SINGULARITY BUT IT IS USUALLY CAUSED BY IMPROPER SUBROUTINE
C        ARGUMENTS.  IT WILL NOT OCCUR IF THE SUBROUTINES ARE CALLED
C        CORRECTLY AND  INFO .EQ. 0 .
C
C     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
C     WITH  P  COLUMNS
C           CALL DPOCO(A,LDA,N,RCOND,Z,INFO)
C           IF (RCOND IS TOO SMALL .OR. INFO .NE. 0) GO TO ...
C           DO 10 J = 1, P
C              CALL DPOSL(A,LDA,N,C(1,J))
C        10 CONTINUE
C
C     LINPACK.  THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DDOT
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION DDOT,T
      INTEGER K,KB
C
C     SOLVE TRANS(R)*Y = B
C
      DO 10 K = 1, N
         T = DDOT(K-1,A(1,K),1,B(1),1)
         B(K) = (B(K) - T)/A(K,K)
   10 CONTINUE
C
C     SOLVE R*X = Y
C
      DO 20 KB = 1, N
         K = N + 1 - KB
         B(K) = B(K)/A(K,K)
         T = -B(K)
         CALL DAXPY(K-1,T,A(1,K),1,B(1),1)
   20 CONTINUE
      RETURN
      END
CDCHDC
      SUBROUTINE DCHDC(A,LDA,P,WORK,JPVT,JOB,INFO)
      INTEGER LDA,P,JPVT(1),JOB,INFO
      DOUBLE PRECISION A(LDA,1),WORK(1)
C
C     DCHDC COMPUTES THE CHOLESKY DECOMPOSITION OF A POSITIVE DEFINITE
C     MATRIX.  A PIVOTING OPTION ALLOWS THE USER TO ESTIMATE THE
C     CONDITION OF A POSITIVE DEFINITE MATRIX OR DETERMINE THE RANK
C     OF A POSITIVE SEMIDEFINITE MATRIX.
C
C     ON ENTRY
C
C         A      DOUBLE PRECISION(LDA,P).
C                A CONTAINS THE MATRIX WHOSE DECOMPOSITION IS TO
C                BE COMPUTED.  ONLT THE UPPER HALF OF A NEED BE STORED.
C                THE LOWER PART OF THE ARRAY A IS NOT REFERENCED.
C
C         LDA    INTEGER.
C                LDA IS THE LEADING DIMENSION OF THE ARRAY A.
C
C         P      INTEGER.
C                P IS THE ORDER OF THE MATRIX.
C
C         WORK   DOUBLE PRECISION.
C                WORK IS A WORK ARRAY.
C
C         JPVT   INTEGER(P).
C                JPVT CONTAINS INTEGERS THAT CONTROL THE SELECTION
C                OF THE PIVOT ELEMENTS, IF PIVOTING HAS BEEN REQUESTED.
C                EACH DIAGONAL ELEMENT A(K,K)
C                IS PLACED IN ONE OF THREE CLASSES ACCORDING TO THE
C                VALUE OF JPVT(K).
C
C                   IF JPVT(K) .GT. 0, THEN X(K) IS AN INITIAL
C                                      ELEMENT.
C
C                   IF JPVT(K) .EQ. 0, THEN X(K) IS A FREE ELEMENT.
C
C                   IF JPVT(K) .LT. 0, THEN X(K) IS A FINAL ELEMENT.
C
C                BEFORE THE DECOMPOSITION IS COMPUTED, INITIAL ELEMENTS
C                ARE MOVED BY SYMMETRIC ROW AND COLUMN INTERCHANGES TO
C                THE BEGINNING OF THE ARRAY A AND FINAL
C                ELEMENTS TO THE END.  BOTH INITIAL AND FINAL ELEMENTS
C                ARE FROZEN IN PLACE DURING THE COMPUTATION AND ONLY
C                FREE ELEMENTS ARE MOVED.  AT THE K-TH STAGE OF THE
C                REDUCTION, IF A(K,K) IS OCCUPIED BY A FREE ELEMENT
C                IT IS INTERCHANGED WITH THE LARGEST FREE ELEMENT
C                A(L,L) WITH L .GE. K.  JPVT IS NOT REFERENCED IF
C                JOB .EQ. 0.
C
C        JOB     INTEGER.
C                JOB IS AN INTEGER THAT INITIATES COLUMN PIVOTING.
C                IF JOB .EQ. 0, NO PIVOTING IS DONE.
C                IF JOB .NE. 0, PIVOTING IS DONE.
C
C     ON RETURN
C
C         A      A CONTAINS IN ITS UPPER HALF THE CHOLESKY FACTOR
C                OF THE MATRIX A AS IT HAS BEEN PERMUTED BY PIVOTING.
C
C         JPVT   JPVT(J) CONTAINS THE INDEX OF THE DIAGONAL ELEMENT
C                OF A THAT WAS MOVED INTO THE J-TH POSITION,
C                PROVIDED PIVOTING WAS REQUESTED.
C
C         INFO   CONTAINS THE INDEX OF THE LAST POSITIVE DIAGONAL
C                ELEMENT OF THE CHOLESKY FACTOR.
C
C     FOR POSITIVE DEFINITE MATRICES INFO = P IS THE NORMAL RETURN.
C     FOR PIVOTING WITH POSITIVE SEMIDEFINITE MATRICES INFO WILL
C     IN GENERAL BE LESS THAN P.  HOWEVER, INFO MAY BE GREATER THAN
C     THE RANK OF A, SINCE ROUNDING ERROR CAN CAUSE AN OTHERWISE ZERO
C     ELEMENT TO BE POSITIVE. INDEFINITE SYSTEMS WILL ALWAYS CAUSE
C     INFO TO BE LESS THAN P.
C
C     LINPACK. THIS VERSION DATED 03/19/79 .
C     J.J. DONGARRA AND G.W. STEWART, ARGONNE NATIONAL LABORATORY AND
C     UNIVERSITY OF MARYLAND.
C
C
C     BLAS DAXPY,DSWAP
C     FORTRAN DSQRT
C
C     INTERNAL VARIABLES
C
      INTEGER PU,PL,PLP1,I,J,JP,JT,K,KB,KM1,KP1,L,MAXL
      DOUBLE PRECISION TEMP
      DOUBLE PRECISION MAXDIA
      LOGICAL SWAPK,NEGK
C
      PL = 1
      PU = 0
      INFO = P
      IF (JOB .EQ. 0) GO TO 160
C
C        PIVOTING HAS BEEN REQUESTED. REARRANGE THE
C        THE ELEMENTS ACCORDING TO JPVT.
C
         DO 70 K = 1, P
            SWAPK = JPVT(K) .GT. 0
            NEGK = JPVT(K) .LT. 0
            JPVT(K) = K
            IF (NEGK) JPVT(K) = -JPVT(K)
            IF (.NOT.SWAPK) GO TO 60
               IF (K .EQ. PL) GO TO 50
                  CALL DSWAP(PL-1,A(1,K),1,A(1,PL),1)
                  TEMP = A(K,K)
                  A(K,K) = A(PL,PL)
                  A(PL,PL) = TEMP
                  PLP1 = PL + 1
                  IF (P .LT. PLP1) GO TO 40
                  DO 30 J = PLP1, P
                     IF (J .GE. K) GO TO 10
                        TEMP = A(PL,J)
                        A(PL,J) = A(J,K)
                        A(J,K) = TEMP
                     GO TO 20
   10                CONTINUE
                     IF (J .EQ. K) GO TO 20
                        TEMP = A(K,J)
                        A(K,J) = A(PL,J)
                        A(PL,J) = TEMP
   20                CONTINUE
   30             CONTINUE
   40             CONTINUE
                  JPVT(K) = JPVT(PL)
                  JPVT(PL) = K
   50          CONTINUE
               PL = PL + 1
   60       CONTINUE
   70    CONTINUE
         PU = P
         IF (P .LT. PL) GO TO 150
         DO 140 KB = PL, P
            K = P - KB + PL
            IF (JPVT(K) .GE. 0) GO TO 130
               JPVT(K) = -JPVT(K)
               IF (PU .EQ. K) GO TO 120
                  CALL DSWAP(K-1,A(1,K),1,A(1,PU),1)
                  TEMP = A(K,K)
                  A(K,K) = A(PU,PU)
                  A(PU,PU) = TEMP
                  KP1 = K + 1
                  IF (P .LT. KP1) GO TO 110
                  DO 100 J = KP1, P
                     IF (J .GE. PU) GO TO 80
                        TEMP = A(K,J)
                        A(K,J) = A(J,PU)
                        A(J,PU) = TEMP
                     GO TO 90
   80                CONTINUE
                     IF (J .EQ. PU) GO TO 90
                        TEMP = A(K,J)
                        A(K,J) = A(PU,J)
                        A(PU,J) = TEMP
   90                CONTINUE
  100             CONTINUE
  110             CONTINUE
                  JT = JPVT(K)
                  JPVT(K) = JPVT(PU)
                  JPVT(PU) = JT
  120          CONTINUE
               PU = PU - 1
  130       CONTINUE
  140    CONTINUE
  150    CONTINUE
  160 CONTINUE
      DO 270 K = 1, P
C
C        REDUCTION LOOP.
C
         MAXDIA = A(K,K)
         KP1 = K + 1
         MAXL = K
C
C        DETERMINE THE PIVOT ELEMENT.
C
         IF (K .LT. PL .OR. K .GE. PU) GO TO 190
            DO 180 L = KP1, PU
               IF (A(L,L) .LE. MAXDIA) GO TO 170
                  MAXDIA = A(L,L)
                  MAXL = L
  170          CONTINUE
  180       CONTINUE
  190    CONTINUE
C
C        QUIT IF THE PIVOT ELEMENT IS NOT POSITIVE.
C
         IF (MAXDIA .GT. 0.0D0) GO TO 200
            INFO = K - 1
C     ......EXIT
            GO TO 280
  200    CONTINUE
         IF (K .EQ. MAXL) GO TO 210
C
C           START THE PIVOTING AND UPDATE JPVT.
C
            KM1 = K - 1
            CALL DSWAP(KM1,A(1,K),1,A(1,MAXL),1)
            A(MAXL,MAXL) = A(K,K)
            A(K,K) = MAXDIA
            JP = JPVT(MAXL)
            JPVT(MAXL) = JPVT(K)
            JPVT(K) = JP
  210    CONTINUE
C
C        REDUCTION STEP. PIVOTING IS CONTAINED ACROSS THE ROWS.
C
         WORK(K) = DSQRT(A(K,K))
         A(K,K) = WORK(K)
         IF (P .LT. KP1) GO TO 260
         DO 250 J = KP1, P
            IF (K .EQ. MAXL) GO TO 240
               IF (J .GE. MAXL) GO TO 220
                  TEMP = A(K,J)
                  A(K,J) = A(J,MAXL)
                  A(J,MAXL) = TEMP
               GO TO 230
  220          CONTINUE
               IF (J .EQ. MAXL) GO TO 230
                  TEMP = A(K,J)
                  A(K,J) = A(MAXL,J)
                  A(MAXL,J) = TEMP
  230          CONTINUE
  240       CONTINUE
            A(K,J) = A(K,J)/WORK(K)
            WORK(J) = A(K,J)
            TEMP = -A(K,J)
            CALL DAXPY(J-K,TEMP,WORK(KP1),1,A(KP1,J),1)
  250    CONTINUE
  260    CONTINUE
  270 CONTINUE
  280 CONTINUE
      RETURN
      END
CDAXPY
      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
C
C     CONSTANT TIMES A VECTOR PLUS A VECTOR.
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DX(1),DY(1),DA
      INTEGER I,INCX,INCY,IXIY,M,MP1,N
C
      IF(N.LE.0)RETURN
      IF (DA .EQ. 0.0D0) RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DY(IY) = DY(IY) + DA*DX(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,4)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DY(I) = DY(I) + DA*DX(I)
   30 CONTINUE
      IF( N .LT. 4 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,4
        DY(I) = DY(I) + DA*DX(I)
        DY(I + 1) = DY(I + 1) + DA*DX(I + 1)
        DY(I + 2) = DY(I + 2) + DA*DX(I + 2)
        DY(I + 3) = DY(I + 3) + DA*DX(I + 3)
   50 CONTINUE
      RETURN
      END
CDCOPY
      SUBROUTINE  DCOPY(N,DX,INCX,DY,INCY)
C
C     COPIES A VECTOR, X, TO A VECTOR, Y.
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DX(1),DY(1)
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DY(IY) = DX(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,7)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DY(I) = DX(I)
   30 CONTINUE
      IF( N .LT. 7 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,7
        DY(I) = DX(I)
        DY(I + 1) = DX(I + 1)
        DY(I + 2) = DX(I + 2)
        DY(I + 3) = DX(I + 3)
        DY(I + 4) = DX(I + 4)
        DY(I + 5) = DX(I + 5)
        DY(I + 6) = DX(I + 6)
   50 CONTINUE
      RETURN
      END
CDDOT
      DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
C
C     FORMS THE DOT PRODUCT OF TWO VECTORS.
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DX(1),DY(1),DTEMP
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
C
      DDOT = 0.0D0
      DTEMP = 0.0D0
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DTEMP = DTEMP + DX(IX)*DY(IY)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      DDOT = DTEMP
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DTEMP = DTEMP + DX(I)*DY(I)
   30 CONTINUE
      IF( N .LT. 5 ) GO TO 60
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
        DTEMP = DTEMP + DX(I)*DY(I) + DX(I + 1)*DY(I + 1) +
     *   DX(I + 2)*DY(I + 2) + DX(I + 3)*DY(I + 3) + DX(I + 4)*DY(I + 4)
   50 CONTINUE
   60 DDOT = DTEMP
      RETURN
      END
CDNRM2
      DOUBLE PRECISION FUNCTION DNRM2 ( N, DX, INCX)
      INTEGER          NEXT
      DOUBLE PRECISION   DX(1), CUTLO, CUTHI, HITEST, SUM, XMAX,ZERO,ONE
      double precision dtemp
      DATA   ZERO, ONE /0.0D0, 1.0D0/
C
C     EUCLIDEAN NORM OF THE N-VECTOR STORED IN DX() WITH STORAGE
C     INCREMENT INCX .
C     IF    N .LE. 0 RETURN WITH RESULT = 0.
C     IF N .GE. 1 THEN INCX MUST BE .GE. 1
C
C           C.L.LAWSON, 1978 JAN 08
C
C     FOUR PHASE METHOD     USING TWO BUILT-IN CONSTANTS THAT ARE
C     HOPEFULLY APPLICABLE TO ALL MACHINES.
C         CUTLO = MAXIMUM OF  DSQRT(U/EPS)  OVER ALL KNOWN MACHINES.
C         CUTHI = MINIMUM OF  DSQRT(V)      OVER ALL KNOWN MACHINES.
C     WHERE
C         EPS = SMALLEST NO. SUCH THAT EPS + 1. .GT. 1.
C         U   = SMALLEST POSITIVE NO.   (UNDERFLOW LIMIT)
C         V   = LARGEST  NO.            (OVERFLOW  LIMIT)
C
C     BRIEF OUTLINE OF ALGORITHM..
C
C     PHASE 1    SCANS ZERO COMPONENTS.
C     MOVE TO PHASE 2 WHEN A COMPONENT IS NONZERO AND .LE. CUTLO
C     MOVE TO PHASE 3 WHEN A COMPONENT IS .GT. CUTLO
C     MOVE TO PHASE 4 WHEN A COMPONENT IS .GE. CUTHI/M
C     WHERE M = N FOR X() REAL AND M = 2*N FOR COMPLEX.
C
C     VALUES FOR CUTLO AND CUTHI..
C     FROM THE ENVIRONMENTAL PARAMETERS LISTED IN THE IMSL CONVERTER
C     DOCUMENT THE LIMITING VALUES ARE AS FOLLOWS..
C     CUTLO, S.P.   U/EPS = 2**(-102) FOR  HONEYWELL.  CLOSE SECONDS ARE
C                   UNIVAC AND DEC AT 2**(-103)
C                   THUS CUTLO = 2**(-51) = 4.44089E-16
C     CUTHI, S.P.   V = 2**127 FOR UNIVAC, HONEYWELL, AND DEC.
C                   THUS CUTHI = 2**(63.5) = 1.30438E19
C     CUTLO, D.P.   U/EPS = 2**(-67) FOR HONEYWELL AND DEC.
C                   THUS CUTLO = 2**(-33.5) = 8.23181D-11
C     CUTHI, D.P.   SAME AS S.P.  CUTHI = 1.30438D19
C     DATA CUTLO, CUTHI / 8.232D-11,  1.304D19 /
C     DATA CUTLO, CUTHI / 4.441E-16,  1.304E19 /
      DATA CUTLO, CUTHI / 8.232D-11,  1.304D19 /
C
      IF(N .GT. 0) GO TO 10
         DNRM2  = ZERO
         GO TO 300
C
   10 ASSIGN 30 TO NEXT
      SUM = ZERO
      NN = N * INCX
C                                                 BEGIN MAIN LOOP
      I = 1
   20    GO TO NEXT,(30, 50, 70, 110)
   30 IF( ABS(DX(I)) .GT. CUTLO) GO TO 85
      ASSIGN 50 TO NEXT
      XMAX = ZERO
C
C                        PHASE 1.  SUM IS ZERO
C
   50 IF( DX(I) .EQ. ZERO) GO TO 200
      IF( ABS(DX(I)) .GT. CUTLO) GO TO 85
C
C                                PREPARE FOR PHASE 2.
      ASSIGN 70 TO NEXT
      GO TO 105
C
C                                PREPARE FOR PHASE 4.
C
  100 I = J
      ASSIGN 110 TO NEXT
      SUM = (SUM / DX(I)) / DX(I)
  105 XMAX = ABS(DX(I))
      GO TO 115
C
C                   PHASE 2.  SUM IS SMALL.
C                             SCALE TO AVOID DESTRUCTIVE UNDERFLOW.
C
   70 IF( ABS(DX(I)) .GT. CUTLO ) GO TO 75
C
C                     COMMON CODE FOR PHASES 2 AND 4.
C                     IN PHASE 4 SUM IS LARGE.  SCALE TO AVOID OVERFLOW.
C
  110 IF( ABS(DX(I)) .LE. XMAX ) GO TO 115
         SUM = ONE + SUM * (XMAX / DX(I))**2
         XMAX = ABS(DX(I))
         GO TO 200
C
  115 SUM = SUM + (DX(I)/XMAX)**2
      GO TO 200
C
C
C                  PREPARE FOR PHASE 3.
C
   75 SUM = (SUM * XMAX) * XMAX
C
C
C     FOR REAL OR D.P. SET HITEST = CUTHI/N
C     FOR COMPLEX      SET HITEST = CUTHI/(2*N)
C
   85 HITEST = CUTHI/dble( N )
C
C                   PHASE 3.  SUM IS MID-RANGE.  NO SCALING.
C
      DO 95 J =I,NN,INCX
      IF(ABS(DX(J)) .GE. HITEST) GO TO 100
	 dtemp=dx(j)*dx(j)
   95    SUM = dtemp+SUM
      DNRM2 = SQRT( SUM )
      GO TO 300
C
  200 CONTINUE
      I = I + INCX
      IF ( I .LE. NN ) GO TO 20
C
C              END OF MAIN LOOP.
C
C              COMPUTE SQUARE ROOT AND ADJUST FOR SCALING.
C
      DNRM2 = XMAX * SQRT(SUM)
  300 CONTINUE
      RETURN
      END
CDSCAL
      SUBROUTINE  DSCAL(N,DA,DX,INCX)
C
C     SCALES A VECTOR BY A CONSTANT.
C     USES UNROLLED LOOPS FOR INCREMENT EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DA,DX(1)
      INTEGER I,INCX,M,MP1,N,NINCX
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1)GO TO 20
C
C        CODE FOR INCREMENT NOT EQUAL TO 1
C
      NINCX = N*INCX
      DO 10 I = 1,NINCX,INCX
        DX(I) = DA*DX(I)
   10 CONTINUE
      RETURN
C
C        CODE FOR INCREMENT EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DX(I) = DA*DX(I)
   30 CONTINUE
      IF( N .LT. 5 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
        DX(I) = DA*DX(I)
        DX(I + 1) = DA*DX(I + 1)
        DX(I + 2) = DA*DX(I + 2)
        DX(I + 3) = DA*DX(I + 3)
        DX(I + 4) = DA*DX(I + 4)
   50 CONTINUE
      RETURN
      END
CDSWAP
      SUBROUTINE  DSWAP (N,DX,INCX,DY,INCY)
C
C     INTERCHANGES TWO VECTORS.
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DX(1),DY(1),DTEMP
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C       CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS NOT EQUAL
C         TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DTEMP = DX(IX)
        DX(IX) = DY(IY)
        DY(IY) = DTEMP
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C       CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C       CLEAN-UP LOOP
C
   20 M = MOD(N,3)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DTEMP = DX(I)
        DX(I) = DY(I)
        DY(I) = DTEMP
   30 CONTINUE
      IF( N .LT. 3 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,3
        DTEMP = DX(I)
        DX(I) = DY(I)
        DY(I) = DTEMP
        DTEMP = DX(I + 1)
        DX(I + 1) = DY(I + 1)
        DY(I + 1) = DTEMP
        DTEMP = DX(I + 2)
        DX(I + 2) = DY(I + 2)
        DY(I + 2) = DTEMP
   50 CONTINUE
      RETURN
      END
